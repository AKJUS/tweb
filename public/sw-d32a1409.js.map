{"version":3,"file":"sw-d32a1409.js","sources":["src/config/modes.ts","src/config/debug.ts","src/environment/ctx.ts","src/environment/userAgent.ts","src/helpers/context.ts","src/helpers/dT.ts","src/lib/logger.ts","src/helpers/schedulers/pause.ts","src/lib/serviceWorker/cache.ts","src/helpers/blob/readBlobAs.ts","src/helpers/blob/readBlobAsArrayBuffer.ts","src/helpers/blob/readBlobAsUint8Array.ts","src/helpers/noop.ts","src/helpers/cancellablePromise.ts","src/helpers/schedulers/debounce.ts","src/helpers/blob/blobSafeMimeType.ts","src/helpers/blob/blobConstruct.ts","src/lib/files/memoryWriter.ts","src/helpers/makeError.ts","src/lib/files/cacheStorage.ts","src/lib/serviceWorker/timeout.ts","src/lib/serviceWorker/stream.ts","src/config/databases/state.ts","src/config/notifications.ts","src/helpers/object/deepEqual.ts","src/helpers/object/safeAssign.ts","src/lib/files/idb.ts","src/lib/serviceWorker/push.ts","src/config/tabId.ts","src/helpers/array/indexOfAndSplice.ts","src/helpers/array/findAndSplice.ts","src/helpers/eventListenerBase.ts","src/lib/mtproto/superMessagePort.ts","src/lib/serviceWorker/serviceMessagePort.ts","src/helpers/listenMessagePort.ts","src/lib/serviceWorker/download.ts","src/lib/serviceWorker/share.ts","src/lib/serviceWorker/index.service.ts"],"sourcesContent":["/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n *\r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport type {TransportType} from '../lib/mtproto/dcConfigurator';\r\n\r\nconst Modes = {\r\n  test: location.search.indexOf('test=1') > 0/*  || true */,\r\n  debug: location.search.indexOf('debug=1') > 0,\r\n  http: false,\r\n  ssl: true, // location.search.indexOf('ssl=1') > 0 || location.protocol === 'https:' && location.search.indexOf('ssl=0') === -1,\r\n  multipleConnections: true,\r\n  asServiceWorker: false,\r\n  transport: 'websocket' as TransportType,\r\n  noSharedWorker: location.search.indexOf('noSharedWorker=1') > 0\r\n};\r\n\r\nif(import.meta.env.VITE_MTPROTO_HAS_HTTP) {\r\n  Modes.http = location.search.indexOf('http=1') > 0;\r\n}\r\n\r\nif(import.meta.env.VITE_MTPROTO_HAS_HTTP || !import.meta.env.VITE_MTPROTO_HAS_WS) {\r\n  Modes.http = true;\r\n}\r\n\r\nif(Modes.http) {\r\n  Modes.transport = 'https';\r\n}\r\n\r\nif(import.meta.env.VITE_MTPROTO_SW) {\r\n  Modes.asServiceWorker = true;\r\n}\r\n\r\nexport default Modes;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport Modes from './modes';\r\n\r\nexport const IS_BETA = import.meta.env.DEV;\r\nexport const DEBUG = (IS_BETA || Modes.debug)/*  && false */;\r\nconst ctx: any = typeof(window) !== 'undefined' ? window : self;\r\nexport const MOUNT_CLASS_TO: any = DEBUG || true/*  && false */ ? ctx : {};\r\nexport default DEBUG;\r\n\r\n// let m = DEBUG;\r\n/* if(!DEBUG) {\r\n  ctx.sandpitTurtle = () => {\r\n    //if(!m) {\r\n      for(let i in MOUNT_CLASS_TO) {\r\n        ctx[i] = MOUNT_CLASS_TO[i];\r\n      }\r\n      //m = true;\r\n    //}\r\n\r\n    //DEBUG = !DEBUG;\r\n  };\r\n} */\r\n\r\n/* export const superDebug = (object: any, key: string) => {\r\n  var d = object[key];\r\n  var beforeStr = '', afterStr = '';\r\n  for(var r of d) {\r\n    beforeStr += r.before.hex + '\\n';\r\n    afterStr += r.after.hex + '\\n';\r\n  }\r\n\r\n  beforeStr = beforeStr.trim();\r\n  afterStr = afterStr.trim();\r\n  //var beforeStr = d.map((r) => r.before.hex).join('\\n');\r\n  //var afterStr = d.map((r) => r.after.hex).join('\\n');\r\n\r\n  var dada = (name: string, str: string) => {\r\n    var a = document.createElement('a');\r\n    a.target = '_blank';\r\n    a.download = name + '.txt';\r\n    a.href = URL.createObjectURL(new Blob([str], {\r\n      type: 'text/plain'\r\n    }));\r\n    document.body.append(a);\r\n    a.click();\r\n  };\r\n\r\n  dada(key + '_' + 'before', beforeStr);\r\n  dada(key + '_' + 'after', afterStr);\r\n}\r\n\r\nMOUNT_CLASS_TO.superDebug = superDebug; */\r\n","const ctx = typeof(window) !== 'undefined' ? window : self;\r\n\r\nexport default ctx;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport ctx from './ctx';\r\n\r\nexport const USER_AGENT = navigator ? navigator.userAgent : null;\r\nexport const IS_APPLE = navigator.userAgent.search(/OS X|iPhone|iPad|iOS/i) !== -1;\r\nexport const IS_ANDROID = navigator.userAgent.toLowerCase().indexOf('android') !== -1;\r\nexport const IS_CHROMIUM = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\r\nexport const CHROMIUM_VERSION = (() => {\r\n  try {\r\n    return +navigator.userAgent.match(/Chrom(?:e|ium)\\/(.+?)(?:\\s|\\.)/)[1];\r\n  } catch(err) {\r\n  }\r\n})();\r\n\r\n// https://stackoverflow.com/a/58065241\r\nexport const IS_APPLE_MOBILE = (/iPad|iPhone|iPod/.test(navigator.platform) ||\r\n  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)) &&\r\n  !(ctx as any).MSStream;\r\n\r\nexport const IS_SAFARI = !!('safari' in ctx) || !!(USER_AGENT && (/\\b(iPad|iPhone|iPod)\\b/.test(USER_AGENT) || (!!USER_AGENT.match('Safari') && !USER_AGENT.match('Chrome'))))/*  || true */;\r\nexport const IS_FIREFOX = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\r\n\r\nexport const IS_MOBILE_SAFARI = IS_SAFARI && IS_APPLE_MOBILE;\r\n\r\nexport const IS_MOBILE = (navigator.maxTouchPoints === undefined || navigator.maxTouchPoints > 0) && navigator.userAgent.search(/iOS|iPhone OS|Android|BlackBerry|BB10|Series ?[64]0|J2ME|MIDP|opera mini|opera mobi|mobi.+Gecko|Windows Phone/i) != -1;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n// в SW может быть сразу две переменных TRUE\r\nexport const IS_SERVICE_WORKER = typeof ServiceWorkerGlobalScope !== 'undefined' && self instanceof ServiceWorkerGlobalScope;\r\nexport const IS_WEB_WORKER = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && !IS_SERVICE_WORKER;\r\nexport const IS_WORKER = IS_WEB_WORKER || IS_SERVICE_WORKER;\r\n\r\nexport const getWindowClients = () => {\r\n  return (self as any as ServiceWorkerGlobalScope)\r\n  .clients\r\n  .matchAll({includeUncontrolled: false, type: 'window'});\r\n};\r\n\r\nexport const getLastWindowClient = () => getWindowClients().then((windowClients) => windowClients.slice(-1)[0]);\r\n\r\nconst postMessage = (listener: WindowClient | DedicatedWorkerGlobalScope, ...args: any[]) => {\r\n  try {\r\n    // @ts-ignore\r\n    listener.postMessage(...args);\r\n  } catch(err) {\r\n    console.error('[worker] postMessage error:', err, args);\r\n  }\r\n};\r\n\r\nconst notifyServiceWorker = (all: boolean, ...args: any[]) => {\r\n  getWindowClients().then((listeners) => {\r\n    if(!listeners.length) {\r\n      // console.trace('no listeners?', self, listeners);\r\n      return;\r\n    }\r\n\r\n    listeners.slice(all ? 0 : -1).forEach((listener) => {\r\n      postMessage(listener, ...args);\r\n    });\r\n  });\r\n};\r\n\r\nconst notifyWorker = (...args: any[]) => {\r\n  postMessage(self as any as DedicatedWorkerGlobalScope, ...args);\r\n};\r\n\r\nconst noop = () => {};\r\n\r\nexport const notifySomeone = IS_SERVICE_WORKER ? notifyServiceWorker.bind(null, false) : (IS_WEB_WORKER ? notifyWorker : noop);\r\nexport const notifyAll = IS_SERVICE_WORKER ? notifyServiceWorker.bind(null, true) : (IS_WEB_WORKER ? notifyWorker : noop);\r\n","const _logTimer = Date.now();\r\nexport default function dT() {\r\n  return '[' + ((Date.now() - _logTimer) / 1000).toFixed(3) + ']';\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport DEBUG from '../config/debug';\r\nimport {IS_FIREFOX, IS_SAFARI} from '../environment/userAgent';\r\nimport {IS_SERVICE_WORKER, IS_WEB_WORKER} from '../helpers/context';\r\nimport dT from '../helpers/dT';\r\n\r\nexport enum LogTypes {\r\n  None = 0,\r\n  Error = 1,\r\n  Warn = 2,\r\n  Log = 4,\r\n  Debug = 8\r\n};\r\n\r\nexport const LOG_LEVELS = [LogTypes.None, LogTypes.Error, LogTypes.Warn, LogTypes.Log, LogTypes.Debug];\r\n\r\nconst IS_WEBKIT = IS_SAFARI || IS_FIREFOX;\r\n\r\n// let getCallerFunctionNameFromLine: (line: string) => string;\r\n// if(IS_WEBKIT) {\r\n//   getCallerFunctionNameFromLine = (line) => {\r\n//     const splitted = line.split('@');\r\n//     return splitted[0];\r\n//   };\r\n// } else {\r\n//   getCallerFunctionNameFromLine = (line: string) => {\r\n//     const splitted = line.trim().split(' ');\r\n//     if(splitted.length === 3) {\r\n//       return splitted[1].slice(splitted[1].lastIndexOf('.') + 1);\r\n//     }\r\n//   };\r\n// }\r\n\r\nconst STYLES_SUPPORTED = !IS_WEBKIT;\r\n// const LINE_INDEX = IS_WEBKIT ? 2 : 3;\r\n\r\n// function getCallerFunctionName() {\r\n//   const stack = new Error().stack;\r\n//   const lines = stack.split('\\n');\r\n//   const line = lines[LINE_INDEX] || lines[lines.length - 1];\r\n//   // const match = line.match(/\\.([^\\.]+?)\\s/);\r\n//   // line = match ? match[1] : line.trim();\r\n//   const caller = getCallerFunctionNameFromLine(line) || '<anonymous>';\r\n//   return '[' + caller + ']';\r\n// }\r\n\r\nexport const LOGGER_STYLES = {\r\n  reset: '\\x1b[0m',\r\n  bright: '\\x1b[1m',\r\n  dim: '\\x1b[2m',\r\n  underscore: '\\x1b[4m',\r\n  blink: '\\x1b[5m',\r\n  reverse: '\\x1b[7m',\r\n  hidden: '\\x1b[8m',\r\n  // Foreground (text) colors\r\n  fg: {\r\n    black: '\\x1b[30m',\r\n    red: '\\x1b[31m',\r\n    green: '\\x1b[32m',\r\n    yellow: '\\x1b[33m',\r\n    blue: '\\x1b[34m',\r\n    magenta: '\\x1b[35m',\r\n    cyan: '\\x1b[36m',\r\n    white: '\\x1b[37m'\r\n  },\r\n  // Background colors\r\n  bg: {\r\n    black: '\\x1b[40m',\r\n    red: '\\x1b[41m',\r\n    green: '\\x1b[42m',\r\n    yellow: '\\x1b[43m',\r\n    blue: '\\x1b[44m',\r\n    magenta: '\\x1b[45m',\r\n    cyan: '\\x1b[46m',\r\n    white: '\\x1b[47m'\r\n  }\r\n};\r\n\r\nexport type Logger = {\r\n  (...args: any[]): void;\r\n  warn(...args: any[]): void;\r\n  info(...args: any[]): void;\r\n  error(...args: any[]): void;\r\n  trace(...args: any[]): void;\r\n  debug(...args: any[]): void;\r\n  assert(...args: any[]): void;\r\n  // log(...args: any[]): void;\r\n  group(...args: any[]): void;\r\n  groupCollapsed(...args: any[]): void;\r\n  groupEnd(...args: any[]): void;\r\n  setPrefix(newPrefix: string): void;\r\n  setLevel(level: 0 | 1 | 2 | 3 | 4): void;\r\n  bindPrefix(prefix: string, type?: LogTypes): Logger;\r\n};\r\n\r\nconst methods: ['debug' | 'info' | 'warn' | 'error' | 'assert' | 'trace'/*  | 'log' */ | 'group' | 'groupCollapsed' | 'groupEnd', LogTypes][] = [\r\n  ['debug', LogTypes.Debug],\r\n  ['info', LogTypes.Log],\r\n  ['warn', LogTypes.Warn],\r\n  ['error', LogTypes.Error],\r\n  ['assert', LogTypes.Error],\r\n  ['trace', LogTypes.Log],\r\n  ['group', LogTypes.Log],\r\n  ['groupCollapsed', LogTypes.Log],\r\n  ['groupEnd', LogTypes.Log]\r\n  // [\"log\", LogTypes.Log]\r\n];\r\n\r\nexport function logger(prefix: string, type: LogTypes = LogTypes.Log | LogTypes.Warn | LogTypes.Error, ignoreDebugReset = false, style = ''): Logger {\r\n  let originalPrefix: string;\r\n  if(!DEBUG && !ignoreDebugReset/*  || true */) {\r\n    type = LogTypes.Error;\r\n  }\r\n\r\n  if(!STYLES_SUPPORTED) {\r\n    style = '';\r\n  } else if(!style) {\r\n    if(IS_SERVICE_WORKER) style = LOGGER_STYLES.fg.yellow;\r\n    else if(IS_WEB_WORKER) style = LOGGER_STYLES.fg.cyan;\r\n  }\r\n\r\n  const originalStyle = style;\r\n  if(style) style = `%s ${style}%s`;\r\n  else style = '%s';\r\n\r\n  // level = LogLevels.log | LogLevels.warn | LogLevels.error | LogLevels.debug\r\n\r\n  const log: Logger = function(...args: any[]) {\r\n    return type & LogTypes.Log && console.log(style, dT(), prefix, /* getCallerFunctionName(), */ ...args);\r\n  } as any;\r\n\r\n  methods.forEach(([method, logType]) => {\r\n    log[method] = function(...args: any[]) {\r\n      return type & logType && console[method](style, dT(), prefix, /* getCallerFunctionName(), */ ...args);\r\n    };\r\n  });\r\n\r\n  log.setPrefix = function(newPrefix: string) {\r\n    originalPrefix = newPrefix;\r\n    prefix = '[' + newPrefix + ']';\r\n  };\r\n\r\n  log.setPrefix(prefix);\r\n\r\n  log.setLevel = function(level: 0 | 1 | 2 | 3 | 4) {\r\n    type = LOG_LEVELS.slice(0, level + 1).reduce((acc, v) => acc | v, 0) as any;\r\n  };\r\n\r\n  log.bindPrefix = function(prefix: string, _type = type) {\r\n    return logger(`${originalPrefix}] [${prefix}`, _type, ignoreDebugReset, originalStyle);\r\n  };\r\n\r\n  return log;\r\n};\r\n","export default function pause(ms: number) {\r\n  return new Promise<void>((resolve) => {\r\n    setTimeout(resolve, ms);\r\n  });\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport pause from '../../helpers/schedulers/pause';\r\n\r\nconst ctx = self as any as ServiceWorkerGlobalScope;\r\nexport const CACHE_ASSETS_NAME = 'cachedAssets';\r\n\r\nfunction isCorrectResponse(response: Response) {\r\n  return response.ok && response.status === 200;\r\n}\r\n\r\nfunction timeoutRace<T extends Promise<any>>(promise: T) {\r\n  return Promise.race([\r\n    promise,\r\n    pause(10000).then(() => Promise.reject())\r\n  ]);\r\n}\r\n\r\nexport async function requestCache(event: FetchEvent) {\r\n  try {\r\n    // const cache = await ctx.caches.open(CACHE_ASSETS_NAME);\r\n    const cache = await timeoutRace(ctx.caches.open(CACHE_ASSETS_NAME));\r\n    const file = await timeoutRace(cache.match(event.request, {ignoreVary: true}));\r\n\r\n    if(file && isCorrectResponse(file)) {\r\n      return file;\r\n    }\r\n\r\n    const headers: HeadersInit = {'Vary': '*'};\r\n    let response = await fetch(event.request, {headers});\r\n    if(isCorrectResponse(response)) {\r\n      cache.put(event.request, response.clone());\r\n    } else if(response.status === 304) { // possible fix for 304 in Safari\r\n      const url = event.request.url.replace(/\\?.+$/, '') + '?' + (Math.random() * 100000 | 0);\r\n      response = await fetch(url, {headers});\r\n      if(isCorrectResponse(response)) {\r\n        cache.put(event.request, response.clone());\r\n      }\r\n    }\r\n\r\n    return response;\r\n  } catch(err) {\r\n    return fetch(event.request);\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n// import { IS_WEB_WORKER } from \"../context\";\r\n\r\n// const id = IS_WEB_WORKER ? Math.random() * 0x1000 | 0 : 0;\r\nexport default function readBlobAs(blob: Blob, method: 'readAsText'): Promise<string>;\r\nexport default function readBlobAs(blob: Blob, method: 'readAsDataURL'): Promise<string>;\r\nexport default function readBlobAs(blob: Blob, method: 'readAsArrayBuffer'): Promise<ArrayBuffer>;\r\nexport default function readBlobAs(blob: Blob, method: 'readAsArrayBuffer' | 'readAsText' | 'readAsDataURL'): Promise<any> {\r\n  // const perf = performance.now();\r\n  return new Promise<any>((resolve) => {\r\n    const reader = new FileReader();\r\n    reader.addEventListener('loadend', (e) => {\r\n      // console.log(`readBlobAs [${id}] ${method} time ${performance.now() - perf}`);\r\n      resolve(e.target.result);\r\n    });\r\n    reader[method](blob);\r\n  });\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport readBlobAs from './readBlobAs';\r\n\r\nexport default function readBlobAsArrayBuffer(blob: Blob) {\r\n  return readBlobAs(blob, 'readAsArrayBuffer');\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport readBlobAsArrayBuffer from './readBlobAsArrayBuffer';\r\n\r\nexport default function readBlobAsUint8Array(blob: Blob) {\r\n  return readBlobAsArrayBuffer(blob).then((buffer) => new Uint8Array(buffer));\r\n}\r\n","export default function noop() {}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport noop from './noop';\r\n\r\nexport interface CancellablePromise<T> extends Promise<T> {\r\n  resolve?: (value: T) => void,\r\n  reject?: (...args: any[]) => void,\r\n  cancel?: (reason?: any) => void,\r\n\r\n  notify?: (...args: any[]) => void,\r\n  notifyAll?: (...args: any[]) => void,\r\n  lastNotify?: any,\r\n  listeners?: Array<(...args: any[]) => void>,\r\n  addNotifyListener?: (callback: (...args: any[]) => void) => void,\r\n\r\n  isFulfilled?: boolean,\r\n  isRejected?: boolean,\r\n\r\n  onFinish?: () => void,\r\n  _resolve?: (value: T) => void,\r\n  _reject?: (...args: any[]) => void\r\n}\r\n\r\nconst deferredHelper = {\r\n  isFulfilled: false,\r\n  isRejected: false,\r\n\r\n  notify: () => {},\r\n  notifyAll: function(...args: any[]) {\r\n    this.lastNotify = args;\r\n    this.listeners?.forEach((callback: any) => callback(...args));\r\n  },\r\n\r\n  addNotifyListener: function(callback: (...args: any[]) => void) {\r\n    if(this.lastNotify) {\r\n      callback(...this.lastNotify);\r\n    }\r\n\r\n    (this.listeners ??= []).push(callback);\r\n  },\r\n\r\n  resolve: function(value) {\r\n    if(this.isFulfilled || this.isRejected) return;\r\n\r\n    this.isFulfilled = true;\r\n    this._resolve(value);\r\n    this.onFinish();\r\n  },\r\n\r\n  reject: function(...args) {\r\n    if(this.isRejected || this.isFulfilled) return;\r\n\r\n    this.isRejected = true;\r\n    this._reject(...args);\r\n    this.onFinish();\r\n  },\r\n\r\n  onFinish: function() {\r\n    this.notify = this.notifyAll = this.lastNotify = null;\r\n    if(this.listeners) this.listeners.length = 0;\r\n\r\n    if(this.cancel) {\r\n      this.cancel = noop;\r\n    }\r\n  }\r\n} as CancellablePromise<any>;\r\n\r\nexport default function deferredPromise<T>() {\r\n  let resolve: (value: T) => void, reject: (...args: any[]) => void;\r\n  const deferred: CancellablePromise<T> = new Promise<T>((_resolve, _reject) => {\r\n    resolve = _resolve, reject = _reject;\r\n  });\r\n\r\n  Object.assign(deferred, deferredHelper);\r\n  deferred._resolve = resolve;\r\n  deferred._reject = reject;\r\n\r\n  return deferred;\r\n}\r\n\r\n(self as any).deferredPromise = deferredPromise;\r\n","// * Jolly Cobra's schedulers\r\n\r\nimport ctx from '../../environment/ctx';\r\nimport {AnyFunction, Awaited} from '../../types';\r\nimport noop from '../noop';\r\n\r\nexport type DebounceReturnType<F extends AnyFunction> = {\r\n  (...args: Parameters<F>): Promise<Awaited<ReturnType<F>>>;\r\n  clearTimeout(): void;\r\n  isDebounced(): boolean;\r\n};\r\n\r\nexport default function debounce<F extends AnyFunction>(\r\n  fn: F,\r\n  ms: number,\r\n  shouldRunFirst = true,\r\n  shouldRunLast = true\r\n): DebounceReturnType<F> {\r\n  let waitingTimeout: number;\r\n  let waitingPromise: Promise<Awaited<ReturnType<F>>>, resolve: (result: any) => void, reject: () => void;\r\n  let hadNewCall = false;\r\n\r\n  const invoke = (args: Parameters<F>) => {\r\n    const _resolve = resolve, _reject = reject;\r\n    try {\r\n      const result = fn.apply(null, args);\r\n      _resolve(result);\r\n    } catch(err) {\r\n      console.error('debounce error', err);\r\n      // @ts-ignore\r\n      _reject(err);\r\n    }\r\n  };\r\n\r\n  const debounce = (...args: Parameters<F>) => {\r\n    if(!waitingPromise) waitingPromise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));\r\n\r\n    if(waitingTimeout) {\r\n      clearTimeout(waitingTimeout);\r\n      hadNewCall = true;\r\n      reject();\r\n      waitingPromise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));\r\n    } else if(shouldRunFirst) {\r\n      invoke(args);\r\n      hadNewCall = false;\r\n    }\r\n\r\n    const _waitingTimeout = ctx.setTimeout(() => {\r\n      // will run if should run last or first but with new call\r\n      if(shouldRunLast && (!shouldRunFirst || hadNewCall)) {\r\n        invoke(args);\r\n      }\r\n\r\n      // if debounce was called during invoking\r\n      if(waitingTimeout === _waitingTimeout) {\r\n        waitingTimeout = waitingPromise = resolve = reject = undefined;\r\n        hadNewCall = false;\r\n      }\r\n    }, ms);\r\n\r\n    waitingTimeout = _waitingTimeout;\r\n    waitingPromise.catch(noop);\r\n    return waitingPromise;\r\n  };\r\n\r\n  debounce.clearTimeout = () => {\r\n    if(waitingTimeout) {\r\n      ctx.clearTimeout(waitingTimeout);\r\n      reject();\r\n      waitingTimeout = waitingPromise = resolve = reject = undefined;\r\n      hadNewCall = false;\r\n    }\r\n  };\r\n\r\n  debounce.isDebounced = () => !!waitingTimeout;\r\n\r\n  return debounce;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n *\r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\n// https://www.iana.org/assignments/media-types/media-types.xhtml\r\nexport default function blobSafeMimeType(mimeType: string) {\r\n  if([\r\n    'image/jpeg',\r\n    'image/png',\r\n    'image/gif',\r\n    'image/svg+xml',\r\n    'image/webp',\r\n    'image/bmp',\r\n    'video/mp4',\r\n    'video/webm',\r\n    'video/quicktime',\r\n    'audio/ogg',\r\n    'audio/mpeg',\r\n    'audio/mp4',\r\n    'audio/wav', // though it is not in list\r\n    'application/json',\r\n    'application/pdf'\r\n  ].indexOf(mimeType) === -1) {\r\n    return 'application/octet-stream';\r\n  }\r\n\r\n  return mimeType;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n *\r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport blobSafeMimeType from './blobSafeMimeType';\r\n\r\nexport default function blobConstruct<T extends Uint8Array | string>(blobParts: Array<T> | T, mimeType: string = ''): Blob {\r\n  if(!Array.isArray(blobParts)) {\r\n    blobParts = [blobParts];\r\n  }\r\n\r\n  const safeMimeType = blobSafeMimeType(mimeType);\r\n  const blob = new Blob(blobParts, {type: safeMimeType});\r\n  return blob;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport blobConstruct from '../../helpers/blob/blobConstruct';\r\nimport StreamWriter from './streamWriter';\r\n\r\nexport default class MemoryWriter implements StreamWriter {\r\n  private bytes: Uint8Array;\r\n\r\n  constructor(\r\n    private mimeType: string,\r\n    private size: number,\r\n    private saveFileCallback?: (blob: Blob) => Promise<Blob>\r\n  ) {\r\n    this.bytes = new Uint8Array(size);\r\n  }\r\n\r\n  public async write(part: Uint8Array, offset: number) {\r\n    // sometimes file size can be bigger than the prov\r\n    const endOffset = offset + part.byteLength;\r\n    if(endOffset > this.bytes.byteLength) {\r\n      const newBytes = new Uint8Array(endOffset);\r\n      newBytes.set(this.bytes, 0);\r\n      this.bytes = newBytes;\r\n    }\r\n\r\n    this.bytes.set(part, offset);\r\n  };\r\n\r\n  public truncate() {\r\n    this.bytes = new Uint8Array();\r\n  }\r\n\r\n  public trim(size: number) {\r\n    this.bytes = this.bytes.slice(0, size);\r\n  }\r\n\r\n  public finalize(saveToStorage = true) {\r\n    const blob = blobConstruct(this.bytes, this.mimeType);\r\n\r\n    if(saveToStorage && this.saveFileCallback) {\r\n      this.saveFileCallback(blob);\r\n    }\r\n\r\n    return blob;\r\n  }\r\n\r\n  public getParts() {\r\n    return this.bytes;\r\n  }\r\n\r\n  public replaceParts(parts: Uint8Array) {\r\n    this.bytes = parts;\r\n  }\r\n}\r\n","const CACHED_ERRORS: {[key in Error['type']]?: ApiError} = {};\r\nexport default function makeError(type: Error['type']) {\r\n  return CACHED_ERRORS[type] ??= {\r\n    type\r\n  };\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport Modes from '../../config/modes';\r\nimport blobConstruct from '../../helpers/blob/blobConstruct';\r\nimport MemoryWriter from './memoryWriter';\r\nimport FileManager from './memoryWriter';\r\nimport FileStorage from './fileStorage';\r\nimport makeError from '../../helpers/makeError';\r\nimport deferredPromise from '../../helpers/cancellablePromise';\r\n\r\nexport type CacheStorageDbName = 'cachedFiles' | 'cachedStreamChunks' | 'cachedAssets';\r\n\r\nexport default class CacheStorageController implements FileStorage {\r\n  private static STORAGES: CacheStorageController[] = [];\r\n  private openDbPromise: Promise<Cache>;\r\n\r\n  private useStorage = true;\r\n\r\n  // private log: ReturnType<typeof logger> = logger('CS');\r\n\r\n  constructor(private dbName: CacheStorageDbName) {\r\n    if(Modes.test) {\r\n      this.dbName += '_test';\r\n    }\r\n\r\n    if(CacheStorageController.STORAGES.length) {\r\n      this.useStorage = CacheStorageController.STORAGES[0].useStorage;\r\n    }\r\n\r\n    this.openDatabase();\r\n    CacheStorageController.STORAGES.push(this);\r\n  }\r\n\r\n  private openDatabase(): Promise<Cache> {\r\n    return this.openDbPromise ?? (this.openDbPromise = caches.open(this.dbName));\r\n  }\r\n\r\n  public delete(entryName: string) {\r\n    return this.timeoutOperation((cache) => cache.delete('/' + entryName));\r\n  }\r\n\r\n  public deleteAll() {\r\n    return caches.delete(this.dbName);\r\n  }\r\n\r\n  public get(entryName: string) {\r\n    return this.timeoutOperation((cache) => cache.match('/' + entryName));\r\n  }\r\n\r\n  public save(entryName: string, response: Response) {\r\n    // return new Promise((resolve) => {}); // DEBUG\r\n    return this.timeoutOperation((cache) => cache.put('/' + entryName, response));\r\n  }\r\n\r\n  public getFile(fileName: string, method: 'blob' | 'json' | 'text' = 'blob'): Promise<any> {\r\n    // if(method === 'blob') {\r\n    //   return Promise.reject(makeError('NO_ENTRY_FOUND'));\r\n    // }\r\n\r\n    // const str = `get fileName: ${fileName}`;\r\n    // console.time(str);\r\n    return this.get(fileName).then((response) => {\r\n      if(!response) {\r\n        // console.warn('getFile:', response, fileName);\r\n        throw makeError('NO_ENTRY_FOUND');\r\n      }\r\n\r\n      const promise = response[method]();\r\n      // promise.then(() => {\r\n      //   console.timeEnd(str);\r\n      // });\r\n      return promise;\r\n    });\r\n  }\r\n\r\n  public saveFile(fileName: string, blob: Blob | Uint8Array) {\r\n    // return Promise.resolve(blobConstruct([blob]));\r\n    if(!(blob instanceof Blob)) {\r\n      blob = blobConstruct(blob);\r\n    }\r\n\r\n    const response = new Response(blob, {\r\n      headers: {\r\n        'Content-Length': '' + blob.size\r\n      }\r\n    });\r\n\r\n    return this.save(fileName, response).then(() => blob as Blob);\r\n  }\r\n\r\n  public timeoutOperation<T>(callback: (cache: Cache) => Promise<T>) {\r\n    if(!this.useStorage) {\r\n      return Promise.reject(makeError('STORAGE_OFFLINE'));\r\n    }\r\n\r\n    return new Promise<T>(async(resolve, reject) => {\r\n      let rejected = false;\r\n      const timeout = setTimeout(() => {\r\n        reject();\r\n        // console.warn('CACHESTORAGE TIMEOUT');\r\n        rejected = true;\r\n      }, 15e3);\r\n\r\n      try {\r\n        const cache = await this.openDatabase();\r\n        if(!cache) {\r\n          this.useStorage = false;\r\n          this.openDbPromise = undefined;\r\n          throw 'no cache?';\r\n        }\r\n\r\n        const res = await callback(cache);\r\n\r\n        if(rejected) return;\r\n        resolve(res);\r\n      } catch(err) {\r\n        reject(err);\r\n      }\r\n\r\n      clearTimeout(timeout);\r\n    });\r\n  }\r\n\r\n  public prepareWriting(fileName: string, fileSize: number, mimeType: string) {\r\n    return {\r\n      deferred: deferredPromise<Blob>(),\r\n      getWriter: () => {\r\n        const writer = new MemoryWriter(mimeType, fileSize, (blob) => {\r\n          return this.saveFile(fileName, blob).catch(() => blob);\r\n        });\r\n\r\n        return writer;\r\n      }\r\n    };\r\n  }\r\n\r\n  public static toggleStorage(enabled: boolean, clearWrite: boolean) {\r\n    return Promise.all(this.STORAGES.map((storage) => {\r\n      storage.useStorage = enabled;\r\n\r\n      if(!clearWrite) {\r\n        return;\r\n      }\r\n\r\n      if(!enabled) {\r\n        return storage.deleteAll();\r\n      }\r\n    }));\r\n  }\r\n}\r\n","export default function timeout(delay: number): Promise<Response> {\r\n  return new Promise(((resolve) => {\r\n    setTimeout(() => {\r\n      resolve(new Response('', {\r\n        status: 408,\r\n        statusText: 'Request timed out.'\r\n      }));\r\n    }, delay);\r\n  }));\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport readBlobAsUint8Array from '../../helpers/blob/readBlobAsUint8Array';\r\nimport deferredPromise, {CancellablePromise} from '../../helpers/cancellablePromise';\r\nimport debounce from '../../helpers/schedulers/debounce';\r\nimport pause from '../../helpers/schedulers/pause';\r\nimport {InputFileLocation} from '../../layer';\r\nimport CacheStorageController from '../files/cacheStorage';\r\nimport {DownloadOptions, MyUploadFile} from '../mtproto/apiFileManager';\r\nimport {getMtprotoMessagePort, log, serviceMessagePort} from './index.service';\r\nimport {ServiceRequestFilePartTaskPayload} from './serviceMessagePort';\r\nimport timeout from './timeout';\r\n\r\nconst deferredPromises: Map<MessagePort, {[taskId: string]: CancellablePromise<MyUploadFile>}> = new Map();\r\nconst cacheStorage = new CacheStorageController('cachedStreamChunks');\r\nconst CHUNK_TTL = 86400;\r\nconst CHUNK_CACHED_TIME_HEADER = 'Time-Cached';\r\nconst USE_CACHE = true;\r\nconst TEST_SLOW = false;\r\n\r\nconst clearOldChunks = () => {\r\n  return cacheStorage.timeoutOperation((cache) => {\r\n    return cache.keys().then((requests) => {\r\n      const filtered: Map<StreamId, Request> = new Map();\r\n      const timestamp = Date.now() / 1000 | 0;\r\n      for(const request of requests) {\r\n        const match = request.url.match(/\\/(\\d+?)\\?/);\r\n        if(match && !filtered.has(match[1])) {\r\n          filtered.set(match[1], request);\r\n        }\r\n      }\r\n\r\n      const promises: Promise<any>[] = [];\r\n      for(const [id, request] of filtered) {\r\n        const promise = cache.match(request).then((response) => {\r\n          if((+response.headers.get(CHUNK_CACHED_TIME_HEADER) + CHUNK_TTL) <= timestamp) {\r\n            log('will delete stream chunk:', id);\r\n            return cache.delete(request, {ignoreSearch: true, ignoreVary: true});\r\n          }\r\n        });\r\n\r\n        promises.push(promise);\r\n      }\r\n\r\n      return Promise.all(promises);\r\n    });\r\n  });\r\n};\r\n\r\nsetInterval(clearOldChunks, 1800e3);\r\nsetInterval(() => {\r\n  const mtprotoMessagePort = getMtprotoMessagePort();\r\n  for(const [messagePort, promises] of deferredPromises) {\r\n    if(messagePort === mtprotoMessagePort) {\r\n      continue;\r\n    }\r\n\r\n    for(const taskId in promises) {\r\n      const promise = promises[taskId];\r\n      promise.reject();\r\n    }\r\n\r\n    deferredPromises.delete(messagePort);\r\n  }\r\n}, 120e3);\r\n\r\ntype StreamRange = [number, number];\r\ntype StreamId = DocId;\r\nconst streams: Map<StreamId, Stream> = new Map();\r\nclass Stream {\r\n  private destroyDebounced: () => void;\r\n  private id: StreamId;\r\n  private limitPart: number;\r\n  private loadedOffsets: Set<number> = new Set();\r\n\r\n  constructor(private info: DownloadOptions) {\r\n    this.id = Stream.getId(info);\r\n    streams.set(this.id, this);\r\n\r\n    // ! если грузить очень большое видео чанками по 512Кб в мобильном Safari, то стрим не запустится\r\n    this.limitPart = info.size > (75 * 1024 * 1024) ? STREAM_CHUNK_UPPER_LIMIT : STREAM_CHUNK_MIDDLE_LIMIT;\r\n    this.destroyDebounced = debounce(this.destroy, 150000, false, true);\r\n  }\r\n\r\n  private destroy = () => {\r\n    streams.delete(this.id);\r\n  };\r\n\r\n  private async requestFilePartFromWorker(alignedOffset: number, limit: number, fromPreload = false) {\r\n    const payload: ServiceRequestFilePartTaskPayload = {\r\n      docId: this.id,\r\n      dcId: this.info.dcId,\r\n      offset: alignedOffset,\r\n      limit\r\n    };\r\n\r\n    const taskId = JSON.stringify(payload);\r\n\r\n    const mtprotoMessagePort = getMtprotoMessagePort();\r\n    let promises = deferredPromises.get(mtprotoMessagePort);\r\n    if(!promises) {\r\n      deferredPromises.set(mtprotoMessagePort, promises = {});\r\n    }\r\n\r\n    let deferred = promises[taskId];\r\n    if(deferred) {\r\n      return deferred.then((uploadFile) => uploadFile.bytes);\r\n    }\r\n\r\n    this.loadedOffsets.add(alignedOffset);\r\n\r\n    deferred = promises[taskId] = deferredPromise();\r\n\r\n    serviceMessagePort.invoke('requestFilePart', payload, undefined, mtprotoMessagePort)\r\n    .then(deferred.resolve.bind(deferred), deferred.reject.bind(deferred)).finally(() => {\r\n      if(promises[taskId] === deferred) {\r\n        delete promises[taskId];\r\n\r\n        if(!Object.keys(promises).length) {\r\n          deferredPromises.delete(mtprotoMessagePort);\r\n        }\r\n      }\r\n    });\r\n\r\n    const bytesPromise = deferred.then((uploadFile) => uploadFile.bytes);\r\n\r\n    if(USE_CACHE) {\r\n      this.saveChunkToCache(bytesPromise, alignedOffset, limit);\r\n      !fromPreload && this.preloadChunks(alignedOffset, alignedOffset + (this.limitPart * 15));\r\n    }\r\n\r\n    return bytesPromise;\r\n  }\r\n\r\n  private requestFilePartFromCache(alignedOffset: number, limit: number, fromPreload?: boolean) {\r\n    if(!USE_CACHE) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const key = this.getChunkKey(alignedOffset, limit);\r\n    return cacheStorage.getFile(key).then((blob: Blob) => {\r\n      return fromPreload ? new Uint8Array() : readBlobAsUint8Array(blob);\r\n    }, (error: ApiError) => {\r\n      if(error.type === 'NO_ENTRY_FOUND') {\r\n        return;\r\n      }\r\n    });\r\n  }\r\n\r\n  private requestFilePart(alignedOffset: number, limit: number, fromPreload?: boolean) {\r\n    const promise = this.requestFilePartFromCache(alignedOffset, limit, fromPreload).then((bytes) => {\r\n      return bytes || this.requestFilePartFromWorker(alignedOffset, limit, fromPreload);\r\n    });\r\n\r\n    if(TEST_SLOW) {\r\n      return promise.then((bytes) => {\r\n        log.warn('delaying chunk', alignedOffset, limit);\r\n        return pause(3000).then(() => {\r\n          log.warn('releasing chunk', alignedOffset, limit);\r\n          return bytes;\r\n        });\r\n      });\r\n    }\r\n\r\n    return promise;\r\n  }\r\n\r\n  private saveChunkToCache(deferred: Promise<Uint8Array>, alignedOffset: number, limit: number) {\r\n    return deferred.then((bytes) => {\r\n      const key = this.getChunkKey(alignedOffset, limit);\r\n      const response = new Response(bytes, {\r\n        headers: {\r\n          'Content-Length': '' + bytes.length,\r\n          'Content-Type': 'application/octet-stream',\r\n          [CHUNK_CACHED_TIME_HEADER]: '' + (Date.now() / 1000 | 0)\r\n        }\r\n      });\r\n\r\n      return cacheStorage.save(key, response);\r\n    });\r\n  }\r\n\r\n  private preloadChunk(offset: number) {\r\n    if(this.loadedOffsets.has(offset)) {\r\n      return;\r\n    }\r\n\r\n    this.loadedOffsets.add(offset);\r\n    this.requestFilePart(offset, this.limitPart, true);\r\n  }\r\n\r\n  private preloadChunks(offset: number, end: number) {\r\n    if(end > this.info.size) {\r\n      end = this.info.size;\r\n    }\r\n\r\n    if(!offset) { // load last chunk for bounds\r\n      this.preloadChunk(alignOffset(offset, this.limitPart));\r\n    } else { // don't preload next chunks before the start\r\n      for(; offset < end; offset += this.limitPart) {\r\n        this.preloadChunk(offset);\r\n      }\r\n    }\r\n  }\r\n\r\n  public requestRange(range: StreamRange) {\r\n    this.destroyDebounced();\r\n\r\n    const possibleResponse = responseForSafariFirstRange(range, this.info.mimeType, this.info.size);\r\n    if(possibleResponse) {\r\n      return possibleResponse;\r\n    }\r\n\r\n    let [offset, end] = range;\r\n\r\n    /* if(info.size > limitPart && isSafari && offset === limitPart) {\r\n      //end = info.size - 1;\r\n      //offset = info.size - 1 - limitPart;\r\n      offset = info.size - (info.size % limitPart);\r\n    } */\r\n\r\n    const limit = end && end < this.limitPart ? alignLimit(end - offset + 1) : this.limitPart;\r\n    const alignedOffset = alignOffset(offset, limit);\r\n\r\n    if(!end) {\r\n      end = Math.min(offset + limit, this.info.size - 1);\r\n    }\r\n\r\n    return this.requestFilePart(alignedOffset, limit).then((ab) => {\r\n      // log.debug('[stream] requestFilePart result:', result);\r\n\r\n      // if(isSafari) {\r\n      if(offset !== alignedOffset || end !== (alignedOffset + limit)) {\r\n        ab = ab.slice(offset - alignedOffset, end - alignedOffset + 1);\r\n      }\r\n\r\n      const headers: Record<string, string> = {\r\n        'Accept-Ranges': 'bytes',\r\n        'Content-Range': `bytes ${offset}-${offset + ab.byteLength - 1}/${this.info.size || '*'}`,\r\n        'Content-Length': `${ab.byteLength}`\r\n      };\r\n\r\n      if(this.info.mimeType) {\r\n        headers['Content-Type'] = this.info.mimeType;\r\n      }\r\n\r\n      // simulate slow connection\r\n      // setTimeout(() => {\r\n      return new Response(ab, {\r\n        status: 206,\r\n        statusText: 'Partial Content',\r\n        headers\r\n      });\r\n      // }, 2.5e3);\r\n    });\r\n  }\r\n\r\n  private getChunkKey(alignedOffset: number, limit: number) {\r\n    return this.id + '?offset=' + alignedOffset + '&limit=' + limit;\r\n  }\r\n\r\n  public static get(info: DownloadOptions) {\r\n    return streams.get(this.getId(info)) ?? new Stream(info);\r\n  }\r\n\r\n  private static getId(info: DownloadOptions) {\r\n    return (info.location as InputFileLocation.inputDocumentFileLocation).id;\r\n  }\r\n}\r\n\r\nexport default function onStreamFetch(event: FetchEvent, params: string) {\r\n  const range = parseRange(event.request.headers.get('Range'));\r\n  const info: DownloadOptions = JSON.parse(decodeURIComponent(params));\r\n  const stream = Stream.get(info);\r\n\r\n  // log.debug('[stream]', url, offset, end);\r\n\r\n  event.respondWith(Promise.race([\r\n    timeout(45 * 1000),\r\n    stream.requestRange(range)\r\n  ]));\r\n}\r\n\r\nfunction responseForSafariFirstRange(range: StreamRange, mimeType: string, size: number): Response {\r\n  if(range[0] === 0 && range[1] === 1) {\r\n    return new Response(new Uint8Array(2).buffer, {\r\n      status: 206,\r\n      statusText: 'Partial Content',\r\n      headers: {\r\n        'Accept-Ranges': 'bytes',\r\n        'Content-Range': `bytes 0-1/${size || '*'}`,\r\n        'Content-Length': '2',\r\n        'Content-Type': mimeType || 'video/mp4'\r\n      }\r\n    });\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/* const STREAM_CHUNK_UPPER_LIMIT = 256 * 1024;\r\nconst SMALLEST_CHUNK_LIMIT = 256 * 4; */\r\n/* const STREAM_CHUNK_UPPER_LIMIT = 1024 * 1024;\r\nconst SMALLEST_CHUNK_LIMIT = 1024 * 4; */\r\nconst STREAM_CHUNK_MIDDLE_LIMIT = 512 * 1024;\r\nconst STREAM_CHUNK_UPPER_LIMIT = 1024 * 1024;\r\nconst SMALLEST_CHUNK_LIMIT = 512 * 4;\r\n\r\nfunction parseRange(header: string): StreamRange {\r\n  if(!header) return [0, 0];\r\n  const [, chunks] = header.split('=');\r\n  const ranges = chunks.split(', ');\r\n  const [offset, end] = ranges[0].split('-');\r\n\r\n  return [+offset, +end || 0];\r\n}\r\n\r\nfunction alignOffset(offset: number, base = SMALLEST_CHUNK_LIMIT) {\r\n  return offset - (offset % base);\r\n}\r\n\r\nfunction alignLimit(limit: number) {\r\n  return 2 ** Math.ceil(Math.log(limit) / Math.log(2));\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport type {Database} from '.';\r\nimport type {IDBIndex} from '../../lib/files/idb';\r\n\r\nconst DATABASE_STATE: Database<'session' | 'stickerSets' | 'users' | 'chats' | 'messages' | 'dialogs'> = {\r\n  name: 'tweb',\r\n  version: 7,\r\n  stores: [{\r\n    name: 'session'\r\n  }, {\r\n    name: 'stickerSets'\r\n  }, {\r\n    name: 'users'\r\n  }, {\r\n    name: 'chats'\r\n  }, {\r\n    name: 'dialogs'\r\n    // indexes: [\r\n    //   ...(new Array(20 + 2).fill(0)).map((_, idx) => {\r\n    //     const name = `index_${idx}`;\r\n    //     const index: IDBIndex = {\r\n    //       indexName: name,\r\n    //       keyPath: name,\r\n    //       objectParameters: {}\r\n    //     };\r\n\r\n    //     return index\r\n    //   })\r\n    // ]\r\n  }, {\r\n    name: 'messages'\r\n  }]\r\n};\r\n\r\nexport default DATABASE_STATE;\r\n","export const NOTIFICATION_ICON_PATH = 'assets/img/logo_filled_rounded.png';\r\nexport const NOTIFICATION_BADGE_PATH = 'assets/img/logo_plain.svg'; // masked\r\n","/**\r\n * ignores `undefined` properties\r\n */\r\nexport default function deepEqual<T>(x: T, y: T, ignoreKeys?: (keyof T)[]): boolean {\r\n  const ignoreSet = ignoreKeys && new Set(ignoreKeys);\r\n  const okok = (obj: any) => Object.keys(obj).filter((key) => obj[key] !== undefined);\r\n  const ok = ignoreKeys ? (obj: any) => okok(obj).filter((key) => !ignoreSet.has(key as any)) : okok,\r\n    tx = typeof x,\r\n    ty = typeof y;\r\n  return x && y && tx === 'object' && tx === ty ? (\r\n    ok(x).length === ok(y).length &&\r\n      ok(x).every((key) => deepEqual((x as any)[key], (y as any)[key], ignoreKeys))\r\n  ) : (x === y);\r\n}\r\n","export default function safeAssign<T>(object: T, fromObject: any) {\r\n  if(fromObject) {\r\n    for(const i in fromObject) {\r\n      if(fromObject[i] !== undefined) {\r\n        // @ts-ignore\r\n        object[i] = fromObject[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  return object;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n *\r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport {Database} from '../../config/databases';\r\nimport Modes from '../../config/modes';\r\nimport makeError from '../../helpers/makeError';\r\nimport safeAssign from '../../helpers/object/safeAssign';\r\nimport {logger} from '../logger';\r\n\r\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/createIndex\r\n */\r\nexport type IDBIndex = {\r\n  indexName: string,\r\n  keyPath: string,\r\n  objectParameters: IDBIndexParameters\r\n};\r\n\r\nexport type IDBStore = {\r\n  name: string,\r\n  indexes?: IDBIndex[]\r\n};\r\n\r\nexport type IDBOptions = {\r\n  name?: string,\r\n  storeName: string,\r\n  stores?: IDBStore[],\r\n  version?: number\r\n};\r\n\r\nconst DEBUG = false;\r\n\r\nexport class IDB {\r\n  private static INSTANCES: IDB[] = [];\r\n  private openDbPromise: Promise<IDBDatabase>;\r\n  private db: IDBDatabase;\r\n  private storageIsAvailable: boolean;\r\n  private log: ReturnType<typeof logger>;\r\n  private name: string;\r\n  private version: number;\r\n  private stores: IDBStore[];\r\n\r\n  constructor(db: Database<any>) {\r\n    safeAssign(this, db);\r\n\r\n    if(Modes.test) {\r\n      this.name += '_test';\r\n    }\r\n\r\n    this.storageIsAvailable = true;\r\n    this.log = logger(['IDB', db.name].join('-'));\r\n    this.log('constructor');\r\n\r\n    this.openDatabase(true);\r\n\r\n    IDB.INSTANCES.push(this);\r\n  }\r\n\r\n  public isAvailable() {\r\n    return this.storageIsAvailable;\r\n  }\r\n\r\n  public openDatabase(createNew = false): Promise<IDBDatabase> {\r\n    if(this.openDbPromise && !createNew) {\r\n      return this.openDbPromise;\r\n    }\r\n\r\n    const createIndexes = (os: IDBObjectStore, store: IDBStore) => {\r\n      const indexNames = Array.from(os.indexNames);\r\n      for(const indexName of indexNames) {\r\n        os.deleteIndex(indexName);\r\n      }\r\n\r\n      if(!store.indexes?.length) {\r\n        return;\r\n      }\r\n\r\n      for(const index of store.indexes) {\r\n        if(os.indexNames.contains(index.indexName)) {\r\n          continue;\r\n        }\r\n\r\n        os.createIndex(index.indexName, index.keyPath, index.objectParameters);\r\n      }\r\n    };\r\n\r\n    const createObjectStore = (db: IDBDatabase, store: IDBStore) => {\r\n      const os = db.createObjectStore(store.name);\r\n      createIndexes(os, store);\r\n    };\r\n\r\n    try {\r\n      var request = indexedDB.open(this.name, this.version);\r\n\r\n      if(!request) {\r\n        return Promise.reject();\r\n      }\r\n    } catch(error) {\r\n      this.log.error('error opening db', (error as Error).message);\r\n      this.storageIsAvailable = false;\r\n      return Promise.reject(error);\r\n    }\r\n\r\n    let finished = false;\r\n    setTimeout(() => {\r\n      if(!finished) {\r\n        request.onerror(makeError('IDB_CREATE_TIMEOUT') as Event);\r\n      }\r\n    }, 3000);\r\n\r\n    return this.openDbPromise = new Promise<IDBDatabase>((resolve, reject) => {\r\n      request.onsuccess = (event) => {\r\n        finished = true;\r\n        const db = request.result;\r\n        let calledNew = false;\r\n\r\n        this.log('Opened');\r\n\r\n        db.onerror = (error) => {\r\n          this.storageIsAvailable = false;\r\n          this.log.error('Error creating/accessing IndexedDB database', error);\r\n          reject(error);\r\n        };\r\n\r\n        db.onclose = (e) => {\r\n          this.log.error('closed:', e);\r\n          !calledNew && this.openDatabase();\r\n        };\r\n\r\n        db.onabort = (e) => {\r\n          this.log.error('abort:', e);\r\n          const transaction = e.target as IDBTransaction;\r\n\r\n          this.openDatabase(calledNew = true);\r\n\r\n          if(transaction.onerror) {\r\n            transaction.onerror(e);\r\n          }\r\n\r\n          db.close();\r\n        };\r\n\r\n        db.onversionchange = (e) => {\r\n          this.log.error('onversionchange, lol?');\r\n        };\r\n\r\n        resolve(this.db = db);\r\n      };\r\n\r\n      request.onerror = (event) => {\r\n        finished = true;\r\n        this.storageIsAvailable = false;\r\n        this.log.error('Error creating/accessing IndexedDB database', event);\r\n        reject(event);\r\n      };\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        finished = true;\r\n        this.log.warn('performing idb upgrade from', event.oldVersion, 'to', event.newVersion);\r\n\r\n        const target = event.target as IDBOpenDBRequest;\r\n        const db = target.result;\r\n        this.stores.forEach((store) => {\r\n          /* if(db.objectStoreNames.contains(store.name)) {\r\n            //if(event.oldVersion === 1) {\r\n              db.deleteObjectStore(store.name);\r\n            //}\r\n          } */\r\n\r\n          if(!db.objectStoreNames.contains(store.name)) {\r\n            createObjectStore(db, store);\r\n          } else {\r\n            const txn = target.transaction;\r\n            const os = txn.objectStore(store.name);\r\n            createIndexes(os, store);\r\n          }\r\n        });\r\n      };\r\n    });\r\n  }\r\n\r\n  public static create<T extends Database<any>>(db: T) {\r\n    return this.INSTANCES.find((instance) => instance.name === db.name) ?? new IDB(db);\r\n  }\r\n\r\n  public static closeDatabases(preserve?: IDB) {\r\n    this.INSTANCES.forEach((storage) => {\r\n      if(preserve && preserve === storage) {\r\n        return;\r\n      }\r\n\r\n      const db = storage.db;\r\n      if(db) {\r\n        db.onclose = () => {};\r\n        db.close();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default class IDBStorage<T extends Database<any>, StoreName extends string = T['stores'][0]['name']> {\r\n  private log: ReturnType<typeof logger>;\r\n  private storeName: T['stores'][0]['name'];\r\n  private idb: IDB;\r\n\r\n  constructor(db: T, storeName: typeof db['stores'][0]['name']) {\r\n    this.storeName = storeName;\r\n    this.log = logger(['IDB', db.name, storeName].join('-'));\r\n    this.idb = IDB.create(db);\r\n  }\r\n\r\n  /**\r\n   * ! WARNING ! function requires at least one opened connection\r\n   */\r\n  /* public static clearObjectStores() {\r\n    const storage = this.STORAGES[0];\r\n    this.closeDatabases(storage);\r\n\r\n    const names = Array.from(storage.db.objectStoreNames);\r\n    const promises = names.map((name) => storage.clear(name));\r\n    return Promise.all(promises);\r\n  } */\r\n\r\n  /* public static deleteDatabase() {\r\n    this.closeDatabases();\r\n\r\n    const storages = this.STORAGES;\r\n    const dbNames = Array.from(new Set(storages.map((storage) => storage.name)));\r\n    const promises = dbNames.map((dbName) => {\r\n      return new Promise<void>((resolve, reject) => {\r\n        const deleteRequest = indexedDB.deleteDatabase(dbName);\r\n\r\n        deleteRequest.onerror = () => {\r\n          reject();\r\n        };\r\n\r\n        deleteRequest.onsuccess = () => {\r\n          resolve();\r\n        };\r\n      });\r\n    });\r\n\r\n    return Promise.all(promises);\r\n  } */\r\n\r\n  public delete(entryName: string | string[], storeName?: StoreName): Promise<void> {\r\n    // return Promise.resolve();\r\n    const isArray = Array.isArray(entryName);\r\n    if(!isArray) {\r\n      entryName = [].concat(entryName);\r\n    }\r\n\r\n    return this.getObjectStore('readwrite', (objectStore) => {\r\n      const promises = (entryName as string[]).map((entryName) => objectStore.delete(entryName));\r\n      return isArray ? promises : promises[0];\r\n    }, DEBUG ? 'delete: ' + (entryName as string[]).join(', ') : '', storeName);\r\n  }\r\n\r\n  public clear(storeName?: StoreName): Promise<void> {\r\n    return this.getObjectStore('readwrite', (objectStore) => objectStore.clear(), DEBUG ? 'clear' : '', storeName);\r\n  }\r\n\r\n  public save(entryName: string | string[], value: any | any[], storeName?: StoreName) {\r\n    // const handleError = (error: Error) => {\r\n    //   this.log.error('save: transaction error:', entryName, value, db, error, error && error.name);\r\n    //   if((!error || error.name === 'InvalidStateError')/*  && false */) {\r\n    //     setTimeout(() => {\r\n    //       this.save(entryName, value);\r\n    //     }, 2e3);\r\n    //   } else {\r\n    //     //console.error('IndexedDB saveFile transaction error:', error, error && error.name);\r\n    //   }\r\n    // };\r\n\r\n    const isArray = Array.isArray(entryName);\r\n    if(!isArray) {\r\n      entryName = [].concat(entryName);\r\n      value = [].concat(value);\r\n    }\r\n\r\n    return this.getObjectStore('readwrite', (objectStore) => {\r\n      const promises = (entryName as string[]).map((entryName, idx) => objectStore.put(value[idx], entryName));\r\n      return isArray ? promises : promises[0];\r\n    }, DEBUG ? 'save: ' + (entryName as string[]).join(', ') : '', storeName);\r\n  }\r\n\r\n  // public saveFile(fileName: string, blob: Blob | Uint8Array) {\r\n  //   //return Promise.resolve(blobConstruct([blob]));\r\n  //   if(!(blob instanceof Blob)) {\r\n  //     blob = blobConstruct(blob);\r\n  //   }\r\n\r\n  //   return this.save(fileName, blob);\r\n  // }\r\n\r\n  /* public saveFileBase64(db: IDBDatabase, fileName: string, blob: Blob | any): Promise<Blob> {\r\n    if(this.getBlobSize(blob) > 10 * 1024 * 1024) {\r\n      return Promise.reject();\r\n    }\r\n\r\n    if(!(blob instanceof Blob)) {\r\n      var safeMimeType = blobSafeMimeType(blob.type || 'image/jpeg');\r\n      var address = 'data:' + safeMimeType + ';base64,' + bytesToBase64(blob);\r\n      return this.storagePutB64String(db, fileName, address).then(() => {\r\n        return blob;\r\n      });\r\n    }\r\n\r\n    try {\r\n      var reader = new FileReader();\r\n    } catch (e) {\r\n      this.storageIsAvailable = false;\r\n      return Promise.reject();\r\n    }\r\n\r\n    let promise = new Promise<Blob>((resolve, reject) => {\r\n      reader.onloadend = () => {\r\n        this.storagePutB64String(db, fileName, reader.result as string).then(() => {\r\n          resolve(blob);\r\n        }, reject);\r\n      }\r\n\r\n      reader.onerror = reject;\r\n    });\r\n\r\n\r\n    try {\r\n      reader.readAsDataURL(blob);\r\n    } catch (e) {\r\n      this.storageIsAvailable = false;\r\n      return Promise.reject();\r\n    }\r\n\r\n    return promise;\r\n  }\r\n\r\n  public storagePutB64String(db: IDBDatabase, fileName: string, b64string: string) {\r\n    try {\r\n      var objectStore = db.transaction([this.storeName], 'readwrite')\r\n        .objectStore(this.storeName);\r\n      var request = objectStore.put(b64string, fileName);\r\n    } catch(error) {\r\n      this.storageIsAvailable = false;\r\n      return Promise.reject(error);\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      request.onsuccess = function(event) {\r\n        resolve();\r\n      };\r\n\r\n      request.onerror = reject;\r\n    });\r\n  }\r\n\r\n  public getBlobSize(blob: any) {\r\n    return blob.size || blob.byteLength || blob.length;\r\n  } */\r\n\r\n  public get<T>(entryName: string[], storeName?: StoreName): Promise<T[]>;\r\n  public get<T>(entryName: string, storeName?: StoreName): Promise<T>;\r\n  public get<T>(entryName: string | string[], storeName?: StoreName): Promise<T> | Promise<T[]> {\r\n    // return Promise.reject();\r\n\r\n    const isArray = Array.isArray(entryName);\r\n    if(!isArray) {\r\n      if(!entryName) {\r\n        return undefined;\r\n      }\r\n\r\n      entryName = [].concat(entryName);\r\n    } else if(!entryName.length) {\r\n      return Promise.resolve([]) as any;\r\n    }\r\n\r\n    return this.getObjectStore<T>('readonly', (objectStore) => {\r\n      const promises = (entryName as string[]).map((entryName) => objectStore.get(entryName));\r\n      return isArray ? promises : promises[0];\r\n    }, DEBUG ? 'get: ' + (entryName as string[]).join(', ') : '', storeName);\r\n  }\r\n\r\n  private getObjectStore<T>(\r\n    mode: IDBTransactionMode,\r\n    callback: (objectStore: IDBObjectStore) => IDBRequest | IDBRequest[],\r\n    log?: string,\r\n    storeName = this.storeName\r\n  ) {\r\n    let perf: number;\r\n\r\n    if(log) {\r\n      perf = performance.now();\r\n      this.log(log + ': start');\r\n    }\r\n\r\n    return this.idb.openDatabase().then((db) => {\r\n      return new Promise<T>((resolve, reject) => {\r\n        /* if(mode === 'readwrite') {\r\n          return;\r\n        } */\r\n\r\n        const transaction = db.transaction([storeName], mode);\r\n\r\n        const onError = () => {\r\n          clearTimeout(timeout);\r\n          reject(transaction.error);\r\n        };\r\n\r\n        // let resolved = false;\r\n        const onComplete = (/* what: string */) => {\r\n          clearTimeout(timeout);\r\n\r\n          if(log) {\r\n            this.log(log + ': end', performance.now() - perf/* , what */);\r\n          }\r\n\r\n          // if(resolved) {\r\n          //   return;\r\n          // }\r\n\r\n          // resolved = true;\r\n          const results = requests.map((r) => r.result);\r\n          resolve(isArray ? results : results[0]);\r\n        };\r\n\r\n        transaction.onerror = onError;\r\n\r\n        // * have to wait while clearing or setting something\r\n        const waitForTransactionComplete = mode === 'readwrite';\r\n        if(waitForTransactionComplete) {\r\n          transaction.oncomplete = () => onComplete(/* 'transaction' */);\r\n        }\r\n\r\n        const timeout = setTimeout(() => {\r\n          this.log.error('transaction not finished', transaction, log);\r\n        }, 10000);\r\n\r\n        /* transaction.addEventListener('abort', (e) => {\r\n          //handleError();\r\n          this.log.error('IndexedDB: transaction abort!', transaction.error);\r\n        }); */\r\n\r\n        const callbackResult = callback(transaction.objectStore(storeName));\r\n\r\n        const isArray = Array.isArray(callbackResult);\r\n        const requests: IDBRequest[] = isArray ? callbackResult : [].concat(callbackResult) as any;\r\n\r\n        if(waitForTransactionComplete) {\r\n          return;\r\n        }\r\n\r\n        const length = requests.length;\r\n        let left = length;\r\n\r\n        const onRequestFinished = () => {\r\n          if(transaction.error) {\r\n            return;\r\n          }\r\n\r\n          if(!--left) {\r\n            onComplete(/* 'requests' */);\r\n          }\r\n        };\r\n\r\n        for(let i = 0; i < length; ++i) {\r\n          const request = requests[i];\r\n          request.onerror = onError;\r\n          request.onsuccess = onRequestFinished;\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  public getAll<T>(storeName?: StoreName): Promise<T[]> {\r\n    return this.getObjectStore<T[]>('readonly', (objectStore) => objectStore.getAll(), DEBUG ? 'getAll' : '', storeName);\r\n  }\r\n\r\n  /* public getAllKeys(): Promise<Array<string>> {\r\n    console.time('getAllEntries');\r\n    return this.openDatabase().then((db) => {\r\n      var objectStore = db.transaction([this.storeName], 'readonly')\r\n        .objectStore(this.storeName);\r\n      var request = objectStore.getAllKeys();\r\n\r\n      return new Promise((resolve, reject) => {\r\n        request.onsuccess = function(event) {\r\n          // @ts-ignore\r\n          var result = event.target.result;\r\n          resolve(result);\r\n          console.timeEnd('getAllEntries');\r\n        }\r\n\r\n        request.onerror = reject;\r\n      });\r\n    });\r\n  } */\r\n\r\n  /* public isFileExists(fileName: string): Promise<boolean> {\r\n    console.time('isFileExists');\r\n    return this.openDatabase().then((db) => {\r\n      var objectStore = db.transaction([this.storeName], 'readonly')\r\n        .objectStore(this.storeName);\r\n      var request = objectStore.openCursor(fileName);\r\n\r\n      return new Promise((resolve, reject) => {\r\n        request.onsuccess = function(event) {\r\n          // @ts-ignore\r\n          var cursor = event.target.result;\r\n          resolve(!!cursor);\r\n          console.timeEnd('isFileExists');\r\n        }\r\n\r\n        request.onerror = reject;\r\n      });\r\n    });\r\n  } */\r\n\r\n  /* public getFileWriter(fileName: string, mimeType: string) {\r\n    var fakeWriter = FileManager.getFakeFileWriter(mimeType, (blob) => {\r\n      return this.saveFile(fileName, blob);\r\n    });\r\n\r\n    return Promise.resolve(fakeWriter);\r\n  } */\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n *\r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport {Database} from '../../config/databases';\r\nimport DATABASE_STATE from '../../config/databases/state';\r\nimport {NOTIFICATION_BADGE_PATH, NOTIFICATION_ICON_PATH} from '../../config/notifications';\r\nimport {IS_FIREFOX} from '../../environment/userAgent';\r\nimport deepEqual from '../../helpers/object/deepEqual';\r\nimport IDBStorage from '../files/idb';\r\nimport {log, serviceMessagePort} from './index.service';\r\nimport {ServicePushPingTaskPayload} from './serviceMessagePort';\r\n\r\nconst ctx = self as any as ServiceWorkerGlobalScope;\r\nconst defaultBaseUrl = location.protocol + '//' + location.hostname + location.pathname.split('/').slice(0, -1).join('/') + '/';\r\n\r\n// as in webPushApiManager.ts\r\nconst PING_PUSH_TIMEOUT = 10000 + 1500;\r\nlet lastPingTime = 0;\r\nlet localNotificationsAvailable = true;\r\n\r\nexport type PushNotificationObject = {\r\n  loc_key: string,\r\n  loc_args: string[],\r\n  // user_id: number, // should be number\r\n  custom: {\r\n    channel_id?: string, // should be number\r\n    chat_id?: string, // should be number\r\n    from_id?: string, // should be number\r\n    msg_id: string,\r\n    peerId?: string, // should be number\r\n    silent?: string // can be '1'\r\n  },\r\n  sound?: string,\r\n  random_id: number,\r\n  badge?: string, // should be number\r\n  description: string,\r\n  mute: string, // should be number\r\n  title: string,\r\n  message?: string,\r\n} & {\r\n  action?: 'mute1d' | 'push_settings', // will be set before postMessage to main thread\r\n};\r\n\r\nclass SomethingGetter<T extends Database<any>, Storage extends Record<string, any>> {\r\n  private cache: Partial<Storage> = {};\r\n  private storage: IDBStorage<T>;\r\n\r\n  constructor(\r\n    db: T,\r\n    storeName: typeof db['stores'][number]['name'],\r\n    private defaults: {\r\n      [Property in keyof Storage]: ((value: Storage[Property]) => Storage[Property]) | Storage[Property]\r\n    }\r\n  ) {\r\n    this.storage = new IDBStorage<T>(db, storeName);\r\n  }\r\n\r\n  private getDefault<T extends keyof Storage>(key: T) {\r\n    const callback = this.defaults[key];\r\n    return typeof(callback) === 'function' ? callback() : callback;\r\n  }\r\n\r\n  public get<T extends keyof Storage>(key: T) {\r\n    if(this.cache.hasOwnProperty(key)) {\r\n      return this.cache[key];\r\n    }\r\n\r\n    const promise = this.storage.get(key as string) as Promise<Storage[T]>;\r\n    return promise.then((value) => value, () => undefined as Storage[T]).then((value) => {\r\n      if(this.cache.hasOwnProperty(key)) {\r\n        return this.cache[key];\r\n      }\r\n\r\n      value ??= this.getDefault(key);\r\n\r\n      return this.cache[key] = value;\r\n    });\r\n  }\r\n\r\n  public getCached<T extends keyof Storage>(key: T) {\r\n    const value = this.get(key);\r\n    if(value instanceof Promise) {\r\n      throw 'no property';\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  public async set<T extends keyof Storage>(key: T, value: Storage[T]) {\r\n    const cached = this.cache[key] ?? this.defaults[key];\r\n    if(deepEqual(cached, value)) {\r\n      return;\r\n    }\r\n\r\n    this.cache[key] = value;\r\n\r\n    try {\r\n      this.storage.save(key as string, value);\r\n    } catch(err) {\r\n\r\n    }\r\n  }\r\n}\r\n\r\ntype PushStorage = {\r\n  push_mute_until: number,\r\n  push_lang: Partial<ServicePushPingTaskPayload['lang']>\r\n  push_settings: Partial<ServicePushPingTaskPayload['settings']>\r\n};\r\n\r\nconst defaults: PushStorage = {\r\n  push_mute_until: 0,\r\n  push_lang: {\r\n    push_message_nopreview: 'You have a new message',\r\n    push_action_mute1d: 'Mute for 24H',\r\n    push_action_settings: 'Settings'\r\n  },\r\n  push_settings: {}\r\n};\r\n\r\nconst getter = new SomethingGetter<typeof DATABASE_STATE, PushStorage>(DATABASE_STATE, 'session', defaults);\r\n\r\n// fill cache\r\nfor(const i in defaults) {\r\n  getter.get(i as keyof PushStorage);\r\n}\r\n\r\nctx.addEventListener('push', (event) => {\r\n  const obj: PushNotificationObject = event.data.json();\r\n  log('push', {...obj});\r\n\r\n  try {\r\n    const [muteUntil, settings, lang] = [\r\n      getter.getCached('push_mute_until'),\r\n      getter.getCached('push_settings'),\r\n      getter.getCached('push_lang')\r\n    ];\r\n\r\n    const nowTime = Date.now();\r\n    if(\r\n      userInvisibleIsSupported() &&\r\n      muteUntil &&\r\n      nowTime < muteUntil\r\n    ) {\r\n      throw `supress notification because mute for ${Math.ceil((muteUntil - nowTime) / 60000)} min`;\r\n    }\r\n\r\n    const hasActiveWindows = (Date.now() - lastPingTime) <= PING_PUSH_TIMEOUT && localNotificationsAvailable;\r\n    if(hasActiveWindows) {\r\n      throw 'supress notification because some instance is alive';\r\n    }\r\n\r\n    const notificationPromise = fireNotification(obj, settings, lang);\r\n    event.waitUntil(notificationPromise);\r\n  } catch(err) {\r\n    log(err);\r\n\r\n    // const tag = 'fix';\r\n    // const notificationPromise = ctx.registration.showNotification('Telegram', {tag});\r\n\r\n    // notificationPromise.then(() => {\r\n    //   closeAllNotifications(tag);\r\n    // });\r\n\r\n    // event.waitUntil(notificationPromise);\r\n  }\r\n});\r\n\r\nctx.addEventListener('notificationclick', (event) => {\r\n  const notification = event.notification;\r\n  log('on notification click', notification);\r\n  notification.close();\r\n\r\n  const action = event.action as PushNotificationObject['action'];\r\n  if(action === 'mute1d' && userInvisibleIsSupported()) {\r\n    log('[SW] mute for 1d');\r\n    getter.set('push_mute_until', Date.now() + 86400e3);\r\n    return;\r\n  }\r\n\r\n  const data: PushNotificationObject = notification.data;\r\n  if(!data) {\r\n    return;\r\n  }\r\n\r\n  const promise = ctx.clients.matchAll({\r\n    type: 'window'\r\n  }).then((clientList) => {\r\n    data.action = action;\r\n    pendingNotification = data;\r\n    for(let i = 0; i < clientList.length; ++i) {\r\n      const client = clientList[i];\r\n      if('focus' in client) {\r\n        client.focus();\r\n        serviceMessagePort.invokeVoid('pushClick', pendingNotification, client);\r\n        pendingNotification = undefined;\r\n        return;\r\n      }\r\n    }\r\n\r\n    if(ctx.clients.openWindow) {\r\n      return Promise.resolve(getter.get('push_settings')).then((settings) => {\r\n        return ctx.clients.openWindow(settings.baseUrl || defaultBaseUrl);\r\n      });\r\n    }\r\n  }).catch((error) => {\r\n    log.error('Clients.matchAll error', error);\r\n  })\r\n\r\n  event.waitUntil(promise);\r\n});\r\n\r\nctx.addEventListener('notificationclose', onCloseNotification);\r\n\r\nconst notifications: Set<Notification> = new Set();\r\nlet pendingNotification: PushNotificationObject;\r\nfunction pushToNotifications(notification: Notification) {\r\n  if(!notifications.has(notification)) {\r\n    notifications.add(notification);\r\n    // @ts-ignore\r\n    notification.onclose = onCloseNotification;\r\n  }\r\n}\r\n\r\nfunction onCloseNotification(event: NotificationEvent) {\r\n  removeFromNotifications(event.notification)\r\n}\r\n\r\nfunction removeFromNotifications(notification: Notification) {\r\n  notifications.delete(notification);\r\n}\r\n\r\nexport function closeAllNotifications(tag?: string) {\r\n  for(const notification of notifications) {\r\n    try {\r\n      if(tag && notification.tag !== tag) {\r\n        continue;\r\n      }\r\n\r\n      notification.close();\r\n      notifications.delete(notification);\r\n    } catch(e) {}\r\n  }\r\n\r\n  let promise: Promise<void>;\r\n  if('getNotifications' in ctx.registration) {\r\n    promise = ctx.registration.getNotifications({tag}).then((notifications) => {\r\n      for(let i = 0, len = notifications.length; i < len; ++i) {\r\n        try {\r\n          notifications[i].close();\r\n        } catch(e) {}\r\n      }\r\n    }).catch((error) => {\r\n      log.error('Offline register SW error', error);\r\n    });\r\n  } else {\r\n    promise = Promise.resolve();\r\n  }\r\n\r\n  return promise;\r\n}\r\n\r\nfunction userInvisibleIsSupported() {\r\n  return IS_FIREFOX;\r\n}\r\n\r\nfunction fireNotification(obj: PushNotificationObject, settings: PushStorage['push_settings'], lang: PushStorage['push_lang']) {\r\n  let title = obj.title || 'Telegram';\r\n  let body = obj.description || '';\r\n  let peerId: string;\r\n\r\n  if(obj.custom) {\r\n    if(obj.custom.channel_id) {\r\n      peerId = '' + -obj.custom.channel_id;\r\n    } else if(obj.custom.chat_id) {\r\n      peerId = '' + -obj.custom.chat_id;\r\n    } else {\r\n      peerId = obj.custom.from_id || '';\r\n    }\r\n  }\r\n\r\n  obj.custom.peerId = '' + peerId;\r\n  let tag = 'peer' + peerId;\r\n\r\n  const messageKey = peerId + '_' + obj.custom.msg_id;\r\n  if(ignoreMessages.has(messageKey)) {\r\n    const error = 'ignoring push';\r\n    log.warn(error, obj);\r\n    ignoreMessages.delete(messageKey);\r\n    throw error;\r\n  }\r\n\r\n  if(settings?.nopreview) {\r\n    title = 'Telegram';\r\n    body = lang.push_message_nopreview;\r\n    tag = 'unknown_peer';\r\n  }\r\n\r\n  const actions: (Omit<NotificationAction, 'action'> & {action: PushNotificationObject['action']})[] = [{\r\n    action: 'mute1d',\r\n    title: lang.push_action_mute1d\r\n  }/* , {\r\n    action: 'push_settings',\r\n    title: lang.push_action_settings || 'Settings'\r\n  } */];\r\n\r\n  const notificationOptions: NotificationOptions = {\r\n    body,\r\n    icon: NOTIFICATION_ICON_PATH,\r\n    tag,\r\n    data: obj,\r\n    actions,\r\n    badge: NOTIFICATION_BADGE_PATH,\r\n    silent: obj.custom.silent === '1'\r\n  };\r\n\r\n  log('show notify', title, body, obj, notificationOptions);\r\n\r\n  const notificationPromise = ctx.registration.showNotification(title, notificationOptions);\r\n\r\n  return notificationPromise.catch((error) => {\r\n    log.error('Show notification promise', error);\r\n  });\r\n}\r\n\r\nexport function onPing(payload: ServicePushPingTaskPayload, source?: MessageEventSource) {\r\n  lastPingTime = Date.now();\r\n  localNotificationsAvailable = payload.localNotifications;\r\n\r\n  if(pendingNotification && source) {\r\n    serviceMessagePort.invokeVoid('pushClick', pendingNotification, source);\r\n    pendingNotification = undefined;\r\n  }\r\n\r\n  if(payload.lang) {\r\n    getter.set('push_lang', payload.lang);\r\n  }\r\n\r\n  if(payload.settings) {\r\n    getter.set('push_settings', payload.settings);\r\n  }\r\n}\r\n\r\nconst ignoreMessages: Map<string, number> = new Map();\r\nexport function onShownNotification(payload: string) {\r\n  ignoreMessages.set(payload, Date.now());\r\n}\r\n\r\nsetInterval(() => {\r\n  const time = Date.now();\r\n  ignoreMessages.forEach((_time, key) => {\r\n    if((time - _time) > 30e3) {\r\n      ignoreMessages.delete(key);\r\n    }\r\n  });\r\n}, 30 * 60e3);\r\n","const tabId = Date.now() % Math.random() * 100000000 | 0;\r\nexport default tabId;\r\n","export default function indexOfAndSplice<T>(array: Array<T>, item: T) {\r\n  const idx = array.indexOf(item);\r\n  const spliced = idx === -1 ? undefined : array.splice(idx, 1);\r\n  return spliced?.[0];\r\n}\r\n","export default function findAndSplice<T>(array: Array<T>, verify: (value: T, index?: number, array?: Array<T>) => boolean) {\r\n  const index = array.findIndex(verify);\r\n  return index !== -1 ? array.splice(index, 1)[0] : undefined;\r\n};\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n// import { MOUNT_CLASS_TO } from \"../config/debug\";\r\nimport type {ArgumentTypes, SuperReturnType} from '../types';\r\nimport findAndSplice from './array/findAndSplice';\r\n\r\n// class EventSystem {\r\n//   wm: WeakMap<any, Record<any, Set<any>>> = new WeakMap();\r\n\r\n//   add(target: any, event: any, listener: any) {\r\n//     let listeners = this.wm.get(target);\r\n//     if (listeners === undefined) {\r\n//         listeners = {};\r\n//     }\r\n//     let listenersForEvent = listeners[event];\r\n//     if (listenersForEvent === undefined) {\r\n//         listenersForEvent = new Set();\r\n//     }\r\n//     listenersForEvent.add(listener);\r\n//     listeners[event] = listenersForEvent;\r\n//     //target.addEventListener(event, listener);\r\n//     this.wm.set(target, listeners);\r\n//   };\r\n\r\n//   remove(target: any, event: any, listener: any) {\r\n//     let listeners = this.wm.get(target);\r\n//     if (!listeners) return;\r\n//     let listenersForEvent = listeners[event];\r\n//     if (!listenersForEvent) return;\r\n//     listenersForEvent.delete(listener);\r\n//   };\r\n\r\n//   /* fire(target, event) {\r\n//      let listeners = this.wm.get(target);\r\n//      if (!listeners) return;\r\n//      let listenersForEvent = listeners[event];\r\n//      if (!listenersForEvent) return;\r\n//      for (let handler of handlers) {\r\n//          setTimeout(handler, 0, event, target); // we use a setTimeout here because we want event triggering to be asynchronous.\r\n//      }\r\n//   }; */\r\n// }\r\n\r\n// console.log = () => {};\r\n\r\n// const e = new EventSystem();\r\n// MOUNT_CLASS_TO.e = e;\r\n\r\nexport type EventListenerListeners = Record<string, Function>;\r\n// export type EventListenerListeners = Record<string, (...args: any[]) => any>;\r\n// export type EventListenerListeners = {[name in string]: Function};\r\n\r\n/**\r\n * Better not to remove listeners during setting\r\n * Should add listener callback only once\r\n */\r\n\r\ntype ListenerObject<T> = {callback: T, options: boolean | AddEventListenerOptions};\r\n\r\n// type EventLitenerCallback<T> = (data: T) =>\r\n// export default class EventListenerBase<Listeners extends {[name: string]: Function}> {\r\nexport default class EventListenerBase<Listeners extends EventListenerListeners> {\r\n  protected listeners: Partial<{\r\n    [k in keyof Listeners]: Array<ListenerObject<Listeners[k]>>\r\n  }>;\r\n  protected listenerResults: Partial<{\r\n    [k in keyof Listeners]: ArgumentTypes<Listeners[k]>\r\n  }>;\r\n\r\n  private reuseResults: boolean;\r\n\r\n  constructor(reuseResults?: boolean) {\r\n    this._constructor(reuseResults);\r\n  }\r\n\r\n  public _constructor(reuseResults?: boolean): any {\r\n    this.reuseResults = reuseResults;\r\n    this.listeners = {};\r\n    this.listenerResults = {};\r\n  }\r\n\r\n  public addEventListener<T extends keyof Listeners>(name: T, callback: Listeners[T], options?: boolean | AddEventListenerOptions) {\r\n    (this.listeners[name] ??= []).push({callback, options}); // ! add before because if you don't, you won't be able to delete it from callback\r\n\r\n    if(this.listenerResults.hasOwnProperty(name)) {\r\n      callback(...this.listenerResults[name]);\r\n\r\n      if((options as AddEventListenerOptions)?.once) {\r\n        this.listeners[name].pop();\r\n        return;\r\n      }\r\n    }\r\n\r\n    // e.add(this, name, {callback, once});\r\n  }\r\n\r\n  public addMultipleEventsListeners(obj: {\r\n    [name in keyof Listeners]?: Listeners[name]\r\n  }) {\r\n    for(const i in obj) {\r\n      this.addEventListener(i, obj[i]);\r\n    }\r\n  }\r\n\r\n  public removeEventListener<T extends keyof Listeners>(\r\n    name: T,\r\n    callback: Listeners[T],\r\n    options?: boolean | AddEventListenerOptions\r\n  ) {\r\n    if(this.listeners[name]) {\r\n      findAndSplice(this.listeners[name], (l) => l.callback === callback);\r\n    }\r\n    // e.remove(this, name, callback);\r\n  }\r\n\r\n  protected invokeListenerCallback<T extends keyof Listeners, L extends ListenerObject<any>>(\r\n    name: T,\r\n    listener: L,\r\n    ...args: ArgumentTypes<L['callback']>\r\n  ) {\r\n    let result: any, error: any;\r\n    try {\r\n      result = listener.callback(...args);\r\n    } catch(err) {\r\n      error = err;\r\n      // console.error('listener callback error', err);\r\n    }\r\n\r\n    if((listener.options as AddEventListenerOptions)?.once) {\r\n      this.removeEventListener(name, listener.callback);\r\n    }\r\n\r\n    if(error) {\r\n      throw error;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  private _dispatchEvent<T extends keyof Listeners>(\r\n    name: T,\r\n    collectResults: boolean,\r\n    ...args: ArgumentTypes<Listeners[T]>\r\n  ) {\r\n    if(this.reuseResults) {\r\n      this.listenerResults[name] = args;\r\n    }\r\n\r\n    const arr: Array<SuperReturnType<Listeners[typeof name]>> = collectResults && [];\r\n\r\n    const listeners = this.listeners[name];\r\n    if(listeners) {\r\n      // ! this one will guarantee execution even if delete another listener during setting\r\n      const left = listeners.slice();\r\n      left.forEach((listener) => {\r\n        const index = listeners.findIndex((l) => l.callback === listener.callback);\r\n        if(index === -1) {\r\n          return;\r\n        }\r\n\r\n        const result = this.invokeListenerCallback(name, listener, ...args);\r\n        if(arr) {\r\n          arr.push(result);\r\n        }\r\n      });\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  public dispatchResultableEvent<T extends keyof Listeners>(name: T, ...args: ArgumentTypes<Listeners[T]>) {\r\n    return this._dispatchEvent(name, true, ...args);\r\n  }\r\n\r\n  // * must be protected, but who cares\r\n  public dispatchEvent<L extends EventListenerListeners = Listeners, T extends keyof L = keyof L>(\r\n    name: T,\r\n    ...args: ArgumentTypes<L[T]>\r\n  ) {\r\n    // @ts-ignore\r\n    this._dispatchEvent(name, false, ...args);\r\n  }\r\n\r\n  public cleanup() {\r\n    this.listeners = {};\r\n    this.listenerResults = {};\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport DEBUG from '../../config/debug';\r\nimport tabId from '../../config/tabId';\r\nimport ctx from '../../environment/ctx';\r\nimport indexOfAndSplice from '../../helpers/array/indexOfAndSplice';\r\nimport {IS_WORKER} from '../../helpers/context';\r\nimport EventListenerBase from '../../helpers/eventListenerBase';\r\nimport makeError from '../../helpers/makeError';\r\nimport {Awaited, WorkerTaskTemplate, WorkerTaskVoidTemplate} from '../../types';\r\nimport {logger} from '../logger';\r\n\r\ntype SuperMessagePortTask = WorkerTaskTemplate & {\r\n  transfer?: Transferable[]\r\n};\r\n\r\ninterface InvokeTask extends SuperMessagePortTask {\r\n  type: 'invoke',\r\n  payload: WorkerTaskVoidTemplate & {withAck?: boolean, void?: boolean}\r\n}\r\n\r\ninterface ResultTask extends SuperMessagePortTask {\r\n  type: 'result',\r\n  payload: {\r\n    taskId: number,\r\n    result?: any,\r\n    error?: any\r\n  }\r\n}\r\n\r\ninterface AckTask extends SuperMessagePortTask {\r\n  type: 'ack',\r\n  payload: {\r\n    cached: boolean,\r\n    taskId: number\r\n    result?: any,\r\n    error?: any,\r\n  }\r\n}\r\n\r\ninterface PingTask extends SuperMessagePortTask {\r\n  type: 'ping'\r\n}\r\n\r\ninterface PongTask extends SuperMessagePortTask {\r\n  type: 'pong'\r\n}\r\n\r\ninterface BatchTask extends SuperMessagePortTask {\r\n  type: 'batch',\r\n  payload: Task[]\r\n}\r\n\r\ninterface CloseTask extends SuperMessagePortTask {\r\n  type: 'close'\r\n}\r\n\r\n// interface OpenTask extends SuperMessagePortTask {\r\n//   type: 'open'\r\n// }\r\n\r\ninterface LockTask extends SuperMessagePortTask {\r\n  type: 'lock',\r\n  payload: string\r\n}\r\n\r\ntype Task = InvokeTask | ResultTask | AckTask | PingTask | PongTask | BatchTask | CloseTask/*  | OpenTask */ | LockTask;\r\ntype TaskMap = {\r\n  [type in Task as type['type']]?: (task: Extract<Task, type>, source: MessageEventSource, event: MessageEvent<any>) => void | Promise<any>\r\n};\r\n\r\nexport type AckedResult<T> = {\r\n  cached: boolean,\r\n  result: Promise<T>\r\n};\r\n// export type AckedResult<T> = {\r\n//   cached: true,\r\n//   result: T\r\n// } | {\r\n//   cached: false,\r\n//   result: Promise<T>\r\n// };\r\n\r\ntype ListenPort = WindowProxy | MessagePort | ServiceWorker | Worker | ServiceWorkerContainer;\r\ntype SendPort = Pick<MessageEventSource, 'postMessage'>/* WindowProxy | MessagePort | ServiceWorker | Worker */;\r\n\r\nexport type MessageListenPort = ListenPort;\r\nexport type MessageSendPort = SendPort;\r\n\r\ntype ListenerCallback = (payload: any, source: MessageEventSource, event: MessageEvent<any>) => any;\r\ntype Listeners = Record<string, ListenerCallback>;\r\n\r\nconst USE_LOCKS = true;\r\nconst USE_BATCHING = true;\r\n\r\n// const PING_INTERVAL = DEBUG && false ? 0x7FFFFFFF : 5000;\r\n// const PING_TIMEOUT = DEBUG && false ? 0x7FFFFFFF : 10000;\r\n\r\nexport default class SuperMessagePort<\r\n  Workers extends Listeners,\r\n  Masters extends Listeners,\r\n  IsMaster extends boolean,\r\n  Receive extends Listeners = IsMaster extends true ? Masters : Workers,\r\n  Send extends Listeners = IsMaster extends true ? Workers : Masters\r\n> extends EventListenerBase<Receive> {\r\n  protected listenPorts: Array<ListenPort>;\r\n  protected sendPorts: Array<SendPort>;\r\n  protected pingResolves: Map<SendPort, () => void>;\r\n\r\n  protected taskId: number;\r\n  protected awaiting: {\r\n    [id: number]: {\r\n      resolve: any,\r\n      reject: any,\r\n      taskType: string,\r\n      port?: SendPort\r\n    }\r\n  };\r\n  protected pending: Map<SendPort, Task[]>;\r\n\r\n  protected log: ReturnType<typeof logger>;\r\n  protected debug: boolean;\r\n  protected releasingPending: boolean;\r\n\r\n  protected processTaskMap: TaskMap;\r\n\r\n  protected onPortDisconnect: (source: MessageEventSource) => void;\r\n  // protected onPortConnect: (source: MessageEventSource) => void;\r\n\r\n  protected heldLocks: Map<SendPort, {resolve: () => void, id: string}>;\r\n  protected requestedLocks: Map<string, SendPort>;\r\n\r\n  constructor(protected logSuffix?: string) {\r\n    super(false);\r\n\r\n    this.listenPorts = [];\r\n    this.sendPorts = [];\r\n    this.pingResolves = new Map();\r\n    this.taskId = 0;\r\n    this.awaiting = {};\r\n    this.pending = new Map();\r\n    this.log = logger('MP' + (logSuffix ? '-' + logSuffix : ''));\r\n    this.debug = DEBUG;\r\n    this.heldLocks = new Map();\r\n    this.requestedLocks = new Map();\r\n\r\n    this.processTaskMap = {\r\n      result: this.processResultTask,\r\n      ack: this.processAckTask,\r\n      invoke: this.processInvokeTask,\r\n      ping: this.processPingTask,\r\n      pong: this.processPongTask,\r\n      close: this.processCloseTask,\r\n      // open: this.processOpenTask,\r\n      lock: this.processLockTask,\r\n      batch: this.processBatchTask\r\n    };\r\n  }\r\n\r\n  public setOnPortDisconnect(callback: (source: MessageEventSource) => void) {\r\n    this.onPortDisconnect = callback;\r\n  }\r\n\r\n  // public setOnPortConnect(callback: (source: MessageEventSource) => void) {\r\n  //   this.onPortConnect = callback;\r\n  // }\r\n\r\n  public attachPort(port: MessageEventSource) {\r\n    this.attachListenPort(port);\r\n    this.attachSendPort(port);\r\n  }\r\n\r\n  public attachListenPort(port: ListenPort) {\r\n    this.listenPorts.push(port);\r\n    port.addEventListener('message', this.onMessage as any);\r\n  }\r\n\r\n  public attachSendPort(port: SendPort) {\r\n    this.log.warn('attaching send port');\r\n\r\n    (port as MessagePort).start?.();\r\n\r\n    this.sendPorts.push(port);\r\n    // this.sendPing(port);\r\n\r\n    // const task = this.createTask('open', undefined);\r\n    // this.postMessage(port, task);\r\n\r\n    if(typeof(window) !== 'undefined' && USE_LOCKS) {\r\n      if('locks' in navigator) {\r\n        const id = ['lock', tabId, this.logSuffix || '', Math.random() * 0x7FFFFFFF | 0].join('-');\r\n        this.log.warn('created lock', id);\r\n        const promise = new Promise<void>((resolve) => this.heldLocks.set(port, {resolve, id}))\r\n        .then(() => this.heldLocks.delete(port));\r\n        navigator.locks.request(id, () => {\r\n          this.resendLockTask(port);\r\n          return promise;\r\n        });\r\n      } else {\r\n        window.addEventListener('beforeunload', () => {\r\n          const task = this.createTask('close', undefined);\r\n          this.postMessage(undefined, task);\r\n        });\r\n      }\r\n    }\r\n\r\n    this.releasePending();\r\n  }\r\n\r\n  public resendLockTask(port: SendPort) {\r\n    const lock = this.heldLocks.get(port);\r\n    if(!lock) {\r\n      return;\r\n    }\r\n\r\n    this.pushTask(this.createTask('lock', lock.id), port);\r\n  }\r\n\r\n  // ! Can't rely on ping because timers can be suspended\r\n  // protected sendPing(port: SendPort, loop = IS_WORKER) {\r\n  //   let timeout: number;\r\n  //   const promise = new Promise<void>((resolve, reject) => {\r\n  //     this.pingResolves.set(port, resolve);\r\n  //     this.pushTask(this.createTask('ping', undefined), port);\r\n\r\n  //     timeout = ctx.setTimeout(() => {\r\n  //       reject();\r\n  //     }, PING_TIMEOUT);\r\n  //   });\r\n\r\n  //   promise.then(() => {\r\n  //     // this.log('got pong');\r\n\r\n  //     clearTimeout(timeout);\r\n  //     this.pingResolves.delete(port);\r\n\r\n  //     if(loop) {\r\n  //       this.sendPingWithTimeout(port);\r\n  //     }\r\n  //   }, () => {\r\n  //     this.pingResolves.delete(port);\r\n  //     this.detachPort(port);\r\n  //   });\r\n  // }\r\n\r\n  // protected sendPingWithTimeout(port: SendPort, timeout = PING_INTERVAL) {\r\n  //   ctx.setTimeout(() => {\r\n  //     if(!this.sendPorts.includes(port)) {\r\n  //       return;\r\n  //     }\r\n\r\n  //     this.sendPing(port);\r\n  //   }, timeout);\r\n  // }\r\n\r\n  public detachPort(port: ListenPort) {\r\n    this.log.warn('disconnecting port');\r\n\r\n    indexOfAndSplice(this.listenPorts, port);\r\n    indexOfAndSplice(this.sendPorts, port as any);\r\n\r\n    port.removeEventListener?.('message', this.onMessage as any);\r\n    (port as MessagePort).close?.();\r\n\r\n    this.onPortDisconnect?.(port as any);\r\n\r\n    const heldLock = this.heldLocks.get(port as SendPort);\r\n    heldLock?.resolve();\r\n\r\n    const error = makeError('PORT_DISCONNECTED');\r\n    for(const id in this.awaiting) {\r\n      const task = this.awaiting[id];\r\n      if(task.port === port) {\r\n        task.reject(error);\r\n        delete this.awaiting[id];\r\n      }\r\n    }\r\n  }\r\n\r\n  protected postMessage(port: SendPort | SendPort[], task: Task) {\r\n    const ports = Array.isArray(port) ? port : (port ? [port] : this.sendPorts);\r\n    ports.forEach((port) => {\r\n      if(import.meta.env.MODE === 'test') {\r\n        return;\r\n      }\r\n\r\n      port.postMessage(task, task.transfer as any);\r\n    });\r\n  }\r\n\r\n  protected onMessage = (event: MessageEvent) => {\r\n    const task: Task = event.data;\r\n    // this.log('got message', task);\r\n\r\n    const source: MessageEventSource = event.source || event.currentTarget as any; // can have no source\r\n\r\n    // @ts-ignore\r\n    this.processTaskMap[task.type](task, source, event);\r\n  };\r\n\r\n  protected async releasePending() {\r\n    // return;\r\n\r\n    if(/* !this.listenPorts.length || !this.sendPorts.length ||  */this.releasingPending) {\r\n      return;\r\n    }\r\n\r\n    this.releasingPending = true;\r\n    // const perf = performance.now();\r\n\r\n    if(USE_BATCHING) {\r\n      await Promise.resolve();\r\n    }\r\n    // await pause(0);\r\n\r\n    this.debug && this.log.debug('releasing tasks, length:', this.pending.size/* , performance.now() - perf */);\r\n\r\n    this.pending.forEach((portTasks, port) => {\r\n      let tasks: Task[] = portTasks;\r\n      if(USE_BATCHING) {\r\n        let batchTask: BatchTask;\r\n        tasks = [];\r\n        portTasks.forEach((task) => {\r\n          if(task.transfer) {\r\n            batchTask = undefined;\r\n            tasks.push(task);\r\n          } else {\r\n            if(!batchTask) {\r\n              batchTask = this.createTask('batch', []);\r\n              tasks.push(batchTask);\r\n            }\r\n\r\n            batchTask.payload.push(task);\r\n          }\r\n        });\r\n      }\r\n\r\n      const ports = port ? [port] : this.sendPorts;\r\n      if(!ports.length) {\r\n        return;\r\n      }\r\n\r\n      tasks.forEach((task) => {\r\n        // if(USE_BATCHING && task.type === 'batch') {\r\n        //   this.log(`batching ${task.payload.length} tasks`);\r\n        // }\r\n\r\n        try {\r\n          // if(IS_SERVICE_WORKER && !port) {\r\n          //   notifyAll(task);\r\n          // } else {\r\n          this.postMessage(ports, task);\r\n          // }\r\n        } catch(err) {\r\n          this.log.error('postMessage error:', err, task, ports);\r\n        }\r\n      });\r\n\r\n      this.pending.delete(port);\r\n    });\r\n\r\n    this.debug && this.log.debug('released tasks');\r\n\r\n    this.releasingPending = false;\r\n  }\r\n\r\n  protected processResultTask = (task: ResultTask) => {\r\n    const {taskId, result, error} = task.payload;\r\n    const deferred = this.awaiting[taskId];\r\n    if(!deferred) {\r\n      return;\r\n    }\r\n\r\n    this.debug && this.log.debug('done', deferred.taskType, result, error);\r\n    'error' in task.payload ? deferred.reject(error) : deferred.resolve(result);\r\n    delete this.awaiting[taskId];\r\n  };\r\n\r\n  protected processAckTask = (task: AckTask) => {\r\n    const payload = task.payload;\r\n    const deferred = this.awaiting[payload.taskId];\r\n    if(!deferred) {\r\n      return;\r\n    }\r\n\r\n    // * will finish the init promise with incoming result\r\n    const previousResolve: (acked: AckedResult<any>) => void = deferred.resolve;\r\n    // const previousReject = deferred.reject;\r\n\r\n    // if(payload.cached) {\r\n    //   if('result' in payload) {\r\n    //     previousResolve({\r\n    //       cached: true,\r\n    //       result: payload.result\r\n    //     });\r\n    //   } else {\r\n    //     previousReject(payload.error);\r\n    //   }\r\n    // } else {\r\n    //   const ret: AckedResult<any> = {\r\n    //     cached: false,\r\n    //     result: new Promise((resolve, reject) => {\r\n    //       deferred.resolve = resolve;\r\n    //       deferred.reject = reject;\r\n    //     })\r\n    //   };\r\n\r\n    //   previousResolve(ret);\r\n    // }\r\n\r\n    const ret: AckedResult<any> = {\r\n      cached: payload.cached,\r\n      result: payload.cached ? ('result' in payload ? Promise.resolve(payload.result) : Promise.reject(payload.error)) : new Promise((resolve, reject) => {\r\n        deferred.resolve = resolve;\r\n        deferred.reject = reject;\r\n      })\r\n    };\r\n\r\n    previousResolve(ret);\r\n\r\n    if(payload.cached) {\r\n      delete this.awaiting[payload.taskId];\r\n    }\r\n  };\r\n\r\n  protected processPingTask = (task: PingTask, source: MessageEventSource, event: MessageEvent) => {\r\n    this.pushTask(this.createTask('pong', undefined), event.source);\r\n  };\r\n\r\n  protected processPongTask = (task: PongTask, source: MessageEventSource, event: MessageEvent) => {\r\n    const pingResolve = this.pingResolves.get(source);\r\n    if(pingResolve) {\r\n      this.pingResolves.delete(source);\r\n      pingResolve();\r\n    }\r\n  };\r\n\r\n  protected processCloseTask = (task: CloseTask, source: MessageEventSource, event: MessageEvent) => {\r\n    this.detachPort(source);\r\n  };\r\n\r\n  protected processBatchTask = (task: BatchTask, source: MessageEventSource, event: MessageEvent) => {\r\n    if(!USE_BATCHING) {\r\n      return;\r\n    }\r\n\r\n    const newEvent: MessageEvent = {data: event.data, source: event.source, currentTarget: event.currentTarget} as any;\r\n    task.payload.forEach((task) => {\r\n      // @ts-ignore\r\n      newEvent.data = task;\r\n      this.onMessage(newEvent);\r\n    });\r\n  };\r\n\r\n  // * it's just an 'open' callback, DO NOT attach port from here\r\n  // protected processOpenTask = (task: OpenTask, source: MessageEventSource, event: MessageEvent) => {\r\n  //   this.onPortConnect?.(source);\r\n  // };\r\n\r\n  protected processLockTask = (task: LockTask, source: MessageEventSource, event: MessageEvent) => {\r\n    const id = task.payload;\r\n    if(this.requestedLocks.has(id)) {\r\n      return;\r\n    }\r\n\r\n    this.requestedLocks.set(id, source);\r\n    navigator.locks.request(id, () => {\r\n      this.processCloseTask(undefined, source, undefined);\r\n      this.requestedLocks.delete(id);\r\n    });\r\n  };\r\n\r\n  protected processInvokeTask = async(task: InvokeTask, source: MessageEventSource, event: MessageEvent) => {\r\n    const id = task.id;\r\n    const innerTask = task.payload;\r\n\r\n    let resultTaskPayload: ResultTask['payload'];\r\n    let resultTask: ResultTask, ackTask: AckTask;\r\n    if(!innerTask.void) {\r\n      resultTaskPayload = {taskId: id};\r\n      resultTask = this.createTask('result', resultTaskPayload);\r\n    }\r\n\r\n    if(innerTask.withAck) {\r\n      ackTask = this.createTask('ack', {\r\n        taskId: id,\r\n        cached: true\r\n      });\r\n    }\r\n\r\n    let isPromise: boolean;\r\n    try {\r\n      const listeners = this.listeners[innerTask.type];\r\n      if(!listeners?.length) {\r\n        throw new Error('no listener');\r\n      }\r\n\r\n      const listener = listeners[0];\r\n\r\n      // @ts-ignore\r\n      let result = this.invokeListenerCallback(innerTask.type, listener, innerTask.payload, source, event);\r\n      if(innerTask.void) {\r\n        return;\r\n      }\r\n\r\n      isPromise = result instanceof Promise;\r\n\r\n      if(ackTask) {\r\n        const cached = !isPromise;\r\n        ackTask.payload.cached = cached;\r\n        if(cached) ackTask.payload.result = result;\r\n        this.pushTask(ackTask, source);\r\n\r\n        if(cached) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      if(isPromise) {\r\n        result = await result;\r\n      }\r\n\r\n      resultTaskPayload.result = result;\r\n    } catch(error) {\r\n      this.log.error('worker task error:', error, task);\r\n      if(innerTask.void) {\r\n        return;\r\n      }\r\n\r\n      if(ackTask && ackTask.payload.cached) {\r\n        ackTask.payload.error = error;\r\n        this.pushTask(ackTask, source);\r\n        return;\r\n      }\r\n\r\n      resultTaskPayload.error = error;\r\n    }\r\n\r\n    this.pushTask(resultTask, source);\r\n  };\r\n\r\n  protected createTask<T extends Task['type'], K extends Task = Parameters<TaskMap[T]>[0]>(type: T, payload: K['payload'], transfer?: Transferable[]): K {\r\n    return {\r\n      type,\r\n      payload,\r\n      id: this.taskId++,\r\n      transfer\r\n    } as K;\r\n  }\r\n\r\n  protected createInvokeTask(type: string, payload: any, withAck?: boolean, _void?: boolean, transfer?: Transferable[]): InvokeTask {\r\n    return this.createTask('invoke', {\r\n      type,\r\n      payload,\r\n      withAck,\r\n      void: _void\r\n    }, transfer);\r\n  }\r\n\r\n  protected pushTask(task: Task, port?: SendPort) {\r\n    let tasks = this.pending.get(port);\r\n    if(!tasks) {\r\n      this.pending.set(port, tasks = []);\r\n    }\r\n\r\n    tasks.push(task);\r\n    this.releasePending();\r\n  }\r\n\r\n  public invokeVoid<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], port?: SendPort, transfer?: Transferable[]) {\r\n    const task = this.createInvokeTask(type as string, payload, undefined, true, transfer);\r\n    this.pushTask(task, port);\r\n  }\r\n\r\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: false, port?: SendPort, transfer?: Transferable[]): Promise<Awaited<ReturnType<Send[T]>>>;\r\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: true, port?: SendPort, transfer?: Transferable[]): Promise<AckedResult<Awaited<ReturnType<Send[T]>>>>;\r\n  public invoke<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], withAck?: boolean, port?: SendPort, transfer?: Transferable[]) {\r\n    this.debug && this.log.debug('start', type, payload);\r\n\r\n    let task: InvokeTask;\r\n    const promise = new Promise<Awaited<ReturnType<Send[T]>>>((resolve, reject) => {\r\n      task = this.createInvokeTask(type as string, payload, withAck, undefined, transfer);\r\n      this.awaiting[task.id] = {resolve, reject, taskType: type as string, port};\r\n      this.pushTask(task, port);\r\n    });\r\n\r\n    if(IS_WORKER) {\r\n      promise.finally(() => {\r\n        clearInterval(interval);\r\n      });\r\n\r\n      const interval = ctx.setInterval(() => {\r\n        this.log.error('task still has no result', task, port);\r\n      }, 60e3);\r\n    } else if(false) {\r\n      // let timedOut = false;\r\n      const startTime = Date.now();\r\n      promise.finally(() => {\r\n        const elapsedTime = Date.now() - startTime;\r\n        if(elapsedTime >= TIMEOUT) {\r\n          this.log.error(`task was processing ${Date.now() - startTime}ms`, task.payload.payload, port);\r\n        }/*  else {\r\n          clearTimeout(timeout);\r\n        } */\r\n      });\r\n\r\n      const TIMEOUT = 10;\r\n      // const timeout = ctx.setTimeout(() => {\r\n      //   timedOut = true;\r\n      //   // this.log.error(`task is processing more than ${TIMEOUT} milliseconds`, task, port);\r\n      // }, TIMEOUT);\r\n    }\r\n\r\n    return promise;\r\n  }\r\n\r\n  public invokeExceptSource<T extends keyof Send>(type: T, payload: Parameters<Send[T]>[0], source?: SendPort) {\r\n    const ports = this.sendPorts.slice();\r\n    indexOfAndSplice(ports, source);\r\n\r\n    ports.forEach((target) => {\r\n      this.invokeVoid(type, payload, target);\r\n    });\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport type {WebPushApiManager} from '../mtproto/webPushApiManager';\r\nimport type {PushNotificationObject} from './push';\r\nimport type {MyUploadFile} from '../mtproto/apiFileManager';\r\nimport SuperMessagePort from '../mtproto/superMessagePort';\r\nimport {MOUNT_CLASS_TO} from '../../config/debug';\r\n\r\nexport type ServicePushPingTaskPayload = {\r\n  localNotifications: boolean,\r\n  lang: {\r\n    push_action_mute1d: string\r\n    push_action_settings: string\r\n    push_message_nopreview: string\r\n  },\r\n  settings: WebPushApiManager['settings']\r\n};\r\n\r\nexport type ServiceRequestFilePartTaskPayload = {\r\n  docId: DocId,\r\n  dcId: number,\r\n  offset: number,\r\n  limit: number\r\n};\r\n\r\nexport type ServiceDownloadTaskPayload = {\r\n  headers: any,\r\n  id: string\r\n};\r\n\r\nexport type ServiceEvent = {\r\n  port: (payload: void, source: MessageEventSource, event: MessageEvent) => void\r\n};\r\n\r\nexport default class ServiceMessagePort<Master extends boolean = false> extends SuperMessagePort<{\r\n  // from main thread to service worker\r\n  notificationsClear: () => void,\r\n  toggleStorages: (payload: {enabled: boolean, clearWrite: boolean}) => void,\r\n  pushPing: (payload: ServicePushPingTaskPayload, source: MessageEventSource, event: MessageEvent) => void,\r\n  hello: (payload: void, source: MessageEventSource, event: MessageEvent) => void,\r\n  shownNotification: (payload: string) => void,\r\n\r\n  // from mtproto worker\r\n  download: (payload: ServiceDownloadTaskPayload) => void,\r\n  downloadChunk: (payload: {id: ServiceDownloadTaskPayload['id'], chunk: Uint8Array}) => void\r\n  downloadFinalize: (payload: ServiceDownloadTaskPayload['id']) => void,\r\n  downloadCancel: (payload: ServiceDownloadTaskPayload['id']) => void\r\n}, {\r\n  // to main thread\r\n  pushClick: (payload: PushNotificationObject) => void,\r\n  hello: (payload: void, source: MessageEventSource) => void,\r\n  share: (payload: ShareData) => void,\r\n\r\n  // to mtproto worker\r\n  requestFilePart: (payload: ServiceRequestFilePartTaskPayload) => Promise<MyUploadFile> | MyUploadFile\r\n} & ServiceEvent, Master> {\r\n  constructor() {\r\n    super('SERVICE');\r\n\r\n    MOUNT_CLASS_TO && (MOUNT_CLASS_TO.serviceMessagePort = this);\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport type SuperMessagePort from '../lib/mtproto/superMessagePort';\r\nimport ctx from '../environment/ctx';\r\n\r\nexport default function listenMessagePort(\r\n  messagePort: SuperMessagePort<any, any, any>,\r\n  onConnect?: (source: MessageEventSource) => void,\r\n  onDisconnect?: (source: MessageEventSource) => void\r\n) {\r\n  const attachPort = (listenPort: any, sendPort: any) => {\r\n    messagePort.attachListenPort(listenPort);\r\n    sendPort && messagePort.attachSendPort(sendPort);\r\n    onConnect?.(listenPort);\r\n  };\r\n\r\n  messagePort.setOnPortDisconnect(onDisconnect);\r\n\r\n  if(typeof(SharedWorkerGlobalScope) !== 'undefined') {\r\n    (ctx as any as SharedWorkerGlobalScope).addEventListener('connect', (e) => attachPort(e.source, e.source));\r\n  } else if(typeof(ServiceWorkerGlobalScope) !== 'undefined') {\r\n    attachPort(ctx, null);\r\n  } else {\r\n    attachPort(ctx, ctx);\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport type {ServiceDownloadTaskPayload} from './serviceMessagePort';\r\nimport type ServiceMessagePort from './serviceMessagePort';\r\nimport deferredPromise, {CancellablePromise} from '../../helpers/cancellablePromise';\r\nimport makeError from '../../helpers/makeError';\r\nimport pause from '../../helpers/schedulers/pause';\r\n\r\ntype DownloadType = Uint8Array;\r\ntype DownloadItem = ServiceDownloadTaskPayload & {\r\n  // transformStream: TransformStream<DownloadType, DownloadType>,\r\n  readableStream: ReadableStream<DownloadType>,\r\n  // writableStream: WritableStream<DownloadType>,\r\n  // writer: WritableStreamDefaultWriter<DownloadType>,\r\n  // controller: TransformStreamDefaultController<DownloadType>,\r\n  controller: ReadableStreamController<Uint8Array>,\r\n  promise: CancellablePromise<void>,\r\n  // downloadPromise: Promise<void>,\r\n  used?: boolean\r\n};\r\nconst downloadMap: Map<string, DownloadItem> = new Map();\r\nconst DOWNLOAD_ERROR = makeError('UNKNOWN');\r\nconst DOWNLOAD_TEST = false;\r\n\r\n(self as any).downloadMap = downloadMap;\r\n\r\ntype A = Parameters<ServiceMessagePort<false>['addMultipleEventsListeners']>[0];\r\n\r\nconst events: A = {\r\n  download: (payload) => {\r\n    const {id} = payload;\r\n    if(downloadMap.has(id)) {\r\n      return Promise.reject(DOWNLOAD_ERROR);\r\n    }\r\n\r\n    // const y = (20 * 1024 * 1024) / payload.limitPart;\r\n    // const strategy = new ByteLengthQueuingStrategy({highWaterMark: y});\r\n    // let controller: TransformStreamDefaultController<DownloadType>;\r\n    const strategy = new CountQueuingStrategy({highWaterMark: 1});\r\n    // const transformStream = new TransformStream<DownloadType, DownloadType>(/* {\r\n    //   start: (_controller) => controller = _controller,\r\n    // },  */undefined, strategy, strategy);\r\n\r\n    // const {readable, writable} = transformStream;\r\n    // const writer = writable.getWriter();\r\n\r\n    const promise = deferredPromise<void>();\r\n    promise.then(() => {\r\n      setTimeout(() => {\r\n        downloadMap.delete(id);\r\n      }, 5e3);\r\n    }, () => {\r\n      downloadMap.delete(id);\r\n    });\r\n\r\n    // writer.closed.then(promise.resolve, promise.reject);\r\n\r\n    let controller: ReadableStreamController<any>;\r\n    const readable = new ReadableStream({\r\n      start: (_controller) => {\r\n        controller = _controller;\r\n      },\r\n\r\n      cancel: (reason) => {\r\n        promise.reject(DOWNLOAD_ERROR);\r\n      }\r\n    }, strategy);\r\n\r\n    // writer.closed.catch(noop).finally(() => {\r\n    //   log.error('closed writer');\r\n    //   onEnd();\r\n    // });\r\n\r\n    // const downloadPromise = writer.closed.catch(() => {throw DOWNLOAD_ERROR;});\r\n    const item: DownloadItem = {\r\n      ...payload,\r\n      // transformStream,\r\n      readableStream: readable,\r\n      // writableStream: writable,\r\n      // writer,\r\n      // downloadPromise,\r\n      promise,\r\n      controller\r\n    };\r\n\r\n    downloadMap.set(id, item);\r\n\r\n    // return downloadPromise;\r\n    return promise.catch(() => {throw DOWNLOAD_ERROR});\r\n  },\r\n\r\n  downloadChunk: ({id, chunk}) => {\r\n    const item = downloadMap.get(id);\r\n    if(!item) {\r\n      return Promise.reject();\r\n    }\r\n\r\n    // return item.controller.enqueue(chunk);\r\n    // return item.writer.write(chunk);\r\n    // @ts-ignore\r\n    return item.controller.enqueue(chunk);\r\n  },\r\n\r\n  downloadFinalize: (id) => {\r\n    const item = downloadMap.get(id);\r\n    if(!item) {\r\n      return Promise.reject();\r\n    }\r\n\r\n    item.promise.resolve();\r\n    // return item.controller.terminate();\r\n    // return item.writer.close();\r\n    return item.controller.close();\r\n  },\r\n\r\n  downloadCancel: (id) => {\r\n    const item = downloadMap.get(id);\r\n    if(!item) {\r\n      return;\r\n    }\r\n\r\n    item.promise.reject();\r\n    // return item.controller.error();\r\n    // return item.writer.abort();\r\n    return item.controller.error();\r\n  }\r\n};\r\n\r\nexport default function handleDownload(serviceMessagePort: ServiceMessagePort<false>) {\r\n  serviceMessagePort.addMultipleEventsListeners(events);\r\n\r\n  return {\r\n    onDownloadFetch,\r\n    onClosedWindows: cancelAllDownloads\r\n  };\r\n}\r\n\r\nfunction onDownloadFetch(event: FetchEvent, params: string) {\r\n  const promise = pause(100).then(() => {\r\n    const item = downloadMap.get(params);\r\n    if(!item || (item.used && !DOWNLOAD_TEST)) {\r\n      return;\r\n    }\r\n\r\n    item.used = true;\r\n    const stream = item.readableStream;\r\n    const response = new Response(stream, {headers: item.headers});\r\n    return response;\r\n  });\r\n\r\n  event.respondWith(promise);\r\n}\r\n\r\nfunction cancelAllDownloads() {\r\n  if(downloadMap.size) {\r\n    for(const [id, item] of downloadMap) {\r\n      // item.writer.abort().catch(noop);\r\n      item.controller.error();\r\n    }\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport {log, serviceMessagePort} from './index.service';\r\n\r\nconst deferred: {[id: string]: ShareData[]} = {};\r\n\r\nfunction parseFormData(formData: FormData): ShareData {\r\n  return {\r\n    files: formData.getAll('files') as File[],\r\n    title: formData.get('title') as string,\r\n    text: formData.get('text') as string,\r\n    url: formData.get('url') as string\r\n  };\r\n}\r\n\r\nasync function processShareEvent(formData: FormData, clientId: string) {\r\n  try {\r\n    log('share data', formData);\r\n    const data = parseFormData(formData);\r\n    (deferred[clientId] ??= []).push(data);\r\n  } catch(err) {\r\n    log.warn('something wrong with the data', err);\r\n  }\r\n};\r\n\r\nexport function checkWindowClientForDeferredShare(windowClient: WindowClient) {\r\n  const arr = deferred[windowClient.id];\r\n  if(!arr) {\r\n    return;\r\n  }\r\n\r\n  delete deferred[windowClient.id];\r\n\r\n  log('releasing share events to client:', windowClient.id, 'length:', arr.length);\r\n  arr.forEach((data) => {\r\n    serviceMessagePort.invokeVoid('share', data, windowClient);\r\n  });\r\n}\r\n\r\nexport default function onShareFetch(event: FetchEvent, params: string) {\r\n  const promise = event.request.formData()\r\n  .then((formData) => {\r\n    processShareEvent(formData, event.resultingClientId)\r\n    return Response.redirect('..');\r\n  });\r\n\r\n  event.respondWith(promise);\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport {logger, LogTypes} from '../logger';\r\nimport {CACHE_ASSETS_NAME, requestCache} from './cache';\r\nimport onStreamFetch from './stream';\r\nimport {closeAllNotifications, onPing, onShownNotification} from './push';\r\nimport CacheStorageController from '../files/cacheStorage';\r\nimport {IS_SAFARI} from '../../environment/userAgent';\r\nimport ServiceMessagePort from './serviceMessagePort';\r\nimport listenMessagePort from '../../helpers/listenMessagePort';\r\nimport {getWindowClients} from '../../helpers/context';\r\nimport {MessageSendPort} from '../mtproto/superMessagePort';\r\nimport handleDownload from './download';\r\nimport onShareFetch, {checkWindowClientForDeferredShare} from './share';\r\n\r\n// #if MTPROTO_SW\r\n// import '../mtproto/mtproto.worker';\r\n// #endif\r\n\r\nexport const log = logger('SW', LogTypes.Error | LogTypes.Debug | LogTypes.Log | LogTypes.Warn, true);\r\nconst ctx = self as any as ServiceWorkerGlobalScope;\r\n\r\n// #if !MTPROTO_SW\r\nlet _mtprotoMessagePort: MessagePort;\r\nexport const getMtprotoMessagePort = () => _mtprotoMessagePort;\r\n\r\nlog('init');\r\n\r\nconst sendMessagePort = (source: MessageSendPort) => {\r\n  const channel = new MessageChannel();\r\n  serviceMessagePort.attachPort(_mtprotoMessagePort = channel.port1);\r\n  serviceMessagePort.invokeVoid('port', undefined, source, [channel.port2]);\r\n};\r\n\r\nconst sendMessagePortIfNeeded = (source: MessageSendPort) => {\r\n  if(!connectedWindows.size && !_mtprotoMessagePort) {\r\n    log('sending message port for mtproto');\r\n    sendMessagePort(source);\r\n  }\r\n};\r\n\r\nconst onWindowConnected = (source: WindowClient) => {\r\n  log('window connected', source.id, 'windows before', connectedWindows.size);\r\n\r\n  if(source.frameType === 'none') {\r\n    log.warn('maybe a bugged Safari starting window', source.id);\r\n    return;\r\n  }\r\n\r\n  log('windows', Array.from(connectedWindows));\r\n  serviceMessagePort.invokeVoid('hello', undefined, source);\r\n  sendMessagePortIfNeeded(source);\r\n  connectedWindows.set(source.id, source);\r\n\r\n  checkWindowClientForDeferredShare(source);\r\n};\r\n\r\nexport const serviceMessagePort = new ServiceMessagePort<false>();\r\nserviceMessagePort.addMultipleEventsListeners({\r\n  notificationsClear: closeAllNotifications,\r\n\r\n  toggleStorages: ({enabled, clearWrite}) => {\r\n    CacheStorageController.toggleStorage(enabled, clearWrite);\r\n  },\r\n\r\n  pushPing: (payload, source) => {\r\n    onPing(payload, source);\r\n  },\r\n\r\n  hello: (payload, source) => {\r\n    onWindowConnected(source as any as WindowClient);\r\n  },\r\n\r\n  shownNotification: onShownNotification\r\n});\r\n\r\nconst {\r\n  onDownloadFetch,\r\n  onClosedWindows: onDownloadClosedWindows\r\n} = handleDownload(serviceMessagePort);\r\n\r\n// * service worker can be killed, so won't get 'hello' event\r\ngetWindowClients().then((windowClients) => {\r\n  log(`got ${windowClients.length} windows from the start`);\r\n  windowClients.forEach((windowClient) => {\r\n    onWindowConnected(windowClient);\r\n  });\r\n});\r\n\r\nconst connectedWindows: Map<string, WindowClient> = new Map();\r\n(self as any).connectedWindows = connectedWindows;\r\nlistenMessagePort(serviceMessagePort, undefined, (source) => {\r\n  log('something has disconnected', source);\r\n  const isWindowClient = source instanceof WindowClient;\r\n  if(!isWindowClient || !connectedWindows.has(source.id)) {\r\n    log.warn('it is not a window');\r\n    return;\r\n  }\r\n\r\n  connectedWindows.delete(source.id);\r\n  log('window disconnected, left', connectedWindows.size);\r\n  if(!connectedWindows.size) {\r\n    log.warn('no windows left');\r\n\r\n    if(_mtprotoMessagePort) {\r\n      serviceMessagePort.detachPort(_mtprotoMessagePort);\r\n      _mtprotoMessagePort = undefined;\r\n    }\r\n\r\n    onDownloadClosedWindows();\r\n  }\r\n});\r\n// #endif\r\n\r\nconst onFetch = (event: FetchEvent): void => {\r\n  if(\r\n    import.meta.env.PROD &&\r\n    !IS_SAFARI &&\r\n    event.request.url.indexOf(location.origin + '/') === 0 &&\r\n    event.request.url.match(/\\.(js|css|jpe?g|json|wasm|png|mp3|svg|tgs|ico|woff2?|ttf|webmanifest?)(?:\\?.*)?$/)\r\n  ) {\r\n    return event.respondWith(requestCache(event));\r\n  }\r\n\r\n  if(import.meta.env.DEV && event.request.url.endsWith('.ts')) {\r\n    return;\r\n  }\r\n\r\n  try {\r\n    // const [, url, scope, params] = /http[:s]+\\/\\/.*?(\\/(.*?)(?:$|\\/(.*)$))/.exec(event.request.url) || [];\r\n    const [scope, params] = event.request.url.split('/').slice(-2);\r\n\r\n    // log.debug('[fetch]:', event);\r\n\r\n    switch(scope) {\r\n      case 'stream': {\r\n        onStreamFetch(event, params);\r\n        break;\r\n      }\r\n\r\n      case 'download': {\r\n        onDownloadFetch(event, params);\r\n        break;\r\n      }\r\n\r\n      case 'share': {\r\n        onShareFetch(event, params);\r\n        break;\r\n      }\r\n\r\n      case 'ping': {\r\n        event.respondWith(new Response('pong'));\r\n        break;\r\n      }\r\n\r\n      // default: {\r\n      //   event.respondWith(fetch(event.request));\r\n      //   break;\r\n      // }\r\n    }\r\n  } catch(err) {\r\n    log.error('fetch error', err);\r\n    event.respondWith(new Response('', {\r\n      status: 500,\r\n      statusText: 'Internal Server Error',\r\n      headers: {'Cache-Control': 'no-cache'}\r\n    }));\r\n  }\r\n};\r\n\r\nconst onChangeState = () => {\r\n  ctx.onfetch = onFetch;\r\n};\r\n\r\nctx.addEventListener('install', (event) => {\r\n  log('installing');\r\n  event.waitUntil(ctx.skipWaiting().then(() => log('skipped waiting'))); // Activate worker immediately\r\n});\r\n\r\nctx.addEventListener('activate', (event) => {\r\n  log('activating', ctx);\r\n  event.waitUntil(ctx.caches.delete(CACHE_ASSETS_NAME).then(() => log('cleared assets cache')));\r\n  event.waitUntil(ctx.clients.claim().then(() => log('claimed clients')));\r\n});\r\n\r\n// ctx.onerror = (error) => {\r\n//   log.error('error:', error);\r\n// };\r\n\r\n// ctx.onunhandledrejection = (error) => {\r\n//   log.error('onunhandledrejection:', error);\r\n// };\r\n\r\nctx.onoffline = ctx.ononline = onChangeState;\r\n\r\nonChangeState();\r\n"],"names":["Modes","DEBUG","ctx","MOUNT_CLASS_TO","USER_AGENT","IS_SAFARI","IS_FIREFOX","IS_SERVICE_WORKER","IS_WEB_WORKER","IS_WORKER","getWindowClients","postMessage","listener","args","err","notifyServiceWorker","all","listeners","notifyWorker","noop","_logTimer","dT","LogTypes","LOG_LEVELS","IS_WEBKIT","STYLES_SUPPORTED","LOGGER_STYLES","methods","logger","prefix","type","ignoreDebugReset","style","originalPrefix","originalStyle","log","method","logType","newPrefix","level","acc","v","_type","pause","ms","resolve","CACHE_ASSETS_NAME","isCorrectResponse","response","timeoutRace","promise","requestCache","event","cache","file","headers","url","readBlobAs","blob","reader","e","readBlobAsArrayBuffer","readBlobAsUint8Array","buffer","deferredHelper","callback","value","deferredPromise","reject","deferred","_resolve","_reject","debounce","fn","shouldRunFirst","shouldRunLast","waitingTimeout","waitingPromise","hadNewCall","invoke","result","_waitingTimeout","blobSafeMimeType","mimeType","blobConstruct","blobParts","safeMimeType","MemoryWriter","size","saveFileCallback","part","offset","endOffset","newBytes","saveToStorage","parts","CACHED_ERRORS","makeError","_CacheStorageController","dbName","entryName","fileName","rejected","timeout","res","fileSize","enabled","clearWrite","storage","CacheStorageController","delay","deferredPromises","cacheStorage","CHUNK_TTL","CHUNK_CACHED_TIME_HEADER","clearOldChunks","requests","filtered","timestamp","request","match","promises","id","mtprotoMessagePort","getMtprotoMessagePort","messagePort","taskId","streams","Stream","info","STREAM_CHUNK_UPPER_LIMIT","STREAM_CHUNK_MIDDLE_LIMIT","alignedOffset","limit","fromPreload","payload","uploadFile","serviceMessagePort","bytesPromise","key","error","bytes","end","alignOffset","range","possibleResponse","responseForSafariFirstRange","alignLimit","ab","onStreamFetch","params","parseRange","stream","SMALLEST_CHUNK_LIMIT","header","chunks","ranges","base","DATABASE_STATE","NOTIFICATION_ICON_PATH","NOTIFICATION_BADGE_PATH","deepEqual","x","y","ignoreKeys","ignoreSet","okok","obj","ok","tx","safeAssign","object","fromObject","i","_IDB","db","createNew","createIndexes","os","store","indexNames","indexName","index","createObjectStore","finished","calledNew","transaction","target","instance","preserve","IDB","IDBStorage","storeName","isArray","objectStore","idx","mode","perf","onError","onComplete","results","r","waitForTransactionComplete","callbackResult","length","left","onRequestFinished","defaultBaseUrl","PING_PUSH_TIMEOUT","lastPingTime","localNotificationsAvailable","SomethingGetter","defaults","cached","getter","muteUntil","settings","lang","nowTime","userInvisibleIsSupported","notificationPromise","fireNotification","notification","action","data","clientList","pendingNotification","client","onCloseNotification","notifications","removeFromNotifications","closeAllNotifications","tag","len","title","body","peerId","messageKey","ignoreMessages","actions","notificationOptions","onPing","source","onShownNotification","time","_time","tabId","indexOfAndSplice","array","item","findAndSplice","verify","EventListenerBase","reuseResults","name","options","_a","l","collectResults","arr","USE_LOCKS","SuperMessagePort","logSuffix","task","previousResolve","ret","pingResolve","newEvent","innerTask","resultTaskPayload","resultTask","ackTask","isPromise","port","lock","portTasks","tasks","batchTask","ports","transfer","withAck","_void","interval","ServiceMessagePort","listenMessagePort","onConnect","onDisconnect","attachPort","listenPort","sendPort","downloadMap","DOWNLOAD_ERROR","DOWNLOAD_TEST","events","strategy","controller","readable","_controller","reason","chunk","handleDownload","onDownloadFetch","cancelAllDownloads","parseFormData","formData","processShareEvent","clientId","checkWindowClientForDeferredShare","windowClient","onShareFetch","_mtprotoMessagePort","sendMessagePort","channel","sendMessagePortIfNeeded","connectedWindows","onWindowConnected","onDownloadClosedWindows","windowClients","onFetch","scope","onChangeState"],"mappings":"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"}