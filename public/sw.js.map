{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/config/modes.ts","webpack:///./src/config/debug.ts","webpack:///./src/lib/logger.ts","webpack:///./src/config/databases/state.ts","webpack:///./src/helpers/userAgent.ts","webpack:///./src/lib/idb.ts","webpack:///./src/helpers/object.ts","webpack:///./src/helpers/blob.ts","webpack:///./src/lib/serviceWorker/push.ts","webpack:///./src/lib/serviceWorker/cache.ts","webpack:///./src/helpers/context.ts","webpack:///./src/lib/serviceWorker/stream.ts","webpack:///./src/lib/serviceWorker/timeout.ts","webpack:///./src/helpers/cancellablePromise.ts","webpack:///./src/lib/serviceWorker/index.service.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","test","location","search","indexOf","debug","http","ssl","multipleConnections","asServiceWorker","DEBUG","window","self","LogTypes","LOG_LEVELS","None","Error","Warn","Log","Debug","_logTimer","Date","now","dT","toFixed","logger","prefix","type","args","console","log","warn","info","error","trace","setPrefix","_prefix","setLevel","level","slice","reduce","acc","v","version","stores","userAgent","navigator","toLowerCase","vendor","isSafari","platform","maxTouchPoints","MSStream","match","isFirefox","db","storeName","storageIsAvailable","fromObject","undefined","safeAssign","this","openDatabase","STORAGES","push","forEach","storage","onclose","close","closeDatabases","storages","promises","Array","from","Set","map","dbName","Promise","resolve","reject","deleteRequest","indexedDB","deleteDatabase","onerror","onsuccess","all","createNew","openDbPromise","request","open","message","finished","setTimeout","event","result","calledNew","e","onabort","transaction","target","onversionchange","onupgradeneeded","oldVersion","newVersion","store","objectStoreNames","contains","os","createObjectStore","indexes","length","index","createIndex","indexName","keyPath","objectParameters","entryName","isArray","concat","getObjectStore","objectStore","delete","clear","idx","put","fileName","blob","Blob","blobParts","mimeType","safeMimeType","blobSafeMimeType","bb","BlobBuilder","blobPart","append","getBlob","blobConstruct","save","perf","performance","then","clearTimeout","timeout","oncomplete","results","requests","getAll","defaultBaseUrl","protocol","hostname","pathname","split","join","defaults","cache","err","callback","push_mute_until","push_last_alive","push_lang","push_settings","addEventListener","obj","data","json","hasActiveWindows","checksPromise","clients","matchAll","muteUntil","lastAliveTime","clientList","nowTime","userInvisibleIsSupported","Math","ceil","badge","catch","reason","closePromise","settings","lang","icon","peerId","title","body","description","custom","channel_id","chat_id","from_id","tag","nopreview","push_message_nopreview","actions","action","push_action_mute1d","registration","showNotification","notification","notifications","has","add","onCloseNotification","fireNotification","closeAllNotifications","waitUntil","set","promise","pendingNotification","payload","client","focus","postMessage","openWindow","baseUrl","getNotifications","len","isCorrectResponse","response","ok","status","isWebWorker","WorkerGlobalScope","isServiceWorker","ServiceWorkerGlobalScope","notifyServiceWorker","includeUncontrolled","listeners","listener","notifyWorker","noop","notifySomeone","onStreamFetch","params","range","header","chunks","ranges","offset","end","parseRange","headers","JSON","parse","decodeURIComponent","limitPart","size","STREAM_CHUNK_UPPER_LIMIT","STREAM_CHUNK_MIDDLE_LIMIT","delay","respondWith","race","Response","statusText","possibleResponse","Uint8Array","buffer","responseForSafariFirstRange","limit","alignLimit","alignedOffset","base","alignOffset","task","id","incrementTaskId","dcId","deferredPromises","deferredHelper","isFulfilled","isRejected","notify","notifyAll","lastNotify","addNotifyListener","deferred","finally","cancel","assign","deferredPromise","ab","bytes","byteLength","taskListeners","notifications_clear","ping","ports","source","localNotifications","onPing","requestFilePart","taskId","getTaskId","onFetch","url","origin","caches","file","ignoreVary","fetch","clone","replace","random","requestCache","scope","exec","onChangeState","onfetch","skipWaiting","claim","onunhandledrejection","onoffline","ononline"],"mappings":"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","file":"sw.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nconst Modes = {\n  test: location.search.indexOf('test=1') > 0/*  || true */,\n  debug: location.search.indexOf('debug=1') > 0,\n  http: false, //location.search.indexOf('http=1') > 0,\n  ssl: true, // location.search.indexOf('ssl=1') > 0 || location.protocol === 'https:' && location.search.indexOf('ssl=0') === -1,\n  multipleConnections: true,\n  asServiceWorker: false\n};\n\n                  \n                             \n          \n\nexport default Modes;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport Modes from \"./modes\";\n\nexport const DEBUG = process.env.NODE_ENV !== 'production' || Modes.debug;\nconst ctx: any = typeof(window) !== 'undefined' ? window : self;\nexport const MOUNT_CLASS_TO: any = DEBUG || true/*  && false */ ? ctx : {};\nexport default DEBUG;\n\n//let m = DEBUG;\n/* if(!DEBUG) {\n  ctx.sandpitTurtle = () => {\n    //if(!m) {\n      for(let i in MOUNT_CLASS_TO) {\n        ctx[i] = MOUNT_CLASS_TO[i];\n      }\n      //m = true;\n    //}\n  \n    //DEBUG = !DEBUG;\n  };\n} */\n\n/* export const superDebug = (object: any, key: string) => {\n  var d = object[key];\n  var beforeStr = '', afterStr = '';\n  for(var r of d) {\n    beforeStr += r.before.hex + '\\n';\n    afterStr += r.after.hex + '\\n';\n  }\n\n  beforeStr = beforeStr.trim();\n  afterStr = afterStr.trim();\n  //var beforeStr = d.map(r => r.before.hex).join('\\n');\n  //var afterStr = d.map(r => r.after.hex).join('\\n');\n\n  var dada = (name: string, str: string) => {\n    var a = document.createElement('a');\n    a.target = '_blank';\n    a.download = name + '.txt';\n    a.href = URL.createObjectURL(new Blob([str], {\n      type: 'text/plain'\n    }));\n    document.body.append(a);\n    a.click();\n  };\n\n  dada(key + '_' + 'before', beforeStr);\n  dada(key + '_' + 'after', afterStr);\n}\n\nMOUNT_CLASS_TO.superDebug = superDebug; */\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport DEBUG from \"../config/debug\";\n\nexport enum LogTypes {\n  None = 0,\n  Error = 1,\n  Warn = 2,\n  Log = 4,\n  Debug = 8\n};\n\nexport const LOG_LEVELS = [LogTypes.None, LogTypes.Error, LogTypes.Warn, LogTypes.Log, LogTypes.Debug];\n\nconst _logTimer = Date.now();\nfunction dT() {\n  return '[' + ((Date.now() - _logTimer) / 1000).toFixed(3) + ']';\n}\n\nexport function logger(prefix: string, type: LogTypes = LogTypes.Log | LogTypes.Warn | LogTypes.Error) {\n  if(!DEBUG/*  || true */) {\n    type = LogTypes.Error;\n  }\n\n  //level = LogLevels.log | LogLevels.warn | LogLevels.error | LogLevels.debug\n\n  function Log(...args: any[]) {\n    return type & LogTypes.Log && console.log(dT(), prefix, ...args);\n  }\n  \n  Log.warn = function(...args: any[]) {\n    return type & LogTypes.Warn && console.warn(dT(), prefix, ...args);\n  };\n  \n  Log.info = function(...args: any[]) {\n    return type & LogTypes.Log && console.info(dT(), prefix, ...args);\n  };\n  \n  Log.error = function(...args: any[]) {\n    return type & LogTypes.Error && console.error(dT(), prefix, ...args);\n  };\n  \n  Log.trace = function(...args: any[]) {\n    return type & LogTypes.Log && console.trace(dT(), prefix, ...args);\n  };\n\n  /* Log.debug = function(...args: any[]) {\n    return level & LogLevels.debug && console.log(dT(), prefix, ...args);\n  }; */\n\n  Log.debug = function(...args: any[]) {\n    return type & LogTypes.Debug && console.debug(dT(), prefix, ...args);\n  };\n\n  Log.setPrefix = function(_prefix: string) {\n    prefix = '[' + _prefix + ']:';\n  };\n\n  Log.setPrefix(prefix);\n\n  Log.setLevel = function(level: 0 | 1 | 2 | 3 | 4) {\n    type = LOG_LEVELS.slice(0, level + 1).reduce((acc, v) => acc | v, 0) as any;\n  };\n  \n  return Log;\n};\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport { Database } from '.';\n\nconst DATABASE_STATE: Database<'session' | 'stickerSets' | 'users' | 'chats' | 'messages' | 'dialogs'> = {\n  name: 'tweb',\n  version: 7,\n  stores: [{\n    name: 'session'\n  }, {\n    name: 'stickerSets'\n  }, {\n    name: 'users'\n  }, {\n    name: 'chats'\n  }, {\n    name: 'dialogs'\n  }, {\n    name: 'messages'\n  }]\n};\n\nexport default DATABASE_STATE;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nexport const userAgent = navigator ? navigator.userAgent : null;\nexport const isApple = navigator.userAgent.search(/OS X|iPhone|iPad|iOS/i) !== -1;\nexport const isAndroid = navigator.userAgent.toLowerCase().indexOf('android') !== -1;\nexport const isChromium = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\n\n/**\n * Returns true when run in WebKit derived browsers.\n * This is used as a workaround for a memory leak in Safari caused by using Transferable objects to\n * transfer data between WebWorkers and the main thread.\n * https://github.com/mapbox/mapbox-gl-js/issues/8771\n *\n * This should be removed once the underlying Safari issue is fixed.\n */\nexport const ctx = typeof(window) !== 'undefined' ? window : self;\n\n// https://stackoverflow.com/a/58065241\nexport const isAppleMobile = (/iPad|iPhone|iPod/.test(navigator.platform) ||\n  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)) &&\n  !ctx.MSStream;\n\nexport const isSafari = !!('safari' in ctx) || !!(userAgent && (/\\b(iPad|iPhone|iPod)\\b/.test(userAgent) || (!!userAgent.match('Safari') && !userAgent.match('Chrome'))))/*  || true */;\nexport const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n\nexport const isMobileSafari = isSafari && isAppleMobile;\n\nexport const isMobile = /* screen.width && screen.width < 480 ||  */navigator.userAgent.search(/iOS|iPhone OS|Android|BlackBerry|BB10|Series ?[64]0|J2ME|MIDP|opera mini|opera mobi|mobi.+Gecko|Windows Phone/i) != -1;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport { Database } from '../config/databases';\nimport Modes from '../config/modes';\nimport { blobConstruct } from '../helpers/blob';\nimport { safeAssign } from '../helpers/object';\nimport { logger } from './logger';\n\n/**\n * https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/createIndex\n */\nexport type IDBIndex = {\n  indexName: string,\n  keyPath: string,\n  objectParameters: IDBIndexParameters\n};\n\nexport type IDBStore = {\n  name: string, \n  indexes?: IDBIndex[]\n};\n\nexport type IDBOptions = {\n  name?: string,\n  storeName: string,\n  stores?: IDBStore[],\n  version?: number\n};\n\nconst DEBUG = false;\n\nexport default class IDBStorage<T extends Database<any>> {\n  private static STORAGES: IDBStorage<Database<any>>[] = [];\n  private openDbPromise: Promise<IDBDatabase>;\n  private db: IDBDatabase;\n  private storageIsAvailable = true;\n\n  private log: ReturnType<typeof logger>;\n  \n  private name: string;\n  private version: number;\n  private stores: IDBStore[];\n  private storeName: string;\n\n  constructor(db: T, storeName: typeof db['stores'][0]['name']) {\n    safeAssign(this, db);\n\n    if(Modes.test) {\n      this.name += '_test';\n    }\n\n    this.storeName = storeName;\n\n    this.log = logger('IDB-' + this.storeName);\n\n    this.openDatabase(true);\n\n    IDBStorage.STORAGES.push(this);\n  }\n\n  public static closeDatabases() {\n    this.STORAGES.forEach(storage => {\n      const db = storage.db;\n      if(db) {\n        db.onclose = () => {};\n        db.close();\n      }\n    });\n  }\n\n  public static deleteDatabase() {\n    this.closeDatabases();\n\n    const storages = this.STORAGES;\n    const dbNames = Array.from(new Set(storages.map(storage => storage.name)));\n    const promises = dbNames.map(dbName => {\n      return new Promise<void>((resolve, reject) => {\n        const deleteRequest = indexedDB.deleteDatabase(dbName);\n  \n        deleteRequest.onerror = () => {\n          reject();\n        };\n  \n        deleteRequest.onsuccess = () => {\n          resolve();\n        };\n      });\n    });\n\n    return Promise.all(promises);\n  }\n\n  public isAvailable() {\n    return this.storageIsAvailable;\n  }\n\n  public openDatabase(createNew = false): Promise<IDBDatabase> {\n    if(this.openDbPromise && !createNew) {\n      return this.openDbPromise;\n    }\n\n    const createObjectStore = (db: IDBDatabase, store: IDBStore) => {\n      const os = db.createObjectStore(store.name);\n\n      if(store.indexes?.length) {\n        for(const index of store.indexes) {\n          os.createIndex(index.indexName, index.keyPath, index.objectParameters);\n        }\n      }\n    };\n\n    try {\n      var request = indexedDB.open(this.name, this.version);\n\n      if(!request) {\n        return Promise.reject();\n      }\n    } catch(error) {\n      this.log.error('error opening db', error.message)\n      this.storageIsAvailable = false;\n      return Promise.reject(error);\n    }\n\n    let finished = false;\n    setTimeout(() => {\n      if(!finished) {\n        request.onerror({type: 'IDB_CREATE_TIMEOUT'} as Event);\n      }\n    }, 3000);\n\n    return this.openDbPromise = new Promise<IDBDatabase>((resolve, reject) => {\n      request.onsuccess = (event) => {\n        finished = true;\n        const db = request.result;\n        let calledNew = false;\n\n        this.log('Opened');\n  \n        db.onerror = (error) => {\n          this.storageIsAvailable = false;\n          this.log.error('Error creating/accessing IndexedDB database', error);\n          reject(error);\n        };\n\n        db.onclose = (e) => {\n          this.log.error('closed:', e);\n          !calledNew && this.openDatabase();\n        };\n\n        db.onabort = (e) => {\n          this.log.error('abort:', e);\n          const transaction = e.target as IDBTransaction;\n          \n          this.openDatabase(calledNew = true);\n\n          if(transaction.onerror) {\n            transaction.onerror(e);\n          }\n\n          db.close();\n        };\n\n        db.onversionchange = (e) => {\n          this.log.error('onversionchange, lol?');\n        };\n\n        resolve(this.db = db);\n      };\n  \n      request.onerror = (event) => {\n        finished = true;\n        this.storageIsAvailable = false;\n        this.log.error('Error creating/accessing IndexedDB database', event);\n        reject(event);\n      };\n  \n      request.onupgradeneeded = (event) => {\n        finished = true;\n        this.log.warn('performing idb upgrade from', event.oldVersion, 'to', event.newVersion);\n\n        // @ts-ignore\n        var db = event.target.result as IDBDatabase;\n        this.stores.forEach((store) => {\n          /* if(db.objectStoreNames.contains(store.name)) {\n            //if(event.oldVersion === 1) {\n              db.deleteObjectStore(store.name);\n            //}\n          } */\n    \n          if(!db.objectStoreNames.contains(store.name)) {\n            createObjectStore(db, store);\n          }\n        });\n      };\n    });\n  }\n\n  public delete(entryName: string | string[]): Promise<void> {\n    //return Promise.resolve();\n    if(!Array.isArray(entryName)) {\n      entryName = [].concat(entryName);\n    }\n\n    return this.getObjectStore('readwrite', (objectStore) => {\n      return (entryName as string[]).map((entryName) => objectStore.delete(entryName));\n    }, DEBUG ? 'delete: ' + entryName.join(', ') : '');\n  }\n\n  public deleteAll() {\n    return this.getObjectStore('readwrite', (objectStore) => objectStore.clear(), DEBUG ? 'deleteAll' : '');\n  }\n\n  public save(entryName: string | string[], value: any | any[]) {\n    // const handleError = (error: Error) => {\n    //   this.log.error('save: transaction error:', entryName, value, db, error, error && error.name);\n    //   if((!error || error.name === 'InvalidStateError')/*  && false */) {\n    //     setTimeout(() => {\n    //       this.save(entryName, value);\n    //     }, 2e3);\n    //   } else {\n    //     //console.error('IndexedDB saveFile transaction error:', error, error && error.name);\n    //   }\n    // };\n\n    if(!Array.isArray(entryName)) {\n      entryName = [].concat(entryName);\n      value = [].concat(value);\n    }\n    \n    return this.getObjectStore('readwrite', (objectStore) => {\n      return (entryName as string[]).map((entryName, idx) => objectStore.put(value[idx], entryName));\n    }, DEBUG ? 'save: ' + entryName.join(', ') : '');\n  }\n\n  public saveFile(fileName: string, blob: Blob | Uint8Array) {\n    //return Promise.resolve(blobConstruct([blob]));\n    if(!(blob instanceof Blob)) {\n      blob = blobConstruct([blob]) as Blob;\n    }\n\n    return this.save(fileName, blob);\n  }\n\n  /* public saveFileBase64(db: IDBDatabase, fileName: string, blob: Blob | any): Promise<Blob> {\n    if(this.getBlobSize(blob) > 10 * 1024 * 1024) {\n      return Promise.reject();\n    }\n\n    if(!(blob instanceof Blob)) {\n      var safeMimeType = blobSafeMimeType(blob.type || 'image/jpeg');\n      var address = 'data:' + safeMimeType + ';base64,' + bytesToBase64(blob);\n      return this.storagePutB64String(db, fileName, address).then(() => {\n        return blob;\n      });\n    }\n\n    try {\n      var reader = new FileReader();\n    } catch (e) {\n      this.storageIsAvailable = false;\n      return Promise.reject();\n    }\n\n    let promise = new Promise<Blob>((resolve, reject) => {\n      reader.onloadend = () => {\n        this.storagePutB64String(db, fileName, reader.result as string).then(() => {\n          resolve(blob);\n        }, reject);\n      }\n  \n      reader.onerror = reject;\n    });\n    \n\n    try {\n      reader.readAsDataURL(blob);\n    } catch (e) {\n      this.storageIsAvailable = false;\n      return Promise.reject();\n    }\n\n    return promise;\n  }\n\n  public storagePutB64String(db: IDBDatabase, fileName: string, b64string: string) {\n    try {\n      var objectStore = db.transaction([this.storeName], 'readwrite')\n        .objectStore(this.storeName);\n      var request = objectStore.put(b64string, fileName);\n    } catch(error) {\n      this.storageIsAvailable = false;\n      return Promise.reject(error);\n    }\n\n    return new Promise((resolve, reject) => {\n      request.onsuccess = function(event) {\n        resolve();\n      };\n  \n      request.onerror = reject;\n    });\n  }\n\n  public getBlobSize(blob: any) {\n    return blob.size || blob.byteLength || blob.length;\n  } */\n\n  public get<T>(entryName: string[]): Promise<T[]>;\n  public get<T>(entryName: string): Promise<T>;\n  public get<T>(entryName: string | string[]): Promise<T> | Promise<T[]> {\n    //return Promise.reject();\n\n    if(!Array.isArray(entryName)) {\n      entryName = [].concat(entryName);\n    }\n\n    return this.getObjectStore<T>('readonly', (objectStore) => {\n      return (entryName as string[]).map((entryName) => objectStore.get(entryName));\n    }, DEBUG ? 'get: ' + entryName.join(', ') : '');\n  }\n\n  private getObjectStore<T>(mode: IDBTransactionMode, objectStore: (objectStore: IDBObjectStore) => IDBRequest | IDBRequest[], log?: string) {\n    let perf: number;\n\n    if(log) {\n      perf = performance.now();\n      this.log(log + ': start');\n    }\n\n    return this.openDatabase().then((db) => {\n      return new Promise<T>((resolve, reject) => {\n        const transaction = db.transaction([this.storeName], mode);\n\n        transaction.onerror = (e) => {\n          clearTimeout(timeout);\n          reject(transaction.error);\n        };\n  \n        transaction.oncomplete = (e) => {\n          clearTimeout(timeout);\n\n          if(log) {\n            this.log(log + ': end', performance.now() - perf);\n          }\n\n          const results = r.map(r => r.result);\n          resolve(isArray ? results : results[0]);\n        };\n  \n        const timeout = setTimeout(() => {\n          this.log.error('transaction not finished', transaction);\n        }, 10000);\n  \n        /* transaction.addEventListener('abort', (e) => {\n          //handleError();\n          this.log.error('IndexedDB: transaction abort!', transaction.error);\n        }); */\n  \n        const requests = objectStore(transaction.objectStore(this.storeName));\n\n        const isArray = Array.isArray(requests);\n        const r: IDBRequest[] = isArray ? requests : [].concat(requests) as any;\n\n        // const length = r.length;\n        // /* let left = length;\n\n        // const onRequestFinished = (error?: Error) => {\n        //   if(!--left) {\n        //     resolve(result);\n        //     clearTimeout(timeout);\n        //   }\n        // }; */\n\n        // for(let i = 0; i < length; ++i) {\n        //   const request = r[i];\n        //   request.onsuccess = () => {\n        //     onRequestFinished();\n        //   };\n\n        //   request.onerror = (e) => {\n        //     onRequestFinished(transaction.error);\n        //   };\n        // }\n      });\n    });\n  }\n\n  public getAll<T>(): Promise<T[]> {\n    return this.getObjectStore<T[]>('readonly', (objectStore) => objectStore.getAll(), DEBUG ? 'getAll' : '');\n  }\n\n  /* public getAllKeys(): Promise<Array<string>> {\n    console.time('getAllEntries');\n    return this.openDatabase().then((db) => {\n      var objectStore = db.transaction([this.storeName], 'readonly')\n        .objectStore(this.storeName);\n      var request = objectStore.getAllKeys();\n\n      return new Promise((resolve, reject) => {\n        request.onsuccess = function(event) {\n          // @ts-ignore\n          var result = event.target.result;\n          resolve(result);\n          console.timeEnd('getAllEntries');\n        }\n  \n        request.onerror = reject;\n      });\n    });\n  } */\n\n  /* public isFileExists(fileName: string): Promise<boolean> {\n    console.time('isFileExists');\n    return this.openDatabase().then((db) => {\n      var objectStore = db.transaction([this.storeName], 'readonly')\n        .objectStore(this.storeName);\n      var request = objectStore.openCursor(fileName);\n\n      return new Promise((resolve, reject) => {\n        request.onsuccess = function(event) {\n          // @ts-ignore\n          var cursor = event.target.result;\n          resolve(!!cursor);\n          console.timeEnd('isFileExists');\n        }\n  \n        request.onerror = reject;\n      });\n    });\n  } */\n\n  /* public getFileWriter(fileName: string, mimeType: string) {\n    var fakeWriter = FileManager.getFakeFileWriter(mimeType, (blob) => {\n      return this.saveFile(fileName, blob);\n    });\n\n    return Promise.resolve(fakeWriter);\n  } */\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nexport function copy<T>(obj: T): T {\n  //in case of premitives\n  if(obj === null || typeof(obj) !== \"object\") {\n    return obj;\n  }\n \n  //date objects should be \n  if(obj instanceof Date) {\n    return new Date(obj.getTime()) as any;\n  }\n \n  //handle Array\n  if(Array.isArray(obj)) {\n    // @ts-ignore\n    const clonedArr: T = obj.map(el => copy(el)) as any as T;\n    return clonedArr;\n  }\n \n  //lastly, handle objects\n  // @ts-ignore\n  let clonedObj = new obj.constructor();\n  for(var prop in obj){\n    if(obj.hasOwnProperty(prop)) {\n      clonedObj[prop] = copy(obj[prop]);\n    }\n  }\n  return clonedObj;\n}\n\nexport function deepEqual(x: any, y: any): boolean {\n  const ok = Object.keys, tx = typeof x, ty = typeof y;\n  return x && y && tx === 'object' && tx === ty ? (\n    ok(x).length === ok(y).length &&\n      ok(x).every(key => deepEqual(x[key], y[key]))\n  ) : (x === y);\n}\n\nexport function defineNotNumerableProperties(obj: {[key: string]: any}, names: string[]) {\n  //const perf = performance.now();\n  const props = {writable: true, configurable: true};\n  const out: {[name: string]: typeof props} = {};\n  names.forEach(name => {\n    if(obj[name] === undefined) {\n      out[name] = props;\n    }\n  });\n  Object.defineProperties(obj, out);\n  //console.log('defineNotNumerableProperties time:', performance.now() - perf);\n}\n\nexport function getObjectKeysAndSort(object: any, sort: 'asc' | 'desc' = 'asc') {\n  if(!object) return [];\n  const ids = Object.keys(object).map(i => +i);\n  if(sort === 'asc') return ids.sort((a, b) => a - b);\n  else return ids.sort((a, b) => b - a);\n}\n\nexport function safeReplaceObject(wasObject: any, newObject: any) {\n  if(!wasObject) {\n    return newObject;\n  }\n\n  for(var key in wasObject) {\n    if(!newObject.hasOwnProperty(key)) {\n      delete wasObject[key];\n    }\n  }\n\n  for(var key in newObject) {\n    //if (newObject.hasOwnProperty(key)) { // useless\n      wasObject[key] = newObject[key];\n    //}\n  }\n  \n  return wasObject;\n}\n\n/**\n * Will be used for FILE_REFERENCE_EXPIRED\n * @param key \n * @param wasObject \n * @param newObject \n */\nexport function safeReplaceArrayInObject<K>(key: K, wasObject: any, newObject: any) {\n  if('byteLength' in newObject[key]) { // Uint8Array\n    newObject[key] = [...newObject[key]];\n  }\n\n  if(wasObject && wasObject[key] !== newObject[key]) {\n    wasObject[key].length = newObject[key].length;\n    (newObject[key] as any[]).forEach((v, i) => {\n      wasObject[key][i] = v;\n    });\n\n    /* wasObject[key].set(newObject[key]); */\n    newObject[key] = wasObject[key];\n  }\n}\n\nexport function isObject(object: any) {\n  return typeof(object) === 'object' && object !== null;\n}\n\nexport function getDeepProperty(object: any, key: string) {\n  const splitted = key.split('.');\n  let o: any = object;\n  splitted.forEach(key => {\n    if(!key) {\n      return;\n    }\n    \n    // @ts-ignore\n    o = o[key];\n  });\n  \n  return o;\n}\n\nexport function setDeepProperty(object: any, key: string, value: any) {\n  const splitted = key.split('.');\n  getDeepProperty(object, splitted.slice(0, -1).join('.'))[splitted.pop()] = value;\n}\n\nexport function validateInitObject(initObject: any, currentObject: any, onReplace?: (key: string) => void, previousKey?: string) {\n  for(const key in initObject) {\n    if(typeof(currentObject[key]) !== typeof(initObject[key])) {\n      currentObject[key] = copy(initObject[key]);\n      onReplace && onReplace(previousKey || key);\n    } else if(isObject(initObject[key])) {\n      validateInitObject(initObject[key], currentObject[key], onReplace, previousKey || key);\n    }\n  }\n}\n\nexport function safeAssign(object: any, fromObject: any) {\n  if(!fromObject) return;\n  \n  for(let i in fromObject) {\n    if(fromObject[i] !== undefined) {\n      object[i] = fromObject[i];\n    }\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nexport const readBlobAsText = (blob: Blob) => {\n  return new Promise<string>(resolve => {\n    const reader = new FileReader();\n    reader.addEventListener('loadend', (e) => {\n      // @ts-ignore\n      resolve(e.srcElement.result);\n    });\n    reader.readAsText(blob);\n  });\n};\n\nexport function blobConstruct(blobParts: any, mimeType: string = ''): Blob {\n  let blob;\n  const safeMimeType = blobSafeMimeType(mimeType);\n  try {\n    blob = new Blob(blobParts, {type: safeMimeType});\n  } catch(e) {\n    // @ts-ignore\n    let bb = new BlobBuilder;\n    blobParts.forEach((blobPart: any) => {\n      bb.append(blobPart);\n    });\n    blob = bb.getBlob(safeMimeType);\n  }\n  return blob;\n}\n\n// https://www.iana.org/assignments/media-types/media-types.xhtml\nexport function blobSafeMimeType(mimeType: string) {\n  if([\n    'image/jpeg',\n    'image/png',\n    'image/gif',\n    'image/webp',\n    'image/bmp',\n    'video/mp4',\n    'video/webm',\n    'video/quicktime',\n    'audio/ogg',\n    'audio/mpeg',\n    'audio/mp4',\n    'application/json',\n    'application/pdf'\n  ].indexOf(mimeType) === -1) {\n    return 'application/octet-stream';\n  }\n\n  return mimeType;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport { Database } from \"../../config/databases\";\nimport DATABASE_STATE from \"../../config/databases/state\";\nimport { isFirefox } from \"../../helpers/userAgent\";\nimport IDBStorage from \"../idb\";\nimport { log, ServiceWorkerPingTask, ServiceWorkerPushClickTask } from \"./index.service\";\n\nconst ctx = self as any as ServiceWorkerGlobalScope;\nconst defaultBaseUrl = location.protocol + '//' + location.hostname + location.pathname.split('/').slice(0, -1).join('/') + '/';\n\nexport type PushNotificationObject = {\n  loc_key: string,\n  loc_args: string[],\n  //user_id: number, // should be number\n  custom: {\n    channel_id?: string, // should be number\n    chat_id?: string, // should be number\n    from_id?: string, // should be number\n    msg_id: string,\n    peerId?: string // should be number\n  },\n  sound?: string,\n  random_id: number,\n  badge?: string, // should be number\n  description: string,\n  mute: string, // should be number\n  title: string,\n\n  action?: 'mute1d' | 'push_settings', // will be set before postMessage to main thread\n};\n\nclass SomethingGetter<T extends Database<any>, Storage extends Record<string, any>> {\n  private cache: Partial<Storage> = {};\n  private storage: IDBStorage<T>;\n\n  constructor(\n    db: T, \n    storeName: typeof db['stores'][number]['name'], \n    private defaults: {\n      [Property in keyof Storage]: ((value: Storage[Property]) => Storage[Property]) | Storage[Property]\n    }\n  ) {\n    this.storage = new IDBStorage<T>(db, storeName);\n  }\n\n  public async get<T extends keyof Storage>(key: T) {\n    if(this.cache[key] !== undefined) {\n      return this.cache[key];\n    }\n\n    let value: Storage[T];\n    try {\n      value = await this.storage.get(key as string);\n    } catch(err) {\n\n    }\n\n    if(this.cache[key] !== undefined) {\n      return this.cache[key];\n    }\n\n    if(value === undefined) {\n      const callback = this.defaults[key];\n      value = typeof(callback) === 'function' ? callback() : callback;\n    }\n\n    return this.cache[key] = value;\n  }\n\n  public async set<T extends keyof Storage>(key: T, value: Storage[T]) {\n    this.cache[key] = value;\n\n    try {\n      this.storage.save(key as string, value);\n    } catch(err) {\n\n    }\n  }\n}\n\ntype PushStorage = {\n  push_mute_until: number,\n  push_last_alive: number,\n  push_lang: Partial<ServiceWorkerPingTask['payload']['lang']>\n  push_settings: Partial<ServiceWorkerPingTask['payload']['settings']>\n};\n\nconst getter = new SomethingGetter<typeof DATABASE_STATE, PushStorage>(DATABASE_STATE, 'session', {\n  push_mute_until: 0,\n  push_last_alive: 0,\n  push_lang: {},\n  push_settings: {}\n});\n\nctx.addEventListener('push', (event) => {\n  const obj: PushNotificationObject = event.data.json();\n  log('push', obj);\n\n  let hasActiveWindows = false;\n  const checksPromise = Promise.all([\n    getter.get('push_mute_until'), \n    getter.get('push_last_alive'), \n    ctx.clients.matchAll({type: 'window'})\n  ]).then((result) => {\n    const [muteUntil, lastAliveTime, clientList] = result;\n    \n    log('matched clients', clientList);\n    hasActiveWindows = clientList.length > 0;\n    if(hasActiveWindows) {\n      throw 'Supress notification because some instance is alive';\n    }\n    \n    const nowTime = Date.now();\n    if(userInvisibleIsSupported() &&\n        muteUntil &&\n        nowTime < muteUntil) {\n      throw `Supress notification because mute for ${Math.ceil((muteUntil - nowTime) / 60000)} min`;\n    }\n\n    if(!obj.badge) {\n      throw 'No badge?';\n    }\n  });\n\n  checksPromise.catch(reason => {\n    log(reason);\n  });\n\n  const notificationPromise = checksPromise.then(() => {\n    return Promise.all([getter.get('push_settings'), getter.get('push_lang')])\n  }).then((result) => {\n    return fireNotification(obj, result[0], result[1]);\n  });\n\n  const closePromise = notificationPromise.catch(() => {\n    log('Closing all notifications on push', hasActiveWindows);\n    if(userInvisibleIsSupported() || hasActiveWindows) {\n      return closeAllNotifications();\n    }\n\n    return ctx.registration.showNotification('Telegram', {\n      tag: 'unknown_peer'\n    }).then(() => {\n      if(hasActiveWindows) {\n        return closeAllNotifications();\n      }\n\n      setTimeout(() => closeAllNotifications(), hasActiveWindows ? 0 : 100);\n    }).catch((error) => {\n      log.error('Show notification error', error);\n    });\n  });\n\n  event.waitUntil(closePromise);\n});\n\nctx.addEventListener('notificationclick', (event) => {\n  const notification = event.notification;\n  log('On notification click: ', notification.tag);\n  notification.close();\n\n  const action = event.action as PushNotificationObject['action'];\n  if(action === 'mute1d' && userInvisibleIsSupported()) {\n    log('[SW] mute for 1d');\n    getter.set('push_mute_until', Date.now() + 86400e3);\n    return;\n  }\n\n  const data: PushNotificationObject = notification.data;\n  if(!data) {\n    return;\n  }\n\n  const promise = ctx.clients.matchAll({\n    type: 'window'\n  }).then((clientList) => {\n    data.action = action;\n    pendingNotification = {type: 'push_click', payload: data};\n    for(let i = 0; i < clientList.length; i++) {\n      const client = clientList[i];\n      if('focus' in client) {\n        client.focus();\n        client.postMessage(pendingNotification);\n        pendingNotification = undefined;\n        return;\n      }\n    }\n\n    if(ctx.clients.openWindow) {\n      return getter.get('push_settings').then((settings) => {\n        return ctx.clients.openWindow(settings.baseUrl || defaultBaseUrl);\n      });\n    }\n  }).catch((error) => {\n    log.error('Clients.matchAll error', error);\n  })\n\n  event.waitUntil(promise);\n});\n\nctx.addEventListener('notificationclose', onCloseNotification);\n\nlet notifications: Set<Notification> = new Set();\nlet pendingNotification: ServiceWorkerPushClickTask;\nfunction pushToNotifications(notification: Notification) {\n  if(!notifications.has(notification)) {\n    notifications.add(notification);\n    // @ts-ignore\n    notification.onclose = onCloseNotification;\n  }\n}\n\nfunction onCloseNotification(event: NotificationEvent) {\n  removeFromNotifications(event.notification)\n}\n\nfunction removeFromNotifications(notification: Notification) {\n  notifications.delete(notification);\n}\n\nexport function closeAllNotifications() {\n  for(const notification of notifications) {\n    try {\n      notification.close();\n    } catch(e) {}\n  }\n\n  let promise: Promise<void>;\n  if('getNotifications' in ctx.registration) {\n    promise = ctx.registration.getNotifications({}).then((notifications) => {\n      for(let i = 0, len = notifications.length; i < len; ++i) {\n        try {\n          notifications[i].close();\n        } catch(e) {}\n      }\n    }).catch((error) => {\n      log.error('Offline register SW error', error);\n    });\n  } else {\n    promise = Promise.resolve();\n  }\n\n  notifications.clear();\n\n  return promise;\n}\n\nfunction userInvisibleIsSupported() {\n  return isFirefox;\n}\n\nfunction fireNotification(obj: PushNotificationObject, settings: PushStorage['push_settings'], lang: PushStorage['push_lang']) {\n  const icon = 'assets/img/logo_filled_rounded.png';\n  let title = obj.title || 'Telegram';\n  let body = obj.description || '';\n  let peerId: number;\n\n  if(obj.custom) {\n    if(obj.custom.channel_id) {\n      peerId = -obj.custom.channel_id;\n    } else if(obj.custom.chat_id) {\n      peerId = -obj.custom.chat_id;\n    } else {\n      peerId = +obj.custom.from_id || 0;\n    }\n  }\n\n  obj.custom.peerId = '' + peerId;\n  let tag = 'peer' + peerId;\n\n  if(settings && settings.nopreview) {\n    title = 'Telegram';\n    body = lang.push_message_nopreview || 'You have a new message';\n    tag = 'unknown_peer';\n  }\n\n  log('show notify', title, body, icon, obj);\n\n  const actions: (Omit<NotificationAction, 'action'> & {action: PushNotificationObject['action']})[] = [{\n    action: 'mute1d',\n    title: lang.push_action_mute1d || 'Mute for 24H'\n  }/* , {\n    action: 'push_settings',\n    title: lang.push_action_settings || 'Settings'\n  } */];\n\n  const notificationPromise = ctx.registration.showNotification(title, {\n    body,\n    icon,\n    tag,\n    data: obj,\n    actions\n  });\n\n  return notificationPromise.then((event) => {\n    // @ts-ignore\n    if(event && event.notification) {\n      // @ts-ignore\n      pushToNotifications(event.notification);\n    }\n  }).catch((error) => {\n    log.error('Show notification promise', error);\n  });\n}\n\nexport function onPing(task: ServiceWorkerPingTask, event: ExtendableMessageEvent) {\n  const client = event.ports && event.ports[0] || event.source;\n  const payload = task.payload;\n\n  if(payload.localNotifications) {\n    getter.set('push_last_alive', Date.now());\n  }\n\n  if(pendingNotification &&\n      client &&\n      'postMessage' in client) {\n    client.postMessage(pendingNotification, []);\n    pendingNotification = undefined;\n  }\n\n  if(payload.lang) {\n    getter.set('push_lang', payload.lang);\n  }\n\n  if(payload.settings) {\n    getter.set('push_settings', payload.settings);\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nconst ctx = self as any as ServiceWorkerGlobalScope;\nexport const CACHE_ASSETS_NAME = 'cachedAssets';\n\nfunction isCorrectResponse(response: Response) {\n  return response.ok && response.status === 200;\n}\n\nexport async function requestCache(event: FetchEvent) {\n  try {\n    const cache = await ctx.caches.open(CACHE_ASSETS_NAME);\n    const file = await cache.match(event.request, {ignoreVary: true});\n  \n    if(file && isCorrectResponse(file)) {\n      return file;\n    }\n  \n    const headers: HeadersInit = {'Vary': '*'};\n    let response = await fetch(event.request, {headers});\n    if(isCorrectResponse(response)) {\n      cache.put(event.request, response.clone());\n    } else if(response.status === 304) { // possible fix for 304 in Safari\n      const url = event.request.url.replace(/\\?.+$/, '') + '?' + (Math.random() * 100000 | 0);\n      response = await fetch(url, {headers});\n      if(isCorrectResponse(response)) {\n        cache.put(event.request, response.clone());\n      }\n    }\n  \n    return response;\n  } catch(err) {\n    return fetch(event.request);\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nexport const isWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\nexport const isServiceWorker = typeof ServiceWorkerGlobalScope !== 'undefined' && self instanceof ServiceWorkerGlobalScope;\nexport const isWorker = isWebWorker || isServiceWorker;\n\n// в SW может быть сразу две переменных TRUE, поэтому проверяю по последней\n\nconst notifyServiceWorker = (all: boolean, ...args: any[]) => {\n  (self as any as ServiceWorkerGlobalScope)\n  .clients\n  .matchAll({ includeUncontrolled: false, type: 'window' })\n  .then((listeners) => {\n    if(!listeners.length) {\n      //console.trace('no listeners?', self, listeners);\n      return;\n    }\n\n    listeners.slice(all ? 0 : -1).forEach(listener => {\n      // @ts-ignore\n      listener.postMessage(...args);\n    });\n  });\n};\n\nconst notifyWorker = (...args: any[]) => {\n  // @ts-ignore\n  (self as any as DedicatedWorkerGlobalScope).postMessage(...args);\n};\n\nconst noop = () => {};\n\nexport const notifySomeone = isServiceWorker ? notifyServiceWorker.bind(null, false) : (isWebWorker ? notifyWorker : noop);\nexport const notifyAll = isServiceWorker ? notifyServiceWorker.bind(null, true) : (isWebWorker ? notifyWorker : noop);\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport { deferredPromise } from \"../../helpers/cancellablePromise\";\nimport { notifySomeone } from \"../../helpers/context\";\nimport { isSafari } from \"../../helpers/userAgent\";\nimport { UploadFile } from \"../../layer\";\nimport { DownloadOptions } from \"../mtproto/apiFileManager\";\nimport { RequestFilePartTask, deferredPromises, incrementTaskId } from \"./index.service\";\nimport timeout from \"./timeout\";\n\nexport default function onStreamFetch(event: FetchEvent, params: string) {\n  const range = parseRange(event.request.headers.get('Range'));\n  let [offset, end] = range;\n\n  const info: DownloadOptions = JSON.parse(decodeURIComponent(params));\n  //const fileName = getFileNameByLocation(info.location);\n\n  // ! если грузить очень большое видео чанками по 512Кб в мобильном Safari, то стрим не запустится\n  const limitPart = info.size > (75 * 1024 * 1024) ? STREAM_CHUNK_UPPER_LIMIT : STREAM_CHUNK_MIDDLE_LIMIT;\n\n  /* if(info.size > limitPart && isSafari && offset === limitPart) {\n    //end = info.size - 1;\n    //offset = info.size - 1 - limitPart;\n    offset = info.size - (info.size % limitPart);\n  } */\n\n  //log.debug('[stream]', url, offset, end);\n\n  event.respondWith(Promise.race([\n    timeout(45 * 1000),\n\n    new Promise<Response>((resolve, reject) => {\n      // safari workaround\n      const possibleResponse = responseForSafariFirstRange(range, info.mimeType, info.size);\n      if(possibleResponse) {\n        return resolve(possibleResponse);\n      }\n\n      const limit = end && end < limitPart ? alignLimit(end - offset + 1) : limitPart;\n      const alignedOffset = alignOffset(offset, limit);\n\n      //log.debug('[stream] requestFilePart:', /* info.dcId, info.location, */ alignedOffset, limit);\n\n      const task: RequestFilePartTask = {\n        type: 'requestFilePart',\n        id: incrementTaskId(),\n        payload: [info.dcId, info.location, alignedOffset, limit]\n      };\n\n      \n      const deferred = deferredPromises[task.id] = deferredPromise<UploadFile.uploadFile>();\n      deferred.then(result => {\n        let ab = result.bytes as Uint8Array;\n        \n        //log.debug('[stream] requestFilePart result:', result);\n\n        const headers: Record<string, string> = {\n          'Accept-Ranges': 'bytes',\n          'Content-Range': `bytes ${alignedOffset}-${alignedOffset + ab.byteLength - 1}/${info.size || '*'}`,\n          'Content-Length': `${ab.byteLength}`,\n        };\n\n        if(info.mimeType) headers['Content-Type'] = info.mimeType;\n\n        if(isSafari) {\n          ab = ab.slice(offset - alignedOffset, end - alignedOffset + 1);\n          headers['Content-Range'] = `bytes ${offset}-${offset + ab.byteLength - 1}/${info.size || '*'}`;\n          headers['Content-Length'] = `${ab.byteLength}`;\n        }\n\n        // simulate slow connection\n        //setTimeout(() => {\n          resolve(new Response(ab, {\n            status: 206,\n            statusText: 'Partial Content',\n            headers,\n          }));\n        //}, 2.5e3);\n      }).catch(err => {});\n\n      notifySomeone(task);\n    })\n  ]));\n}\n\nfunction responseForSafariFirstRange(range: [number, number], mimeType: string, size: number): Response {\n  if(range[0] === 0 && range[1] === 1) {\n    return new Response(new Uint8Array(2).buffer, {\n      status: 206,\n      statusText: 'Partial Content',\n      headers: {\n        'Accept-Ranges': 'bytes',\n        'Content-Range': `bytes 0-1/${size || '*'}`,\n        'Content-Length': '2',\n        'Content-Type': mimeType || 'video/mp4',\n      },\n    });\n  }\n\n  return null;\n}\n\n/* const STREAM_CHUNK_UPPER_LIMIT = 256 * 1024;\nconst SMALLEST_CHUNK_LIMIT = 256 * 4; */\n/* const STREAM_CHUNK_UPPER_LIMIT = 1024 * 1024;\nconst SMALLEST_CHUNK_LIMIT = 1024 * 4; */\nconst STREAM_CHUNK_MIDDLE_LIMIT = 512 * 1024;\nconst STREAM_CHUNK_UPPER_LIMIT = 1024 * 1024;\nconst SMALLEST_CHUNK_LIMIT = 512 * 4;\n\nfunction parseRange(header: string): [number, number] {\n  if(!header) return [0, 0];\n  const [, chunks] = header.split('=');\n  const ranges = chunks.split(', ');\n  const [offset, end] = ranges[0].split('-');\n\n  return [+offset, +end || 0];\n}\n\nfunction alignOffset(offset: number, base = SMALLEST_CHUNK_LIMIT) {\n  return offset - (offset % base);\n}\n\nfunction alignLimit(limit: number) {\n  return 2 ** Math.ceil(Math.log(limit) / Math.log(2));\n}\n","export default function timeout(delay: number): Promise<Response> {\n  return new Promise(((resolve) => {\n    setTimeout(() => {\n      resolve(new Response('', {\n        status: 408,\n        statusText: 'Request timed out.',\n      }));\n    }, delay);\n  }));\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nexport interface CancellablePromise<T> extends Promise<T> {\n  resolve?: (...args: any[]) => void,\n  reject?: (...args: any[]) => void,\n  cancel?: () => void,\n\n  notify?: (...args: any[]) => void,\n  notifyAll?: (...args: any[]) => void,\n  lastNotify?: any,\n  listeners?: Array<(...args: any[]) => void>,\n  addNotifyListener?: (callback: (...args: any[]) => void) => void,\n\n  isFulfilled?: boolean,\n  isRejected?: boolean\n}\n\nexport function deferredPromise<T>() {\n  let deferredHelper: any = {\n    isFulfilled: false, \n    isRejected: false,\n\n    notify: () => {}, \n    notifyAll: (...args: any[]) => {\n      deferredHelper.lastNotify = args;\n      deferredHelper.listeners.forEach((callback: any) => callback(...args));\n    }, \n\n    lastNotify: undefined,\n    listeners: [],\n    addNotifyListener: (callback: (...args: any[]) => void) => {\n      if(deferredHelper.lastNotify) {\n        callback(...deferredHelper.lastNotify);\n      }\n\n      deferredHelper.listeners.push(callback);\n    }\n  };\n\n  let deferred: CancellablePromise<T> = new Promise<T>((resolve, reject) => {\n    deferredHelper.resolve = (value: T) => {\n      if(deferred.isFulfilled) return;\n\n      deferred.isFulfilled = true;\n      resolve(value);\n    };\n    \n    deferredHelper.reject = (...args: any[]) => {\n      if(deferred.isRejected) return;\n      \n      deferred.isRejected = true;\n      reject(...args);\n    };\n  });\n\n  // @ts-ignore\n  /* deferred.then = (resolve: (value: T) => any, reject: (...args: any[]) => any) => {\n    const n = deferredPromise<ReturnType<typeof resolve>>();\n    \n  }; */\n\n  deferred.finally(() => {\n    deferred.notify = null;\n    deferred.listeners.length = 0;\n    deferred.lastNotify = null;\n\n    if(deferred.cancel) {\n      deferred.cancel = () => {};\n    }\n  });\n\n  Object.assign(deferred, deferredHelper);\n\n  return deferred;\n}","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n                  \n                                   \n          \n//import CacheStorageController from '../cacheStorage';\nimport type { WorkerTaskTemplate, WorkerTaskVoidTemplate } from '../../types';\nimport type { InputFileLocation, UploadFile } from '../../layer';\nimport type { WebPushApiManager } from '../mtproto/webPushApiManager';\nimport { logger, LogTypes } from '../logger';\nimport { CancellablePromise } from '../../helpers/cancellablePromise';\nimport './push';\nimport { CACHE_ASSETS_NAME, requestCache } from './cache';\nimport onStreamFetch from './stream';\nimport { closeAllNotifications, onPing, PushNotificationObject } from './push';\n\nexport const log = logger('SW', LogTypes.Error | LogTypes.Debug | LogTypes.Log | LogTypes.Warn);\nconst ctx = self as any as ServiceWorkerGlobalScope;\nexport const deferredPromises: {[taskId: number]: CancellablePromise<any>} = {};\n\nexport interface RequestFilePartTask extends WorkerTaskTemplate {\n  type: 'requestFilePart',\n  payload: [number, InputFileLocation, number, number]\n};\n\nexport interface RequestFilePartTaskResponse extends WorkerTaskTemplate {\n  type: 'requestFilePart',\n  payload?: UploadFile.uploadFile,\n  originalPayload?: RequestFilePartTask['payload']\n};\n\nexport interface ServiceWorkerPingTask extends WorkerTaskVoidTemplate {\n  type: 'ping',\n  payload: {\n    localNotifications: boolean,\n    lang: {\n      push_action_mute1d: string\n      push_action_settings: string\n      push_message_nopreview: string\n    },\n    settings: WebPushApiManager['settings']\n  }\n};\n\nexport interface ServiceWorkerNotificationsClearTask extends WorkerTaskVoidTemplate {\n  type: 'notifications_clear'\n};\n\nexport interface ServiceWorkerPushClickTask extends WorkerTaskVoidTemplate {\n  type: 'push_click',\n  payload: PushNotificationObject\n};\n\nexport type ServiceWorkerTask = RequestFilePartTaskResponse | ServiceWorkerPingTask | ServiceWorkerNotificationsClearTask;\n\n                   \nconst taskListeners: {\n  [type in ServiceWorkerTask['type']]: (task: any, event: ExtendableMessageEvent) => void\n} = {\n  notifications_clear: () => {\n    closeAllNotifications();\n  },\n  ping: (task: ServiceWorkerPingTask, event) => {\n    onPing(task, event);\n  },\n  requestFilePart: (task: RequestFilePartTaskResponse) => {\n    const promise = deferredPromises[task.id];\n\n    if(task.error) {\n      promise.reject(task.error);\n    } else {\n      promise.resolve(task.payload);\n    }\n\n    delete deferredPromises[task.id];\n  }\n};\nctx.addEventListener('message', (e) => {\n  const task = e.data as ServiceWorkerTask;\n  const callback = taskListeners[task.type];\n  if(callback) {\n    callback(task, e);\n  }\n});\n          \n\n//const cacheStorage = new CacheStorageController('cachedAssets');\nlet taskId = 0;\n\nexport function getTaskId() {\n  return taskId;\n}\n\nexport function incrementTaskId() {\n  return taskId++;\n}\n\nconst onFetch = (event: FetchEvent): void => {\n  if(event.request.url.indexOf(location.origin + '/') === 0 && event.request.url.match(/\\.(js|css|jpe?g|json|wasm|png|mp3|svg|tgs|ico|woff2?|ttf|webmanifest?)(?:\\?.*)?$/)) {\n    return event.respondWith(requestCache(event));\n  }\n\n  try {\n    const [, url, scope, params] = /http[:s]+\\/\\/.*?(\\/(.*?)(?:$|\\/(.*)$))/.exec(event.request.url) || [];\n\n    //log.debug('[fetch]:', event);\n  \n    switch(scope) {\n      case 'stream': {\n        onStreamFetch(event, params);\n        break;\n      }\n    }\n  } catch(err) {\n    event.respondWith(new Response('', {\n      status: 500,\n      statusText: 'Internal Server Error',\n    }));\n  }\n};\n\nconst onChangeState = () => {\n  ctx.onfetch = onFetch;\n};\n\nctx.addEventListener('install', (event) => {\n  log('installing');\n  event.waitUntil(ctx.skipWaiting()); // Activate worker immediately\n});\n\nctx.addEventListener('activate', (event) => {\n  log('activating', ctx);\n  event.waitUntil(ctx.caches.delete(CACHE_ASSETS_NAME));\n  event.waitUntil(ctx.clients.claim());\n});\n\nctx.onerror = (error) => {\n  log.error('error:', error);\n};\n\nctx.onunhandledrejection = (error) => {\n  log.error('onunhandledrejection:', error);\n};\n\nctx.onoffline = ctx.ononline = onChangeState;\n\nonChangeState();\n"],"sourceRoot":""}