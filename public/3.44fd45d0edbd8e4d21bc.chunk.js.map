{"version":3,"sources":["webpack:///./src/lib/searchIndex.ts","webpack:///./src/helpers/cleanSearchText.ts","webpack:///./src/lib/mtproto/mtproto_config.ts","webpack:///./src/helpers/dom/htmlToSpan.ts","webpack:///./src/helpers/cleanUsername.ts","webpack:///./src/lib/appManagers/appUsersManager.ts","webpack:///./src/lib/appManagers/appChatsManager.ts","webpack:///./src/lib/appManagers/appPeersManager.ts","webpack:///./src/helpers/array.ts","webpack:///./src/lib/appManagers/apiUpdatesManager.ts","webpack:///./src/helpers/assumeType.ts"],"names":["SearchIndex","options","minChars","fullTexts","Map","id","searchText","this","trim","delete","set","query","newFoundObjs","queryWords","split","queryWordsLength","length","forEach","fullText","what","found","foundChars","i","word","idx","indexOf","fullTextLength","push","sort","a","b","Set","map","o","badCharsRe","trimRe","clearBadCharsAndTrim","text","replace","latinizeString","ch","latinizeCh","LatinizeMap","undefined","cleanSearchText","latinize","hasTag","charAt","toLowerCase","processSearchText","includeTag","clearBadChars","ignoreCase","REPLIES_PEER_ID","htmlToSpan","html","span","document","createElement","innerHTML","cleanUsername","username","appUsersManager","storage","appStateManager","storages","users","updateUsersStatuses","timestampNow","user","status","_","expires","was_online","rootScope","dispatchEvent","setUserToStateIfNeeded","clear","setInterval","addEventListener","addMultipleEventsListeners","updateUserStatus","update","userId","user_id","serverTimeManager","serverTimeOffset","updateUserPhoto","forceUserOnline","photo","console","warn","updateUserName","saveApiUser","Object","assign","first_name","last_name","e","getSelf","contactsIndex","indexObject","getUserSearchText","getState","then","state","storagesResults","contactsList","Array","isArray","pushContact","contactsFillPromise","resolve","peerId","getFromCache","getUser","init","usernames","_userId","isPeerNeeded","findAndSplice","getTopPeersPromises","createSearchIndex","updatedContactsList","pushToState","cached","isFulfilled","promise","invokeApi","result","saveApiUsers","contacts","contact","onContactsModified","slice","Promise","resolvedPeer","appChatsManager","saveApiChats","chats","appPeersManager","getPeer","getPeerId","peer","add","requestPeer","phone","pFlags","self","format","filter","Boolean","join","includeSaved","sortBy","fillContacts","_contactsList","results","search","has","userId1","userId2","sortName1","sortName","sortName2","localeCompare","status1","getUserStatusForSort","p","myId","testSelfSearch","unshift","block","invokeApiSingle","getInputPeerById","value","apiUpdatesManager","processLocalUpdate","peer_id","getOutputPeer","blocked","index","apiUsers","override","oldUser","min","fullName","searchUsername","deleted","initials","getAbbreviation","changedPhoto","changedTitle","photo_id","formatPhoneNumber","formatted","access_hash","key","args","isBot","support","date","now","Date","d","getDate","getMonth","getHours","getMinutes","bot","isRegularUser","isContact","allowMin","eventTimestamp","timestamp","updatesState","syncLoading","type","topPeersCache","cachedTime","peers","offset","limit","hash","topPeers","categories","topPeer","rating","contactsBlocked","count","peerIds","u","concat","c","invokeApiCacheable","q","cacheSeconds","my_results","offline","showPhone","getUserInput","add_phone_privacy_exception","updates","processUpdateMessage","onContactUpdated","userIds","onChatUpdated","chatId","isChannel","updateChannelParticipant","clearCache","params","channel","channel_id","updateChatDefaultBannedRights","chat","default_banned_rights","getChat","_chatId","apiChats","saveApiChat","oldChat","title","participants_count","rights","defaultRights","action","isThread","kicked","left","megagroup","deactivated","creator","admin_rights","banned_rights","myFlags","post_messages","delete_messages","broadcast","until_date","bind","isMegagroup","good","chat_id","about","channelId","input","getChannelInput","usersInputs","fwdLimit","fwd_limit","deleteChatUser","leaveChannel","leaveChat","deleteChannel","deleteChat","find","bool","inputFile","inputChatPhoto","file","participant","getParticipantPeerId","actor_id","qts","prev_participant","new_participant","keys","kicked_by","editBanned","view_messages","messagesChats","DialogColorsFg","DialogColors","DialogColorsMap","updatePeerBlocked","hasRights","getUserPhoto","getChatPhoto","migrated_to","plainText","onlyFirstName","wrapEmojiText","getUserString","getChatString","isUser","peerParams","substr","isBroadcast","ignorePeerId","getChannelInputPeer","getChatInputPeer","pic","getDialogType","accumulate","arr","initialValue","reduce","acc","findAndSpliceAll","array","verify","out","findIndex","splice","forEachReverse","callback","insertInDescendSortedArray","element","property","pos","sortProperty","len","error","filterUnique","pendingPtsUpdates","pendingSeqUpdates","syncPending","channelStates","attached","log","Error","Warn","Log","debug","updateMessage","processOpts","seq","seqStart","seq_start","forceGetDifference","processUpdate","isOut","fromId","from_id","toId","message","fwd_from","reply_to","entities","pts","pts_count","Proxy","target","saveUpdatesState","us","nextSeq","pendingUpdatesData","saveUpdate","popPendingSeqUpdate","seqAwaiting","ptsAwaiting","clearTimeout","timeout","curState","getChannelState","curPts","goodPts","goodIndex","getDifference","first","wasSyncing","pts_total_limit","differenceResult","other_updates","new_messages","apiMessage","nextState","intermediate_state","justAName","channelState","getChannelDifference","addChannelState","lastPtsUpdateTime","toPeerId","fwdHeader","reason","hasUser","post","hasChat","popPts","popSeq","window","setTimeout","popPendingPtsUpdate","_state","noErrorBox","stateResult","setUpdatesProcessor","setProxy","assumeType","x"],"mappings":"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","file":"3.44fd45d0edbd8e4d21bc.chunk.js","sourcesContent":["/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport { processSearchText, ProcessSearchTextOptions } from '../helpers/cleanSearchText';\r\n\r\nexport default class SearchIndex<SearchWhat> {\r\n  private fullTexts: Map<SearchWhat, string> = new Map();\r\n\r\n  // minChars can be 0 because it requires at least one word (one symbol) to be found\r\n  constructor(private options?: ProcessSearchTextOptions, private minChars = 0) {\r\n  }\r\n\r\n  public indexObject(id: SearchWhat, searchText: string) {\r\n    /* if(searchIndex.fullTexts.hasOwnProperty(id)) {\r\n      return false;\r\n    } */\r\n\r\n    if(this.options && searchText.trim()) {\r\n      searchText = processSearchText(searchText, this.options);\r\n    }\r\n\r\n    if(!searchText) {\r\n      this.fullTexts.delete(id);\r\n      return false;\r\n    }\r\n\r\n    this.fullTexts.set(id, searchText);\r\n    \r\n    /* const shortIndexes = searchIndex.shortIndexes;\r\n    searchText.split(' ').forEach((searchWord) => {\r\n      let len = Math.min(searchWord.length, 3),\r\n        wordPart, i;\r\n      for(i = 1; i <= len; i++) {\r\n        wordPart = searchWord.substr(0, i);\r\n        if(shortIndexes[wordPart] === undefined) {\r\n          shortIndexes[wordPart] = [id];\r\n        } else {\r\n          shortIndexes[wordPart].push(id);\r\n        }\r\n      }\r\n    }); */\r\n  }\r\n\r\n  public search(query: string) {\r\n    const fullTexts = this.fullTexts;\r\n    //const shortIndexes = searchIndex.shortIndexes;\r\n\r\n    if(this.options) {\r\n      query = processSearchText(query, this.options);\r\n    }\r\n\r\n    const newFoundObjs: Array<{fullText: string, fullTextLength: number, what: SearchWhat, foundChars: number}> = [];\r\n    const queryWords = query.split(' ');\r\n    const queryWordsLength = queryWords.length;\r\n    fullTexts.forEach((fullText, what) => {\r\n      let found = true;\r\n      let foundChars = 0;\r\n      for(let i = 0; i < queryWordsLength; ++i) { // * verify that all words are found\r\n        const word = queryWords[i];\r\n        const idx = fullText.indexOf(word);\r\n        if(idx === -1 || (idx !== 0 && fullText[idx - 1] !== ' ')) { // * search only from word beginning\r\n          found = false;\r\n          break;\r\n        }\r\n\r\n        foundChars += word.length;\r\n      }\r\n\r\n      if(found) {\r\n        foundChars += queryWordsLength - 1;\r\n        const fullTextLength = fullText.length;\r\n        if(this.minChars <= foundChars || fullTextLength <= foundChars) {\r\n          newFoundObjs.push({fullText, fullTextLength, what, foundChars});\r\n        }\r\n      }\r\n    });\r\n\r\n    newFoundObjs.sort((a, b) => a.fullTextLength - b.fullTextLength || b.foundChars - a.foundChars);\r\n\r\n    //newFoundObjs.sort((a, b) => a.fullText.localeCompare(b.fullText));\r\n    const newFoundObjs2: Set<SearchWhat> = new Set(newFoundObjs.map(o => o.what));\r\n\r\n    /* const queryWords = query.split(' ');\r\n    let foundArr: number[];\r\n    for(let i = 0; i < queryWords.length; i++) {\r\n      const newFound = shortIndexes[queryWords[i].substr(0, 3)];\r\n      if(!newFound) {\r\n        foundArr = [];\r\n        break;\r\n      }\r\n      \r\n      if(foundArr === undefined || foundArr.length > newFound.length) {\r\n        foundArr = newFound;\r\n      }\r\n    }\r\n\r\n    for(let j = 0; j < foundArr.length; j++) {\r\n      let found = true;\r\n      let searchText = fullTexts[foundArr[j]];\r\n      for(let i = 0; i < queryWords.length; i++) {\r\n        if(searchText.indexOf(queryWords[i]) === -1) {\r\n          found = false;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if(found) {\r\n        newFoundObjs[foundArr[j]] = true;\r\n      }\r\n    } */\r\n\r\n    return newFoundObjs2;\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport Config from \"../lib/config\";\r\n\r\nconst badCharsRe = /[`~!@#$%^&*()\\-_=+\\[\\]\\\\|{}'\";:\\/?.>,<]+/g;\r\nconst trimRe = /^\\s+|\\s$/g;\r\n\r\nexport function clearBadCharsAndTrim(text: string) {\r\n  return text.replace(badCharsRe, '').replace(trimRe, '');\r\n}\r\n\r\nexport function latinizeString(text: string) {\r\n  return text.replace(/[^A-Za-z0-9]/g, (ch) => {\r\n    const latinizeCh = Config.LatinizeMap[ch];\r\n    return latinizeCh !== undefined ? latinizeCh : ch;\r\n  });\r\n}\r\n\r\nexport default function cleanSearchText(text: string, latinize = true) {\r\n  const hasTag = text.charAt(0) === '%';\r\n  text = clearBadCharsAndTrim(text);\r\n  if(latinize) text = latinizeString(text);\r\n  \r\n  text = text.toLowerCase();\r\n  if(hasTag) text = '%' + text;\r\n\r\n  return text;\r\n}\r\n\r\nexport type ProcessSearchTextOptions = Partial<{\r\n  clearBadChars: boolean,\r\n  latinize: boolean,\r\n  ignoreCase: boolean,\r\n  includeTag: boolean\r\n}>;\r\n\r\nexport function processSearchText(text: string, options: ProcessSearchTextOptions = {}) {\r\n  const hasTag = options.includeTag && text.charAt(0) === '%';\r\n  if(options.clearBadChars) text = clearBadCharsAndTrim(text);\r\n  if(options.latinize) text = latinizeString(text);\r\n  if(options.ignoreCase) text = text.toLowerCase();\r\n  if(hasTag) text = '%' + text;\r\n  return text;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n/**\r\n * Legacy Webogram's format, don't change dcID to camelCase. date is timestamp\r\n */\r\nexport type UserAuth = {dcID: number | string, date: number, id: number};\r\n\r\nexport const REPLIES_PEER_ID = 1271266957;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nexport default function htmlToSpan(html: string) {\r\n  const span = document.createElement('span');\r\n  span.innerHTML = html;\r\n  return span;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nexport default function cleanUsername(username: string) {\r\n  return username && username.toLowerCase() || '';\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport { filterUnique } from \"../../helpers/array\";\r\nimport { CancellablePromise, deferredPromise } from \"../../helpers/cancellablePromise\";\r\nimport cleanSearchText from \"../../helpers/cleanSearchText\";\r\nimport cleanUsername from \"../../helpers/cleanUsername\";\r\nimport { tsNow } from \"../../helpers/date\";\r\nimport { formatPhoneNumber } from \"../../helpers/formatPhoneNumber\";\r\nimport { safeReplaceObject, isObject } from \"../../helpers/object\";\r\nimport { Chat, InputUser, User as MTUser, UserProfilePhoto, UserStatus } from \"../../layer\";\r\nimport I18n, { i18n, LangPackKey } from \"../langPack\";\r\n//import apiManager from '../mtproto/apiManager';\r\nimport apiManager from '../mtproto/mtprotoworker';\r\nimport { REPLIES_PEER_ID } from \"../mtproto/mtproto_config\";\r\nimport serverTimeManager from \"../mtproto/serverTimeManager\";\r\nimport { RichTextProcessor } from \"../richtextprocessor\";\r\nimport rootScope from \"../rootScope\";\r\nimport SearchIndex from \"../searchIndex\";\r\nimport apiUpdatesManager from \"./apiUpdatesManager\";\r\nimport appChatsManager from \"./appChatsManager\";\r\nimport appPeersManager from \"./appPeersManager\";\r\nimport appStateManager from \"./appStateManager\";\r\n\r\n// TODO: updateUserBlocked\r\n\r\nexport type User = MTUser.user;\r\nexport type TopPeerType = 'correspondents' | 'bots_inline';\r\nexport type MyTopPeer = {id: number, rating: number};\r\n\r\nexport class AppUsersManager {\r\n  private storage = appStateManager.storages.users;\r\n  \r\n  private users: {[userId: number]: User};\r\n  private usernames: {[username: string]: number};\r\n  private contactsIndex: SearchIndex<number>;\r\n  private contactsFillPromise: CancellablePromise<Set<number>>;\r\n  private contactsList: Set<number>;\r\n  private updatedContactsList: boolean;\r\n  \r\n  private getTopPeersPromises: {[type in TopPeerType]?: Promise<MyTopPeer[]>};\r\n\r\n  constructor() {\r\n    this.clear(true);\r\n\r\n    setInterval(this.updateUsersStatuses, 60000);\r\n\r\n    rootScope.addEventListener('state_synchronized', this.updateUsersStatuses);\r\n\r\n    rootScope.addMultipleEventsListeners({\r\n      updateUserStatus: (update) => {\r\n        const userId = update.user_id;\r\n        const user = this.users[userId];\r\n        if(user) {\r\n          user.status = update.status;\r\n          if(user.status) {\r\n            if('expires' in user.status) {\r\n              user.status.expires -= serverTimeManager.serverTimeOffset;\r\n            }\r\n\r\n            if('was_online' in user.status) {\r\n              user.status.was_online -= serverTimeManager.serverTimeOffset;\r\n            }\r\n          }\r\n\r\n          //user.sortStatus = this.getUserStatusForSort(user.status);\r\n          rootScope.dispatchEvent('user_update', userId);\r\n          this.setUserToStateIfNeeded(user);\r\n        } //////else console.warn('No user by id:', userId);\r\n      },\r\n\r\n      updateUserPhoto: (update) => {\r\n        const userId = update.user_id;\r\n        const user = this.users[userId];\r\n        if(user) {\r\n          this.forceUserOnline(userId);\r\n\r\n          if(update.photo._ === 'userProfilePhotoEmpty') {\r\n            delete user.photo;\r\n          } else {\r\n            user.photo = safeReplaceObject(user.photo, update.photo);\r\n          }\r\n\r\n          this.setUserToStateIfNeeded(user);\r\n\r\n          rootScope.dispatchEvent('user_update', userId);\r\n          rootScope.dispatchEvent('avatar_update', userId);\r\n        } else console.warn('No user by id:', userId);\r\n      },\r\n\r\n      updateUserName: (update) => {\r\n        const userId = update.user_id;\r\n        const user = this.users[userId];\r\n        if(user) {\r\n          this.forceUserOnline(userId);\r\n          \r\n          this.saveApiUser(Object.assign({}, user, {\r\n            first_name: update.first_name,\r\n            last_name: update.last_name,\r\n            username: update.username\r\n          }), true);\r\n        }\r\n      }\r\n    });\r\n\r\n    /* case 'updateContactLink':\r\n    this.onContactUpdated(update.user_id, update.my_link._ === 'contactLinkContact');\r\n    break; */\r\n\r\n    rootScope.addEventListener('language_change', (e) => {\r\n      const userId = this.getSelf().id;\r\n      this.contactsIndex.indexObject(userId, this.getUserSearchText(userId));\r\n    });\r\n\r\n    appStateManager.getState().then((state) => {\r\n      const users = appStateManager.storagesResults.users;\r\n      if(users.length) {\r\n        for(let i = 0, length = users.length; i < length; ++i) {\r\n          const user = users[i];\r\n          if(user) {\r\n            this.users[user.id] = user;\r\n          }\r\n        }\r\n      }\r\n\r\n      const contactsList = state.contactsList;\r\n      if(contactsList && Array.isArray(contactsList)) {\r\n        contactsList.forEach(userId => {\r\n          this.pushContact(userId);\r\n        });\r\n\r\n        if(contactsList.length) {\r\n          this.contactsFillPromise = deferredPromise();\r\n          this.contactsFillPromise.resolve(this.contactsList);\r\n        }\r\n      }\r\n\r\n      appStateManager.addEventListener('peerNeeded', (peerId: number) => {\r\n        if(peerId < 0 || this.storage.getFromCache(peerId)) {\r\n          return;\r\n        }\r\n\r\n        this.storage.set({\r\n          [peerId]: this.getUser(peerId)\r\n        });\r\n      });\r\n\r\n      appStateManager.addEventListener('peerUnneeded', (peerId: number) => {\r\n        if(peerId < 0 || !this.storage.getFromCache(peerId)) {\r\n          return;\r\n        }\r\n\r\n        this.storage.delete(peerId);\r\n      });\r\n    });\r\n  }\r\n\r\n  public clear(init = false) {\r\n    if(!init) {\r\n      const users = appStateManager.storagesResults.users;\r\n      for(const _userId in this.users) {\r\n        const userId = +_userId;\r\n        if(!userId) continue;\r\n        if(!appStateManager.isPeerNeeded(userId)) {\r\n          const user = this.users[userId];\r\n          if(user.username) {\r\n            delete this.usernames[cleanUsername(user.username)];\r\n          }\r\n\r\n          users.findAndSplice((user) => user.id === userId);\r\n          this.storage.delete(userId);\r\n          delete this.users[userId];\r\n        }\r\n      }\r\n    } else {\r\n      this.users = {};\r\n      this.usernames = {};\r\n    }\r\n    \r\n    this.getTopPeersPromises = {};\r\n    this.contactsIndex = this.createSearchIndex();\r\n    this.contactsFillPromise = undefined;\r\n    this.contactsList = new Set();\r\n    this.updatedContactsList = false;\r\n  }\r\n\r\n  private onContactsModified() {\r\n    const contactsList = [...this.contactsList];\r\n    appStateManager.pushToState('contactsList', contactsList);\r\n  }\r\n\r\n  public fillContacts() {\r\n    if(this.contactsFillPromise && this.updatedContactsList) {\r\n      return {\r\n        cached: this.contactsFillPromise.isFulfilled,\r\n        promise: this.contactsFillPromise\r\n      };\r\n    }\r\n\r\n    this.updatedContactsList = true;\r\n\r\n    const promise = deferredPromise<Set<number>>();\r\n    apiManager.invokeApi('contacts.getContacts').then((result) => {\r\n      if(result._ === 'contacts.contacts') {\r\n        this.contactsList.clear();\r\n      \r\n        this.saveApiUsers(result.users);\r\n\r\n        result.contacts.forEach((contact) => {\r\n          this.pushContact(contact.user_id);\r\n        });\r\n\r\n        this.onContactsModified();\r\n\r\n        this.contactsFillPromise = promise;\r\n      }\r\n\r\n      promise.resolve(this.contactsList);\r\n    }, () => {\r\n      this.updatedContactsList = false;\r\n    });\r\n\r\n    return {\r\n      cached: this.contactsFillPromise?.isFulfilled,\r\n      promise: this.contactsFillPromise || (this.contactsFillPromise = promise)\r\n    };\r\n  }\r\n\r\n  public resolveUsername(username: string): Promise<Chat | User> {\r\n    if(username[0] === '@') {\r\n      username = username.slice(1);\r\n    }\r\n\r\n    username = username.toLowerCase();\r\n    if(this.usernames[username]) {\r\n      return Promise.resolve(this.users[this.usernames[username]]);\r\n    }\r\n\r\n    return apiManager.invokeApi('contacts.resolveUsername', {username}).then(resolvedPeer => {\r\n      this.saveApiUsers(resolvedPeer.users);\r\n      appChatsManager.saveApiChats(resolvedPeer.chats);\r\n\r\n      return appPeersManager.getPeer(appPeersManager.getPeerId(resolvedPeer.peer));\r\n    });\r\n  }\r\n\r\n  public pushContact(userId: number) {\r\n    this.contactsList.add(userId);\r\n    this.contactsIndex.indexObject(userId, this.getUserSearchText(userId));\r\n    appStateManager.requestPeer(userId, 'contacts');\r\n  }\r\n\r\n  public getUserSearchText(id: number) {\r\n    const user = this.users[id];\r\n    if(!user) {\r\n      return '';\r\n    }\r\n\r\n    const arr: string[] = [\r\n      user.first_name,\r\n      user.last_name,\r\n      user.phone,\r\n      user.username,\r\n      user.pFlags.self ? I18n.format('SavedMessages', true) : '',\r\n      user.pFlags.self ? 'Saved Messages' : ''\r\n    ];\r\n\r\n    return arr.filter(Boolean).join(' ');\r\n  }\r\n\r\n  public getContacts(query?: string, includeSaved = false, sortBy: 'name' | 'online' | 'none' = 'name') {\r\n    return this.fillContacts().promise.then(_contactsList => {\r\n      let contactsList = [..._contactsList];\r\n      if(query) {\r\n        const results = this.contactsIndex.search(query);\r\n        const filteredContactsList = [...contactsList].filter(id => results.has(id));\r\n\r\n        contactsList = filteredContactsList;\r\n      }\r\n\r\n      if(sortBy === 'name') {\r\n        contactsList.sort((userId1, userId2) => {\r\n          const sortName1 = (this.users[userId1] || {}).sortName || '';\r\n          const sortName2 = (this.users[userId2] || {}).sortName || '';\r\n          return sortName1.localeCompare(sortName2);\r\n        });\r\n      } else if(sortBy === 'online') {\r\n        contactsList.sort((userId1, userId2) => {\r\n          const status1 = appUsersManager.getUserStatusForSort(appUsersManager.getUser(userId1).status);\r\n          const status2 = appUsersManager.getUserStatusForSort(appUsersManager.getUser(userId2).status);\r\n          return status2 - status1;\r\n        });\r\n      }\r\n\r\n      contactsList.findAndSplice(p => p === rootScope.myId);\r\n      if(includeSaved) {\r\n        if(this.testSelfSearch(query)) {\r\n          contactsList.unshift(rootScope.myId);\r\n        }\r\n      }\r\n\r\n      return contactsList;\r\n    });\r\n  }\r\n\r\n  public toggleBlock(peerId: number, block: boolean) {\r\n    return apiManager.invokeApiSingle(block ? 'contacts.block' : 'contacts.unblock', {\r\n      id: appPeersManager.getInputPeerById(peerId)\r\n    }).then(value => {\r\n      if(value) {\r\n        apiUpdatesManager.processLocalUpdate({\r\n          _: 'updatePeerBlocked',\r\n          peer_id: appPeersManager.getOutputPeer(peerId),\r\n          blocked: block\r\n        });\r\n      }\r\n\r\n      return value;\r\n    });\r\n  }\r\n\r\n  public testSelfSearch(query: string) {\r\n    const user = this.getSelf();\r\n    const index = this.createSearchIndex();\r\n    index.indexObject(user.id, this.getUserSearchText(user.id));\r\n    return index.search(query).has(user.id);\r\n  }\r\n\r\n  private createSearchIndex() {\r\n    return new SearchIndex<number>({\r\n      clearBadChars: true,\r\n      ignoreCase: true,\r\n      latinize: true,\r\n      includeTag: true\r\n    });\r\n  }\r\n\r\n  public saveApiUsers(apiUsers: any[], override?: boolean) {\r\n    apiUsers.forEach((user) => this.saveApiUser(user, override));\r\n  }\r\n\r\n  public saveApiUser(user: MTUser, override?: boolean) {\r\n    if(user._ === 'userEmpty') return;\r\n\r\n    const userId = user.id;\r\n    const oldUser = this.users[userId];\r\n\r\n    // ! commented block can affect performance !\r\n    // if(oldUser && !override) {\r\n    //   console.log('saveApiUser same');\r\n    //   return;\r\n    // }\r\n\r\n    if(user.pFlags === undefined) {\r\n      user.pFlags = {};\r\n    }\r\n\r\n    if(user.pFlags.min && oldUser !== undefined) {\r\n      return;\r\n    }\r\n\r\n    // * exclude from state\r\n    // defineNotNumerableProperties(user, ['initials', 'num', 'rFirstName', 'rFullName', 'rPhone', 'sortName', 'sortStatus']);\r\n\r\n    const fullName = user.first_name + ' ' + (user.last_name || '');\r\n    if(user.username) {\r\n      const searchUsername = cleanUsername(user.username);\r\n      this.usernames[searchUsername] = userId;\r\n    }\r\n\r\n    user.sortName = user.pFlags.deleted ? '' : cleanSearchText(fullName, false);\r\n\r\n    user.initials = RichTextProcessor.getAbbreviation(fullName);\r\n\r\n    if(user.status) {\r\n      if((user.status as UserStatus.userStatusOnline).expires) {\r\n        (user.status as UserStatus.userStatusOnline).expires -= serverTimeManager.serverTimeOffset;\r\n      }\r\n\r\n      if((user.status as UserStatus.userStatusOffline).was_online) {\r\n        (user.status as UserStatus.userStatusOffline).was_online -= serverTimeManager.serverTimeOffset;\r\n      }\r\n    }\r\n\r\n    //user.sortStatus = user.pFlags.bot ? -1 : this.getUserStatusForSort(user.status);\r\n\r\n    let changedPhoto = false, changedTitle = false;\r\n    if(oldUser === undefined) {\r\n      this.users[userId] = user;\r\n    } else {\r\n      if(user.first_name !== oldUser.first_name \r\n        || user.last_name !== oldUser.last_name \r\n        || user.username !== oldUser.username) {\r\n        changedTitle = true;\r\n      }\r\n\r\n      const oldPhotoId = (oldUser.photo as UserProfilePhoto.userProfilePhoto)?.photo_id;\r\n      const newPhotoId = (user.photo as UserProfilePhoto.userProfilePhoto)?.photo_id;\r\n      if(oldPhotoId !== newPhotoId) {\r\n        changedPhoto = true;\r\n      }\r\n\r\n      /* if(user.pFlags.bot && user.bot_info_version !== oldUser.bot_info_version) {\r\n        \r\n      } */\r\n\r\n      safeReplaceObject(oldUser, user);\r\n      rootScope.dispatchEvent('user_update', userId);\r\n    }\r\n\r\n    if(changedPhoto) {\r\n      rootScope.dispatchEvent('avatar_update', user.id);\r\n    }\r\n\r\n    if(changedTitle) {\r\n      rootScope.dispatchEvent('peer_title_edit', user.id);\r\n    }\r\n\r\n    this.setUserToStateIfNeeded(user);\r\n  }\r\n\r\n  public setUserToStateIfNeeded(user: User) {\r\n    if(appStateManager.isPeerNeeded(user.id)) {\r\n      this.storage.set({\r\n        [user.id]: user\r\n      });\r\n    }\r\n  }\r\n\r\n  public formatUserPhone(phone: string) {\r\n    return '+' + formatPhoneNumber(phone).formatted;\r\n  }\r\n\r\n  public isUserOnlineVisible(id: number) {\r\n    return this.getUserStatusForSort(id) > 3;\r\n  }\r\n\r\n  public getUserStatusForSort(status: User['status'] | number) {\r\n    if(typeof(status) === 'number') {\r\n      status = this.getUser(status).status;\r\n    }\r\n\r\n    if(status) {\r\n      const expires = status._ === 'userStatusOnline' ? status.expires : (status._ === 'userStatusOffline' ? status.was_online : 0);\r\n      if(expires) {\r\n        return expires;\r\n      }\r\n\r\n      /* const timeNow = tsNow(true);\r\n      switch(status._) {\r\n        case 'userStatusRecently':\r\n          return timeNow - 86400 * 3;\r\n        case 'userStatusLastWeek':\r\n          return timeNow - 86400 * 7;\r\n        case 'userStatusLastMonth':\r\n          return timeNow - 86400 * 30;\r\n      } */\r\n      switch(status._) {\r\n        case 'userStatusRecently':\r\n          return 3;\r\n        case 'userStatusLastWeek':\r\n          return 2;\r\n        case 'userStatusLastMonth':\r\n          return 1;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  public getUser(id: any): User {\r\n    if(isObject(id)) {\r\n      return id;\r\n    }\r\n\r\n    return this.users[id] || {id: id, pFlags: {deleted: true}, access_hash: ''} as User;\r\n  }\r\n\r\n  public getSelf() {\r\n    return this.getUser(rootScope.myId);\r\n  }\r\n\r\n  public getUserStatusString(userId: number): HTMLElement {\r\n    let key: LangPackKey;\r\n    let args: any[];\r\n\r\n    switch(userId) {\r\n      case REPLIES_PEER_ID:\r\n        key = 'Peer.RepliesNotifications';\r\n        break;\r\n      case 777000:\r\n        key = 'Peer.ServiceNotifications';\r\n        break;\r\n      default: {\r\n        if(this.isBot(userId)) {\r\n          key = 'Bot';\r\n          break;\r\n        }\r\n\r\n        const user = this.getUser(userId);\r\n        if(!user) {\r\n          key = '' as any;\r\n          break;\r\n        }\r\n\r\n        if(user.pFlags.support) {\r\n          key = 'SupportStatus';\r\n          break;\r\n        }\r\n\r\n        switch(user.status?._) {\r\n          case 'userStatusRecently': {\r\n            key = 'Lately';\r\n            break;\r\n          }\r\n    \r\n          case 'userStatusLastWeek': {\r\n            key = 'WithinAWeek';\r\n            break;\r\n          }\r\n    \r\n          case 'userStatusLastMonth': {\r\n            key = 'WithinAMonth';\r\n            break;\r\n          }\r\n          \r\n          case 'userStatusOffline': {\r\n            const date = user.status.was_online;\r\n            const now = Date.now() / 1000;\r\n            \r\n            if((now - date) < 60) {\r\n              key = 'Peer.Status.justNow';\r\n            } else if((now - date) < 3600) {\r\n              key = 'Peer.Status.minAgo';\r\n              const c = (now - date) / 60 | 0;\r\n              args = [c];\r\n            } else if(now - date < 86400) {\r\n              key = 'LastSeen.HoursAgo';\r\n              const c = (now - date) / 3600 | 0;\r\n              args = [c];\r\n            } else {\r\n              key = 'Peer.Status.LastSeenAt';\r\n              const d = new Date(date * 1000);\r\n              args = [('0' + d.getDate()).slice(-2) + '.' + ('0' + (d.getMonth() + 1)).slice(-2), \r\n                ('0' + d.getHours()).slice(-2) + ':' + ('0' + d.getMinutes()).slice(-2)];\r\n            }\r\n            \r\n            break;\r\n          }\r\n    \r\n          case 'userStatusOnline': {\r\n            key = 'Online';\r\n            break;\r\n          }\r\n    \r\n          default: {\r\n            key = 'ALongTimeAgo';\r\n            break;\r\n          }\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n    \r\n    return i18n(key, args);\r\n  }\r\n\r\n  public isBot(id: number) {\r\n    return this.users[id] && this.users[id].pFlags.bot;\r\n  }\r\n\r\n  public isContact(id: number) {\r\n    return this.contactsList.has(id) || (this.users[id] && this.users[id].pFlags.contact);\r\n  }\r\n  \r\n  public isRegularUser(id: number) {\r\n    const user = this.users[id];\r\n    return user && !this.isBot(id) && !user.pFlags.deleted && !user.pFlags.support;\r\n  }\r\n\r\n  public isNonContactUser(id: number) {\r\n    return this.isRegularUser(id) && !this.isContact(id) && id !== rootScope.myId;\r\n  }\r\n\r\n  public hasUser(id: number, allowMin?: boolean) {\r\n    const user = this.users[id];\r\n    return isObject(user) && (allowMin || !user.pFlags.min);\r\n  }\r\n\r\n  public canSendToUser(id: number) {\r\n    const user = this.getUser(id);\r\n    return !user.pFlags.deleted && user.username !== 'replies';\r\n  }\r\n\r\n  public getUserPhoto(id: number) {\r\n    const user = this.getUser(id);\r\n\r\n    return user && user.photo || {\r\n      _: 'userProfilePhotoEmpty'\r\n    };\r\n  }\r\n\r\n  public getUserString(id: number) {\r\n    const user = this.getUser(id);\r\n    return 'u' + id + (user.access_hash ? '_' + user.access_hash : '');\r\n  }\r\n\r\n  public getUserInput(id: number): InputUser {\r\n    const user = this.getUser(id);\r\n    if(user.pFlags && user.pFlags.self) {\r\n      return {_: 'inputUserSelf'};\r\n    }\r\n\r\n    return {\r\n      _: 'inputUser',\r\n      user_id: id,\r\n      access_hash: user.access_hash\r\n    };\r\n  }\r\n\r\n  public updateUsersStatuses = () => {\r\n    const timestampNow = tsNow(true);\r\n    for(const i in this.users) {\r\n      const user = this.users[i];\r\n\r\n      if(user.status &&\r\n        user.status._ === 'userStatusOnline' &&\r\n        user.status.expires < timestampNow) {\r\n\r\n        user.status = {_: 'userStatusOffline', was_online: user.status.expires};\r\n        rootScope.dispatchEvent('user_update', user.id);\r\n\r\n        this.setUserToStateIfNeeded(user);\r\n      }\r\n    }\r\n  };\r\n\r\n  public forceUserOnline(id: number, eventTimestamp?: number) {\r\n    if(this.isBot(id)) {\r\n      return;\r\n    }\r\n\r\n    const timestamp = tsNow(true);\r\n    const onlineTimeFor = 60;\r\n    if(eventTimestamp) {\r\n      if((timestamp - eventTimestamp) >= onlineTimeFor) {\r\n        return;\r\n      }\r\n    } else if(apiUpdatesManager.updatesState.syncLoading) {\r\n      return;\r\n    }\r\n\r\n    const user = this.getUser(id);\r\n    if(user &&\r\n      user.status &&\r\n      user.status._ !== 'userStatusOnline' &&\r\n      user.status._ !== 'userStatusEmpty' &&\r\n      !user.pFlags.support &&\r\n      !user.pFlags.deleted) {\r\n\r\n      user.status = {\r\n        _: 'userStatusOnline',\r\n        expires: timestamp + onlineTimeFor\r\n      };\r\n      \r\n      //user.sortStatus = this.getUserStatusForSort(user.status);\r\n      rootScope.dispatchEvent('user_update', id);\r\n\r\n      this.setUserToStateIfNeeded(user);\r\n    }\r\n  }\r\n\r\n  /* function importContact (phone, firstName, lastName) {\r\n      return MtpApiManager.invokeApi('contacts.importContacts', {\r\n        contacts: [{\r\n          _: 'inputPhoneContact',\r\n          client_id: '1',\r\n          phone: phone,\r\n          first_name: firstName,\r\n          last_name: lastName\r\n        }],\r\n        replace: false\r\n      }).then(function (importedContactsResult) {\r\n        saveApiUsers(importedContactsResult.users)\r\n\r\n        var foundUserID = false\r\n        angular.forEach(importedContactsResult.imported, function (importedContact) {\r\n          onContactUpdated(foundUserID = importedContact.user_id, true)\r\n        })\r\n\r\n        return foundUserID || false\r\n      })\r\n  }\r\n\r\n  function importContacts (contacts) {\r\n    var inputContacts = [],\r\n      i\r\n    var j\r\n\r\n    for (i = 0; i < contacts.length; i++) {\r\n      for (j = 0; j < contacts[i].phones.length; j++) {\r\n        inputContacts.push({\r\n          _: 'inputPhoneContact',\r\n          client_id: (i << 16 | j).toString(10),\r\n          phone: contacts[i].phones[j],\r\n          first_name: contacts[i].first_name,\r\n          last_name: contacts[i].last_name\r\n        })\r\n      }\r\n    }\r\n\r\n    return MtpApiManager.invokeApi('contacts.importContacts', {\r\n      contacts: inputContacts,\r\n      replace: false\r\n    }).then(function (importedContactsResult) {\r\n      saveApiUsers(importedContactsResult.users)\r\n\r\n      var result = []\r\n      angular.forEach(importedContactsResult.imported, function (importedContact) {\r\n        onContactUpdated(importedContact.user_id, true)\r\n        result.push(importedContact.user_id)\r\n      })\r\n\r\n      return result\r\n    })\r\n  } */\r\n\r\n  /* public deleteContacts(userIds: number[]) {\r\n    var ids: any[] = [];\r\n    userIds.forEach((userId) => {\r\n      ids.push(this.getUserInput(userId));\r\n    })\r\n\r\n    return apiManager.invokeApi('contacts.deleteContacts', {\r\n      id: ids\r\n    }).then(() => {\r\n      userIds.forEach((userId) => {\r\n        this.onContactUpdated(userId, false);\r\n      });\r\n    });\r\n  } */\r\n\r\n  public getTopPeers(type: TopPeerType) {\r\n    if(this.getTopPeersPromises[type]) return this.getTopPeersPromises[type];\r\n\r\n    return this.getTopPeersPromises[type] = appStateManager.getState().then((state) => {\r\n      const cached = state.topPeersCache[type];\r\n      if(cached && (cached.cachedTime + 86400e3) > Date.now() && cached.peers) {\r\n        return cached.peers;\r\n      }\r\n\r\n      return apiManager.invokeApi('contacts.getTopPeers', {\r\n        [type]: true,\r\n        offset: 0,\r\n        limit: 15,\r\n        hash: 0\r\n      }).then((result) => {\r\n        let topPeers: MyTopPeer[] = [];\r\n        if(result._ === 'contacts.topPeers') {\r\n          //console.log(result);\r\n          this.saveApiUsers(result.users);\r\n          appChatsManager.saveApiChats(result.chats);\r\n\r\n          if(result.categories.length) {\r\n            topPeers = result.categories[0].peers.map((topPeer) => {\r\n              const peerId = appPeersManager.getPeerId(topPeer.peer);\r\n              appStateManager.requestPeer(peerId, 'topPeer');\r\n              return {id: peerId, rating: topPeer.rating};\r\n            });\r\n          }\r\n        }\r\n  \r\n        state.topPeersCache[type] = {\r\n          peers: topPeers,\r\n          cachedTime: Date.now()\r\n        };\r\n        appStateManager.pushToState('topPeersCache', state.topPeersCache);\r\n  \r\n        return topPeers;\r\n      });\r\n    });\r\n  }\r\n\r\n  public getBlocked(offset = 0, limit = 0) {\r\n    return apiManager.invokeApiSingle('contacts.getBlocked', {offset, limit}).then(contactsBlocked => {\r\n      this.saveApiUsers(contactsBlocked.users);\r\n      appChatsManager.saveApiChats(contactsBlocked.chats);\r\n      const count = contactsBlocked._ === 'contacts.blocked' ? contactsBlocked.users.length + contactsBlocked.chats.length : contactsBlocked.count;\r\n\r\n      const peerIds = contactsBlocked.users.map(u => u.id).concat(contactsBlocked.chats.map(c => -c.id));\r\n\r\n      return {count, peerIds};\r\n    });\r\n  }\r\n\r\n  /* public searchContacts(query: string, limit = 20) {\r\n    return Promise.all([\r\n      this.getContacts(query),\r\n      apiManager.invokeApi('contacts.search', {\r\n        q: query,\r\n        limit\r\n      })\r\n    ]).then(results => {\r\n      const [myContacts, peers] = results;\r\n\r\n      this.saveApiUsers(peers.users);\r\n      appChatsManager.saveApiChats(peers.chats);\r\n\r\n      // * contacts.search returns duplicates in my_results\r\n      const myResults = new Set(myContacts.concat(peers.my_results.map(p => appPeersManager.getPeerID(p))));\r\n\r\n      const out = {\r\n        my_results: [...myResults].slice(0, limit),\r\n        results: peers.results.map(p => appPeersManager.getPeerID(p))\r\n      };\r\n\r\n      return out;\r\n    });\r\n  } */\r\n  public searchContacts(query: string, limit = 20) {\r\n    return apiManager.invokeApiCacheable('contacts.search', {\r\n      q: query,\r\n      limit\r\n    }, {cacheSeconds: 60}).then(peers => {\r\n      this.saveApiUsers(peers.users);\r\n      appChatsManager.saveApiChats(peers.chats);\r\n\r\n      const out = {\r\n        my_results: filterUnique(peers.my_results.map(p => appPeersManager.getPeerId(p))), // ! contacts.search returns duplicates in my_results\r\n        results: peers.results.map(p => appPeersManager.getPeerId(p))\r\n      };\r\n\r\n      return out;\r\n    });\r\n  }\r\n\r\n  private onContactUpdated(userId: number, isContact: boolean) {\r\n    const curIsContact = this.isContact(userId);\r\n    if(isContact !== curIsContact) {\r\n      if(isContact) {\r\n        this.pushContact(userId);\r\n      } else {\r\n        this.contactsList.delete(userId);\r\n      }\r\n\r\n      this.onContactsModified();\r\n\r\n      rootScope.dispatchEvent('contacts_update', userId);\r\n    }\r\n  }\r\n\r\n  public updateUsername(username: string) {\r\n    return apiManager.invokeApi('account.updateUsername', {\r\n      username\r\n    }).then((user) => {\r\n      this.saveApiUser(user);\r\n    });\r\n  }\r\n\r\n  public setUserStatus(userId: number, offline: boolean) {\r\n    if(this.isBot(userId)) {\r\n      return;\r\n    }\r\n\r\n    const user = this.users[userId];\r\n    if(user) {\r\n      const status: any = offline ? {\r\n        _: 'userStatusOffline',\r\n        was_online: tsNow(true)\r\n      } : {\r\n        _: 'userStatusOnline',\r\n        expires: tsNow(true) + 500\r\n      };\r\n\r\n      user.status = status;\r\n      //user.sortStatus = this.getUserStatusForSort(user.status);\r\n      rootScope.dispatchEvent('user_update', userId);\r\n    }\r\n  }\r\n\r\n  public addContact(userId: number, first_name: string, last_name: string, phone: string, showPhone?: true) {\r\n    return apiManager.invokeApi('contacts.addContact', {\r\n      id: this.getUserInput(userId),\r\n      first_name,\r\n      last_name,\r\n      phone,\r\n      add_phone_privacy_exception: showPhone\r\n    }).then((updates) => {\r\n      apiUpdatesManager.processUpdateMessage(updates, {override: true});\r\n\r\n      this.onContactUpdated(userId, true);\r\n    });\r\n  }\r\n\r\n  public deleteContacts(userIds: number[]) {\r\n    return apiManager.invokeApi('contacts.deleteContacts', {\r\n      id: userIds.map(userId => this.getUserInput(userId))\r\n    }).then((updates) => {\r\n      apiUpdatesManager.processUpdateMessage(updates, {override: true});\r\n\r\n      userIds.forEach(userId => {\r\n        this.onContactUpdated(userId, false);\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nconst appUsersManager = new AppUsersManager();\r\nMOUNT_CLASS_TO.appUsersManager = appUsersManager;\r\nexport default appUsersManager\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport { isObject, safeReplaceObject, copy, deepEqual } from \"../../helpers/object\";\r\nimport { ChannelParticipant, Chat, ChatAdminRights, ChatBannedRights, ChatParticipant, ChatPhoto, InputChannel, InputChatPhoto, InputFile, InputPeer, Update, Updates } from \"../../layer\";\r\nimport apiManagerProxy from \"../mtproto/mtprotoworker\";\r\nimport apiManager from '../mtproto/mtprotoworker';\r\nimport { RichTextProcessor } from \"../richtextprocessor\";\r\nimport rootScope from \"../rootScope\";\r\nimport apiUpdatesManager from \"./apiUpdatesManager\";\r\nimport appPeersManager from \"./appPeersManager\";\r\nimport appStateManager from \"./appStateManager\";\r\nimport appUsersManager from \"./appUsersManager\";\r\n\r\nexport type Channel = Chat.channel;\r\n\r\nexport type ChatRights = keyof ChatBannedRights['pFlags'] | keyof ChatAdminRights['pFlags'] | 'change_type' | 'change_permissions' | 'delete_chat' | 'view_participants';\r\n\r\nexport class AppChatsManager {\r\n  private storage = appStateManager.storages.chats;\r\n  \r\n  private chats: {[id: number]: Chat.channel | Chat.chat | any};\r\n  //private usernames: any;\r\n  //private channelAccess: any;\r\n  //private megagroups: {[id: number]: true};\r\n\r\n  constructor() {\r\n    this.clear(true);\r\n\r\n    rootScope.addMultipleEventsListeners({\r\n      /* updateChannel: (update) => {\r\n        const channelId = update.channel_id;\r\n        //console.log('updateChannel:', update);\r\n        rootScope.broadcast('channel_settings', {channelId});\r\n      }, */\r\n\r\n      updateChannelParticipant: (update) => {\r\n        apiManagerProxy.clearCache('channels.getParticipants', (params) => {\r\n          return (params.channel as InputChannel.inputChannel).channel_id === update.channel_id;\r\n        });\r\n      },\r\n\r\n      updateChatDefaultBannedRights: (update) => {\r\n        const chatId = -appPeersManager.getPeerId(update.peer);\r\n        const chat: Chat.chat = this.chats[chatId];\r\n        if(chat) {\r\n          chat.default_banned_rights = update.default_banned_rights;\r\n          rootScope.dispatchEvent('chat_update', chatId);\r\n        }\r\n      }\r\n    });\r\n\r\n    appStateManager.getState().then((state) => {\r\n      const chats = appStateManager.storagesResults.chats;\r\n      if(chats.length) {\r\n        for(let i = 0, length = chats.length; i < length; ++i) {\r\n          const chat = chats[i];\r\n          if(chat) {\r\n            this.chats[chat.id] = chat;\r\n          }\r\n        }\r\n      }\r\n\r\n      appStateManager.addEventListener('peerNeeded', (peerId: number) => {\r\n        if(peerId > 0 || this.storage.getFromCache(-peerId)) {\r\n          return;\r\n        }\r\n\r\n        this.storage.set({\r\n          [-peerId]: this.getChat(-peerId)\r\n        });\r\n      });\r\n\r\n      appStateManager.addEventListener('peerUnneeded', (peerId: number) => {\r\n        if(peerId > 0 || !this.storage.getFromCache(-peerId)) {\r\n          return;\r\n        }\r\n\r\n        this.storage.delete(-peerId);\r\n      });\r\n    });\r\n  }\r\n\r\n  public clear(init = false) {\r\n    if(!init) {\r\n      const chats = appStateManager.storagesResults.chats;\r\n      for(const _chatId in this.chats) {\r\n        const chatId = +_chatId;\r\n        if(!chatId) continue;\r\n        if(!appStateManager.isPeerNeeded(-chatId)) {\r\n          /* const chat = this.chats[chatId];\r\n          if(chat.username) {\r\n            delete this.usernames[cleanUsername(chat.username)];\r\n          } */\r\n          \r\n          chats.findAndSplice((chat) => chat.id === chatId);\r\n          this.storage.delete(chatId);\r\n          delete this.chats[chatId];\r\n        }\r\n      }\r\n    } else {\r\n      this.chats = {};\r\n    }\r\n  }\r\n\r\n  public saveApiChats(apiChats: any[], override?: boolean) {\r\n    apiChats.forEach(chat => this.saveApiChat(chat, override));\r\n  }\r\n\r\n  public saveApiChat(chat: Chat, override?: boolean) {\r\n    if(chat._ === 'chatEmpty') return;\r\n    /* if(chat._ !== 'chat' && chat._ !== 'channel') {\r\n      return;\r\n    } */\r\n    \r\n    // * exclude from state\r\n    // defineNotNumerableProperties(chat, ['rTitle', 'initials']);\r\n\r\n    const oldChat: Exclude<Chat, Chat.chatEmpty> = this.chats[chat.id];\r\n\r\n    /* if(oldChat && !override) {\r\n      return;\r\n    } */\r\n\r\n    if((chat as Chat.chat).pFlags === undefined) {\r\n      (chat as Chat.chat).pFlags = {};\r\n    }\r\n\r\n    if((chat as Chat.channel).pFlags.min && oldChat !== undefined) {\r\n      return;\r\n    }\r\n\r\n    chat.initials = RichTextProcessor.getAbbreviation(chat.title);\r\n\r\n    if(chat._ === 'channel' &&\r\n        chat.participants_count === undefined &&\r\n        oldChat !== undefined &&\r\n        (oldChat as Chat.channel).participants_count) {\r\n      chat.participants_count = (oldChat as Chat.channel).participants_count;\r\n    }\r\n\r\n    /* if(chat.username) {\r\n      let searchUsername = searchIndexManager.cleanUsername(chat.username);\r\n      this.usernames[searchUsername] = chat.id;\r\n    } */\r\n\r\n    let changedPhoto = false, changedTitle = false;\r\n    if(oldChat === undefined) {\r\n      this.chats[chat.id] = chat;\r\n    } else {\r\n      const oldPhotoId = ((oldChat as Chat.chat).photo as ChatPhoto.chatPhoto)?.photo_id;\r\n      const newPhotoId = ((chat as Chat.chat).photo as ChatPhoto.chatPhoto)?.photo_id;\r\n      if(oldPhotoId !== newPhotoId) {\r\n        changedPhoto = true;\r\n      }\r\n\r\n      if(oldChat.title !== chat.title) {\r\n        changedTitle = true;\r\n      }\r\n\r\n      safeReplaceObject(oldChat, chat);\r\n      rootScope.dispatchEvent('chat_update', chat.id);\r\n    }\r\n\r\n    if(changedPhoto) {\r\n      rootScope.dispatchEvent('avatar_update', -chat.id);\r\n    }\r\n\r\n    if(changedTitle) {\r\n      rootScope.dispatchEvent('peer_title_edit', -chat.id);\r\n    }\r\n\r\n    if(appStateManager.isPeerNeeded(-chat.id)) {\r\n      this.storage.set({\r\n        [chat.id]: chat\r\n      });\r\n    }\r\n  }\r\n\r\n  public getChat(id: number) {\r\n    if(id < 0) id = -id;\r\n    return this.chats[id] || {_: 'chatEmpty', id, deleted: true, access_hash: '', pFlags: {}/* this.channelAccess[id] */};\r\n  }\r\n\r\n  public combineParticipantBannedRights(id: number, rights: ChatBannedRights) {\r\n    const chat: Chat.channel = this.getChat(id);\r\n\r\n    if(chat.default_banned_rights) {\r\n      rights = copy(rights);\r\n      const defaultRights = chat.default_banned_rights.pFlags;\r\n      for(let i in defaultRights) {\r\n        // @ts-ignore\r\n        rights.pFlags[i] = defaultRights[i];\r\n      }\r\n    }\r\n\r\n    return rights;\r\n  }\r\n\r\n  public hasRights(id: number, action: ChatRights, rights?: ChatAdminRights | ChatBannedRights, isThread?: boolean) {\r\n    const chat: Chat = this.getChat(id);\r\n    if(chat._ === 'chatEmpty') return false;\r\n\r\n    if(chat._ === 'chatForbidden' ||\r\n        chat._ === 'channelForbidden' ||\r\n        (chat as Chat.chat).pFlags.kicked ||\r\n        (chat.pFlags.left && !(chat as Chat.channel).pFlags.megagroup)) {\r\n      return false;\r\n    }\r\n\r\n    if((chat as Chat.chat).pFlags.deactivated && action !== 'view_messages') {\r\n      return false;\r\n    }\r\n\r\n    if(chat.pFlags.creator && rights === undefined) {\r\n      return true;\r\n    }\r\n\r\n    if(!rights) {\r\n      rights = chat.admin_rights || (chat as Chat.channel).banned_rights || chat.default_banned_rights;\r\n\r\n      if(!rights) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    let myFlags: Partial<{[flag in keyof ChatBannedRights['pFlags'] | keyof ChatAdminRights['pFlags']]: true}> = {};\r\n    if(rights) {\r\n      myFlags = rights.pFlags as any;\r\n    }\r\n\r\n    switch(action) {\r\n      case 'embed_links':\r\n      case 'send_games':\r\n      case 'send_gifs':\r\n      case 'send_inline':\r\n      case 'send_media':\r\n      case 'send_messages':\r\n      case 'send_polls':\r\n      case 'send_stickers': {\r\n        if(!isThread && chat.pFlags.left) {\r\n          return false;\r\n        }\r\n\r\n        if(rights._ === 'chatBannedRights' && myFlags[action]) {\r\n          return false;\r\n        }\r\n\r\n        if(chat._ === 'channel') {\r\n          if(!chat.pFlags.megagroup && !myFlags.post_messages) {\r\n            return false;\r\n          }\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      // * revoke foreign messages\r\n      case 'delete_messages': {\r\n        return !!myFlags.delete_messages;\r\n      }\r\n\r\n      case 'pin_messages': {\r\n        return rights._ === 'chatAdminRights' ? myFlags[action] || !!myFlags.post_messages : !myFlags[action];\r\n      }\r\n\r\n      case 'invite_users':\r\n      case 'change_info': {\r\n        return rights._ === 'chatAdminRights' ? myFlags[action] : !myFlags[action];\r\n      }\r\n\r\n      // * only creator can do that\r\n      case 'change_type':\r\n      case 'delete_chat': {\r\n        return false;\r\n      }\r\n\r\n      case 'change_permissions': {\r\n        return rights._ === 'chatAdminRights' && myFlags['ban_users'];\r\n      }\r\n\r\n      case 'view_participants': {\r\n        return !!(chat._ === 'chat' || !chat.pFlags.broadcast || chat.pFlags.creator || chat.admin_rights);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public editChatDefaultBannedRights(id: number, banned_rights: ChatBannedRights) {\r\n    const chat: Chat.chat = this.getChat(id);\r\n    if(chat.default_banned_rights) {\r\n      if(chat.default_banned_rights.until_date === banned_rights.until_date && deepEqual(chat.default_banned_rights.pFlags, banned_rights.pFlags)) {\r\n        return Promise.resolve();\r\n      }\r\n    }\r\n    \r\n    return apiManager.invokeApi('messages.editChatDefaultBannedRights', {\r\n      peer: appPeersManager.getInputPeerById(-id),\r\n      banned_rights\r\n    }).then(this.onChatUpdated.bind(this, id));\r\n  }\r\n\r\n  /* public resolveUsername(username: string) {\r\n    return this.usernames[username] || 0;\r\n  } */\r\n\r\n  /* public saveChannelAccess(id: number, accessHash: string) {\r\n    this.channelAccess[id] = accessHash;\r\n  } */\r\n\r\n  /* public saveIsMegagroup(id: number) {\r\n    this.megagroups[id] = true;\r\n  } */\r\n\r\n  public isChannel(id: number) {\r\n    const chat = this.chats[id];\r\n    return chat && (chat._ === 'channel' || chat._ === 'channelForbidden')/*  || this.channelAccess[id] */;\r\n  }\r\n\r\n  public isMegagroup(id: number) {\r\n    /* if(this.megagroups[id]) {\r\n      return true;\r\n    } */\r\n\r\n    const chat = this.chats[id];\r\n    return chat && chat._ === 'channel' && chat.pFlags.megagroup;\r\n  }\r\n\r\n  public isBroadcast(id: number) {\r\n    return this.isChannel(id) && !this.isMegagroup(id);\r\n  }\r\n\r\n  public isInChat(id: number) {\r\n    let good = true;\r\n    const chat: Chat = this.getChat(id);\r\n    if(chat._ === 'channelForbidden' \r\n      || chat._ === 'chatForbidden' \r\n      || chat._ === 'chatEmpty' \r\n      || (chat as Chat.chat).pFlags.left \r\n      || (chat as Chat.chat).pFlags.kicked \r\n      || (chat as Chat.chat).pFlags.deactivated) {\r\n      good = false;\r\n    }\r\n\r\n    return good;\r\n  }\r\n\r\n  public getChannelInput(id: number): InputChannel {\r\n    const chat: Chat = this.getChat(id);\r\n    if(chat._ === 'chatEmpty' || !(chat as Chat.channel).access_hash) {\r\n      return {\r\n        _: 'inputChannelEmpty'\r\n      };\r\n    } else {\r\n      return {\r\n        _: 'inputChannel',\r\n        channel_id: id,\r\n        access_hash: (chat as Chat.channel).access_hash/*  || this.channelAccess[id] */ || '0'\r\n      };\r\n    }\r\n  }\r\n\r\n  public getChatInputPeer(id: number): InputPeer.inputPeerChat {\r\n    return {\r\n      _: 'inputPeerChat',\r\n      chat_id: id\r\n    };\r\n  }\r\n\r\n  public getChannelInputPeer(id: number): InputPeer.inputPeerChannel {\r\n    return {\r\n      _: 'inputPeerChannel',\r\n      channel_id: id,\r\n      access_hash: this.getChat(id).access_hash/*  || this.channelAccess[id] */ || 0\r\n    };\r\n  }\r\n\r\n  public hasChat(id: number, allowMin?: true) {\r\n    const chat = this.chats[id]\r\n    return isObject(chat) && (allowMin || !chat.pFlags.min);\r\n  }\r\n\r\n  public getChatPhoto(id: number) {\r\n    const chat: Chat.chat = this.getChat(id);\r\n\r\n    return chat && chat.photo || {\r\n      _: 'chatPhotoEmpty'\r\n    };\r\n  }\r\n\r\n  public getChatString(id: number) {\r\n    const chat = this.getChat(id);\r\n    if(this.isChannel(id)) {\r\n      return (this.isMegagroup(id) ? 's' : 'c') + id + '_' + chat.access_hash;\r\n    }\r\n    return 'g' + id;\r\n  }\r\n\r\n  /* public wrapForFull(id: number, fullChat: any) {\r\n    const chatFull = copy(fullChat);\r\n    const chat = this.getChat(id);\r\n\r\n    if(!chatFull.participants_count) {\r\n      chatFull.participants_count = chat.participants_count;\r\n    }\r\n\r\n    if(chatFull.participants &&\r\n        chatFull.participants._ === 'chatParticipants') {\r\n      chatFull.participants.participants = this.wrapParticipants(id, chatFull.participants.participants);\r\n    }\r\n\r\n    if(chatFull.about) {\r\n      chatFull.rAbout = RichTextProcessor.wrapRichText(chatFull.about, {noLinebreaks: true});\r\n    }\r\n\r\n    //chatFull.peerString = this.getChatString(id);\r\n    chatFull.chat = chat;\r\n\r\n    return chatFull;\r\n  }\r\n\r\n  public wrapParticipants(id: number, participants: any[]) {\r\n    const chat = this.getChat(id);\r\n    const myId = appUsersManager.getSelf().id;\r\n    if(this.isChannel(id)) {\r\n      const isAdmin = chat.pFlags.creator;\r\n      participants.forEach((participant) => {\r\n        participant.canLeave = myId === participant.user_id;\r\n        participant.canKick = isAdmin && participant._ === 'channelParticipant';\r\n\r\n        // just for order by last seen\r\n        participant.user = appUsersManager.getUser(participant.user_id);\r\n      });\r\n    } else {\r\n      const isAdmin = chat.pFlags.creator || chat.pFlags.admins_enabled && chat.pFlags.admin;\r\n      participants.forEach((participant) => {\r\n        participant.canLeave = myId === participant.user_id;\r\n        participant.canKick = !participant.canLeave && (\r\n          chat.pFlags.creator ||\r\n          participant._ === 'chatParticipant' && (isAdmin || myId === participant.inviter_id)\r\n        );\r\n\r\n        // just for order by last seen\r\n        participant.user = appUsersManager.getUser(participant.user_id);\r\n      });\r\n    }\r\n\r\n    return participants;\r\n  } */\r\n\r\n  public createChannel(title: string, about: string): Promise<number> {\r\n    return apiManager.invokeApi('channels.createChannel', {\r\n      broadcast: true,\r\n      title,\r\n      about\r\n    }).then((updates) => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n\r\n      const channelId = (updates as any).chats[0].id;\r\n      rootScope.dispatchEvent('history_focus', {peerId: -channelId});\r\n\r\n      return channelId;\r\n    });\r\n  }\r\n\r\n  public inviteToChannel(id: number, userIds: number[]) {\r\n    const input = this.getChannelInput(id);\r\n    const usersInputs = userIds.map(u => appUsersManager.getUserInput(u));\r\n\r\n    return apiManager.invokeApi('channels.inviteToChannel', {\r\n      channel: input,\r\n      users: usersInputs\r\n    }).then(this.onChatUpdated.bind(this, id));\r\n  }\r\n\r\n  public createChat(title: string, userIds: number[]): Promise<number> {\r\n    return apiManager.invokeApi('messages.createChat', {\r\n      users: userIds.map(u => appUsersManager.getUserInput(u)),\r\n      title\r\n    }).then(updates => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n\r\n      const chatId = (updates as any as Updates.updates).chats[0].id;\r\n      rootScope.dispatchEvent('history_focus', {peerId: -chatId});\r\n\r\n      return chatId;\r\n    });\r\n  }\r\n\r\n  private onChatUpdated = (chatId: number, updates?: any) => {\r\n    //console.log('onChatUpdated', chatId, updates);\r\n\r\n    apiUpdatesManager.processUpdateMessage(updates);\r\n    if(updates?.updates?.length && this.isChannel(chatId)) {\r\n      rootScope.dispatchEvent('invalidate_participants', chatId);\r\n    }\r\n  };\r\n\r\n  public leaveChannel(id: number) {\r\n    return apiManager.invokeApi('channels.leaveChannel', {\r\n      channel: this.getChannelInput(id)\r\n    }).then(this.onChatUpdated.bind(this, id));\r\n  }\r\n\r\n  public joinChannel(id: number) {\r\n    return apiManager.invokeApi('channels.joinChannel', {\r\n      channel: this.getChannelInput(id)\r\n    }).then(this.onChatUpdated.bind(this, id));\r\n  }\r\n\r\n  public addChatUser(id: number, userId: number, fwdLimit = 100) {\r\n    return apiManager.invokeApi('messages.addChatUser', {\r\n      chat_id: id,\r\n      user_id: appUsersManager.getUserInput(userId),\r\n      fwd_limit: fwdLimit\r\n    }).then(this.onChatUpdated.bind(this, id));\r\n  }\r\n\r\n  public deleteChatUser(id: number, userId: number) {\r\n    return apiManager.invokeApi('messages.deleteChatUser', {\r\n      chat_id: id,\r\n      user_id: appUsersManager.getUserInput(userId)\r\n    }).then(this.onChatUpdated.bind(this, id));\r\n  }\r\n\r\n  public leaveChat(id: number) {\r\n    return this.deleteChatUser(id, appUsersManager.getSelf().id);\r\n  }\r\n\r\n  public leave(id: number) {\r\n    return this.isChannel(id) ? this.leaveChannel(id) : this.leaveChat(id);\r\n  }\r\n\r\n  public delete(id: number) {\r\n    return this.isChannel(id) ? this.deleteChannel(id) : this.deleteChat(id);\r\n  }\r\n\r\n  public deleteChannel(id: number) {\r\n    return apiManager.invokeApi('channels.deleteChannel', {\r\n      channel: this.getChannelInput(id)\r\n    }).then(this.onChatUpdated.bind(this, id));\r\n  }\r\n\r\n  public deleteChat(id: number) {\r\n    //return this.leaveChat(id).then(() => {\r\n      return apiManager.invokeApi('messages.deleteChat', {\r\n        chat_id: id\r\n      });\r\n    //});\r\n  }\r\n\r\n  public migrateChat(id: number): Promise<number> {\r\n    const chat: Chat = this.getChat(id);\r\n    if(chat._ === 'channel') return Promise.resolve(chat.id);\r\n    return apiManager.invokeApi('messages.migrateChat', {\r\n      chat_id: id\r\n    }).then((updates) => {\r\n      this.onChatUpdated(id, updates);\r\n      const update: Update.updateChannel = (updates as Updates.updates).updates.find(u => u._ === 'updateChannel') as any;\r\n      return update.channel_id;\r\n    });\r\n  }\r\n\r\n  public updateUsername(id: number, username: string) {\r\n    return apiManager.invokeApi('channels.updateUsername', {\r\n      channel: this.getChannelInput(id),\r\n      username\r\n    }).then((bool) => {\r\n      if(bool) {\r\n        const chat: Chat.channel = this.getChat(id);\r\n        chat.username = username;\r\n      }\r\n\r\n      return bool;\r\n    });\r\n  }\r\n\r\n  public editPhoto(id: number, inputFile: InputFile) {\r\n    const inputChatPhoto: InputChatPhoto = {\r\n      _: 'inputChatUploadedPhoto',\r\n      file: inputFile\r\n    };\r\n\r\n    let promise: any;\r\n    if(this.isChannel(id)) {\r\n      promise = apiManager.invokeApi('channels.editPhoto', {\r\n        channel: this.getChannelInput(id),\r\n        photo: inputChatPhoto\r\n      });\r\n    } else {\r\n      promise = apiManager.invokeApi('messages.editChatPhoto', {\r\n        chat_id: id,\r\n        photo: inputChatPhoto\r\n      });\r\n    }\r\n\r\n    return promise.then((updates: any) => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    });\r\n  }\r\n\r\n  public editTitle(id: number, title: string) {\r\n    let promise: any;\r\n\r\n    if(this.isChannel(id)) {\r\n      promise = apiManager.invokeApi('channels.editTitle', {\r\n        channel: this.getChannelInput(id),\r\n        title\r\n      });\r\n    } else {\r\n      promise = apiManager.invokeApi('messages.editChatTitle', {\r\n        chat_id: id,\r\n        title\r\n      });\r\n    }\r\n\r\n    return promise.then((updates: any) => {\r\n      apiUpdatesManager.processUpdateMessage(updates);\r\n    });\r\n  }\r\n\r\n  public editAbout(id: number, about: string) {\r\n    return apiManager.invokeApi('messages.editChatAbout', {\r\n      peer: appPeersManager.getInputPeerById(-id),\r\n      about\r\n    }).then(bool => {\r\n      //apiUpdatesManager.processUpdateMessage(updates);\r\n      rootScope.dispatchEvent('peer_bio_edit', -id);\r\n    });\r\n  }\r\n\r\n  public getParticipantPeerId(participant: ChannelParticipant | ChatParticipant) {\r\n    const peerId = (participant as ChannelParticipant.channelParticipantBanned).peer ? \r\n      appPeersManager.getPeerId((participant as ChannelParticipant.channelParticipantBanned).peer) : \r\n      (participant as ChatParticipant.chatParticipant).user_id;\r\n    return peerId;\r\n  }\r\n\r\n  public editBanned(id: number, participant: number | ChannelParticipant, banned_rights: ChatBannedRights) {\r\n    const peerId = typeof(participant) === 'number' ? participant : this.getParticipantPeerId(participant);\r\n    return apiManager.invokeApi('channels.editBanned', {\r\n      channel: this.getChannelInput(id),\r\n      participant: appPeersManager.getInputPeerById(peerId),\r\n      banned_rights\r\n    }).then((updates) => {\r\n      this.onChatUpdated(id, updates);\r\n\r\n      if(typeof(participant) !== 'number') {\r\n        const timestamp = Date.now() / 1000 | 0;\r\n        apiUpdatesManager.processLocalUpdate({\r\n          _: 'updateChannelParticipant',\r\n          channel_id: id,\r\n          date: timestamp,\r\n          actor_id: undefined,\r\n          qts: undefined,\r\n          user_id: peerId,\r\n          prev_participant: participant,\r\n          new_participant: Object.keys(banned_rights.pFlags).length ? {\r\n            _: 'channelParticipantBanned',\r\n            date: timestamp,\r\n            banned_rights,\r\n            kicked_by: appUsersManager.getSelf().id,\r\n            peer: appPeersManager.getOutputPeer(peerId),\r\n            pFlags: {}\r\n          } : undefined\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  public clearChannelParticipantBannedRights(id: number, participant: number | ChannelParticipant) {\r\n    return this.editBanned(id, participant, {\r\n      _: 'chatBannedRights',\r\n      until_date: 0,\r\n      pFlags: {}\r\n    });\r\n  }\r\n  \r\n  public kickFromChannel(id: number, participant: number | ChannelParticipant) {\r\n    return this.editBanned(id, participant, {\r\n      _: 'chatBannedRights',\r\n      until_date: 0,\r\n      pFlags: {\r\n        view_messages: true\r\n      }\r\n    });\r\n  }\r\n\r\n  public resolveChannel(id: number) {\r\n    return apiManager.invokeApiSingle('channels.getChannels', {\r\n      id: [{\r\n        _: 'inputChannel',\r\n        channel_id: id,\r\n        access_hash: '0'\r\n      }]\r\n    }).then(messagesChats => {\r\n      this.saveApiChats(messagesChats.chats);\r\n    });\r\n  }\r\n}\r\n\r\nconst appChatsManager = new AppChatsManager();\r\nMOUNT_CLASS_TO.appChatsManager = appChatsManager;\r\nexport default appChatsManager;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nimport type { ChatPhoto, DialogPeer, InputDialogPeer, InputNotifyPeer, InputPeer, Peer, Update, UserProfilePhoto } from \"../../layer\";\r\nimport type { LangPackKey } from \"../langPack\";\r\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\r\nimport { isObject } from \"../../helpers/object\";\r\nimport { RichTextProcessor } from \"../richtextprocessor\";\r\nimport rootScope from \"../rootScope\";\r\nimport appChatsManager from \"./appChatsManager\";\r\nimport appUsersManager from \"./appUsersManager\";\r\nimport I18n from '../langPack';\r\n\r\n// https://github.com/eelcohn/Telegram-API/wiki/Calculating-color-for-a-Telegram-user-on-IRC\r\n/*\r\n  HTML-color  IRC-color  Description\r\n  #c03d33     4          red\r\n  #4fad2d     3          green\r\n  #d09306     7          yellow\r\n  #168acd     10         blue\r\n  #8544d6     6          purple\r\n  #cd4073     13         pink\r\n  #2996ad     11         sea\r\n  #ce671b     5          orange\r\n  */\r\nconst DialogColorsFg = ['#fc5c51', '#0fb297', '#d09306', '#3d72ed', '#895dd5', '#cd4073', '#00c1a6', '#fa790f'];\r\nconst DialogColors = ['red', 'green', 'yellow', 'blue', 'violet', 'pink', 'cyan', 'orange'];\r\nconst DialogColorsMap = [0, 7, 4, 1, 6, 3, 5];\r\n\r\nexport type PeerType = 'channel' | 'chat' | 'megagroup' | 'group' | 'saved';\r\nexport class AppPeersManager {\r\n  constructor() {\r\n    rootScope.addMultipleEventsListeners({\r\n      updatePeerBlocked: (update) => {\r\n        rootScope.dispatchEvent('peer_block', {peerId: this.getPeerId(update.peer_id), blocked: update.blocked});\r\n      }\r\n    });\r\n  }\r\n  /* public savePeerInstance(peerId: number, instance: any) {\r\n    if(peerId < 0) appChatsManager.saveApiChat(instance);\r\n    else appUsersManager.saveApiUser(instance);\r\n  } */\r\n\r\n  public canPinMessage(peerId: number) {\r\n    return peerId > 0 || appChatsManager.hasRights(-peerId, 'pin_messages');\r\n  }\r\n\r\n  public getPeerPhoto(peerId: number): UserProfilePhoto.userProfilePhoto | ChatPhoto.chatPhoto {\r\n    const photo = peerId > 0\r\n      ? appUsersManager.getUserPhoto(peerId)\r\n      : appChatsManager.getChatPhoto(-peerId);\r\n\r\n    return photo._ !== 'chatPhotoEmpty' && photo._ !== 'userProfilePhotoEmpty' ? photo : null;\r\n  }\r\n\r\n  public getPeerMigratedTo(peerId: number) {\r\n    if(peerId >= 0) {\r\n      return false;\r\n    }\r\n\r\n    let chat = appChatsManager.getChat(-peerId);\r\n    if(chat && chat.migrated_to && chat.pFlags.deactivated) {\r\n      return this.getPeerId(chat.migrated_to);\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  public getPeerTitle(peerId: number | any, plainText = false, onlyFirstName = false) {\r\n    if(!peerId) {\r\n      peerId = rootScope.myId;\r\n    }\r\n    \r\n    let peer: any = {}; \r\n    if(!isObject(peerId)) {\r\n      peer = this.getPeer(peerId);\r\n    } else peer = peerId;\r\n\r\n    let title = '';\r\n    if(peerId > 0) {\r\n      if(peer.first_name) title += peer.first_name;\r\n      if(peer.last_name && (!onlyFirstName || !title)) title += ' ' + peer.last_name;\r\n  \r\n      if(!title) title = peer.pFlags.deleted ? I18n.format('HiddenName', true) : peer.username;\r\n      else title = title.trim();\r\n    } else {\r\n      title = peer.title;\r\n\r\n      if(onlyFirstName) {\r\n        title = title.split(' ')[0];\r\n      }\r\n    }\r\n    \r\n    return plainText ? title : RichTextProcessor.wrapEmojiText(title);\r\n  }\r\n  \r\n  public getOutputPeer(peerId: number): Peer {\r\n    if(peerId > 0) {\r\n      return {_: 'peerUser', user_id: peerId};\r\n    }\r\n\r\n    let chatId = -peerId;\r\n    if(appChatsManager.isChannel(chatId)) {\r\n      return {_: 'peerChannel', channel_id: chatId};\r\n    }\r\n\r\n    return {_: 'peerChat', chat_id: chatId};\r\n  }\r\n\r\n  public getPeerString(peerId: number) {\r\n    if(peerId > 0) {\r\n      return appUsersManager.getUserString(peerId);\r\n    }\r\n    return appChatsManager.getChatString(-peerId);\r\n  }\r\n\r\n  public getPeerUsername(peerId: number): string {\r\n    if(peerId > 0) {\r\n      return appUsersManager.getUser(peerId).username || '';\r\n    }\r\n    return appChatsManager.getChat(-peerId).username || '';\r\n  }\r\n\r\n  public getPeer(peerId: number) {\r\n    return peerId > 0\r\n      ? appUsersManager.getUser(peerId)\r\n      : appChatsManager.getChat(-peerId)\r\n  }\r\n\r\n  public getPeerId(peerId: Peer | InputPeer | number | string): number {\r\n    if(typeof(peerId) === 'number') return peerId;\r\n    else if(isObject(peerId)) return (peerId as Peer.peerUser).user_id || -((peerId as Peer.peerChannel).channel_id || (peerId as Peer.peerChat).chat_id);\r\n    else if(!peerId) return 0;\r\n    \r\n    const isUser = (peerId as string).charAt(0) === 'u';\r\n    const peerParams = (peerId as string).substr(1).split('_');\r\n\r\n    return isUser ? +peerParams[0] : -peerParams[0] || 0;\r\n  }\r\n\r\n  public getDialogPeer(peerId: number): DialogPeer {\r\n    return {\r\n      _: 'dialogPeer',\r\n      peer: this.getOutputPeer(peerId)\r\n    };\r\n  }\r\n\r\n  public isChannel(peerId: number): boolean {\r\n    return (peerId < 0) && appChatsManager.isChannel(-peerId);\r\n  }\r\n\r\n  public isMegagroup(peerId: number) {\r\n    return (peerId < 0) && appChatsManager.isMegagroup(-peerId);\r\n  }\r\n\r\n  public isAnyGroup(peerId: number): boolean {\r\n    return (peerId < 0) && !appChatsManager.isBroadcast(-peerId);\r\n  }\r\n\r\n  public isBroadcast(peerId: number): boolean {\r\n    return this.isChannel(peerId) && !this.isMegagroup(peerId);\r\n  }\r\n\r\n  public isBot(peerId: number): boolean {\r\n    return (peerId > 0) && appUsersManager.isBot(peerId);\r\n  }\r\n\r\n  /* public getInputPeer(peerString: string): InputPeer {\r\n    var firstChar = peerString.charAt(0);\r\n    var peerParams = peerString.substr(1).split('_');\r\n    let id = +peerParams[0];\r\n\r\n    if(firstChar === 'u') {\r\n      //appUsersManager.saveUserAccess(id, peerParams[1]);\r\n\r\n      return {\r\n        _: 'inputPeerUser',\r\n        user_id: id,\r\n        access_hash: peerParams[1]\r\n      };\r\n    } else if(firstChar === 'c' || firstChar === 's') {\r\n      //appChatsManager.saveChannelAccess(id, peerParams[1]);\r\n      if(firstChar === 's') {\r\n        appChatsManager.saveIsMegagroup(id);\r\n      }\r\n\r\n      return {\r\n        _: 'inputPeerChannel',\r\n        channel_id: id,\r\n        access_hash: peerParams[1] || '0'\r\n      };\r\n    } else {\r\n      return {\r\n        _: 'inputPeerChat',\r\n        chat_id: id\r\n      };\r\n    }\r\n  } */\r\n\r\n  public getInputNotifyPeerById(peerId: number, ignorePeerId: true): Exclude<InputNotifyPeer, InputNotifyPeer.inputNotifyPeer>;\r\n  public getInputNotifyPeerById(peerId: number, ignorePeerId?: false): InputNotifyPeer.inputNotifyPeer;\r\n  public getInputNotifyPeerById(peerId: number, ignorePeerId?: boolean): InputNotifyPeer {\r\n    if(ignorePeerId) {\r\n      if(peerId > 0) {\r\n        return {_: 'inputNotifyUsers'};\r\n      } else {\r\n        if(appPeersManager.isBroadcast(peerId)) {\r\n          return {_: 'inputNotifyBroadcasts'};\r\n        } else {\r\n          return {_: 'inputNotifyChats'};\r\n        }\r\n      }\r\n    } else {\r\n      return {\r\n        _: 'inputNotifyPeer', \r\n        peer: this.getInputPeerById(peerId)\r\n      };\r\n    }\r\n  }\r\n\r\n  public getInputPeerById(peerId: number): InputPeer {\r\n    if(!peerId) {\r\n      return {_: 'inputPeerEmpty'};\r\n    }\r\n\r\n    if(peerId < 0) {\r\n      const chatId = -peerId;\r\n      if(!appChatsManager.isChannel(chatId)) {\r\n        return appChatsManager.getChatInputPeer(chatId);\r\n      } else {\r\n        return appChatsManager.getChannelInputPeer(chatId);\r\n      }\r\n    }\r\n\r\n    return {\r\n      _: 'inputPeerUser',\r\n      user_id: peerId,\r\n      access_hash: appUsersManager.getUser(peerId).access_hash\r\n    };\r\n  }\r\n\r\n  public getInputDialogPeerById(peerId: number): InputDialogPeer {\r\n    return {\r\n      _: 'inputDialogPeer',\r\n      peer: this.getInputPeerById(peerId)\r\n    }\r\n  }\r\n\r\n  public getPeerColorById(peerId: number, pic = true) {\r\n    if(!peerId) return '';\r\n\r\n    const idx = DialogColorsMap[(peerId < 0 ? -peerId : peerId) % 7];\r\n    const color = (pic ? DialogColors : DialogColorsFg)[idx];\r\n    return color;\r\n  }\r\n\r\n  public getPeerSearchText(peerId: number) {\r\n    let text;\r\n    if(peerId > 0) {\r\n      text = '%pu ' + appUsersManager.getUserSearchText(peerId);\r\n    } else if(peerId < 0) {\r\n      const chat = appChatsManager.getChat(-peerId);\r\n      text = '%pg ' + (chat.title || '');\r\n    }\r\n    return text;\r\n  }\r\n\r\n  public getDialogType(peerId: number): PeerType {\r\n    if(appPeersManager.isMegagroup(peerId)) {\r\n      return 'megagroup';\r\n    } else if(appPeersManager.isChannel(peerId)) {\r\n      return 'channel';\r\n    } else if(peerId < 0) {\r\n      return 'group';\r\n    } else {\r\n      return peerId === rootScope.myId ? 'saved' : 'chat';\r\n    }\r\n  }\r\n\r\n  public getDeleteButtonText(peerId: number): LangPackKey {\r\n    switch(this.getDialogType(peerId)) {\r\n      case 'channel':\r\n        return 'ChatList.Context.LeaveChannel';\r\n\r\n      case 'megagroup':\r\n        return 'ChatList.Context.LeaveGroup';\r\n\r\n      case 'group':\r\n        return 'ChatList.Context.DeleteAndExit';\r\n      \r\n      default:\r\n        return 'ChatList.Context.DeleteChat';\r\n    }\r\n  }\r\n}\r\n\r\nconst appPeersManager = new AppPeersManager();\r\nMOUNT_CLASS_TO.appPeersManager = appPeersManager;\r\nexport default appPeersManager;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n/* import { copy } from \"./object\";\r\n\r\nexport function listMergeSorted(list1: any[] = [], list2: any[] = []) {\r\n  const result = copy(list1);\r\n\r\n  const minId = list1.length ? list1[list1.length - 1] : 0xFFFFFFFF;\r\n  for(let i = 0; i < list2.length; i++) {\r\n    if(list2[i] < minId) {\r\n      result.push(list2[i]);\r\n    }\r\n  }\r\n\r\n  return result;\r\n} */\r\n\r\nexport const accumulate = (arr: number[], initialValue: number) => arr.reduce((acc, value) => acc + value, initialValue);\r\n\r\nexport function findAndSpliceAll<T>(array: Array<T>, verify: (value: T, index: number, arr: typeof array) => boolean) {\r\n  const out: typeof array = [];\r\n  let idx = -1;\r\n  while((idx = array.findIndex(verify)) !== -1) {\r\n    out.push(array.splice(idx, 1)[0]);\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\nexport function forEachReverse<T>(array: Array<T>, callback: (value: T, index?: number, array?: Array<T>) => void) {\r\n  for(let length = array.length, i = length - 1; i >= 0; --i) {\r\n    callback(array[i], i, array);\r\n  }\r\n};\r\n\r\nexport function insertInDescendSortedArray<T extends {[smth in K]?: number}, K extends keyof T>(array: Array<T>, element: T, property: K, pos?: number) {\r\n  if(pos === undefined) {\r\n    pos = array.indexOf(element);\r\n    if(pos !== -1) {\r\n      array.splice(pos, 1);\r\n    }\r\n  }\r\n\r\n  const sortProperty: number = element[property];\r\n  const len = array.length;\r\n  if(!len || sortProperty <= array[len - 1][property]) {\r\n    return array.push(element) - 1;\r\n  } else if(sortProperty >= array[0][property]) {\r\n    array.unshift(element);\r\n    return 0;\r\n  } else {\r\n    for(let i = 0; i < len; i++) {\r\n      if(sortProperty > array[i][property]) {\r\n        array.splice(i, 0, element);\r\n        return i;\r\n      }\r\n    }\r\n  }\r\n\r\n  console.error('wtf', array, element);\r\n  return array.indexOf(element);\r\n}\r\n\r\nexport function filterUnique<T extends Array<any>>(arr: T): T {\r\n  return [...new Set(arr)] as T;\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\n//import apiManager from '../mtproto/apiManager';\r\nimport DEBUG, { MOUNT_CLASS_TO } from '../../config/debug';\r\nimport { Message, MessageFwdHeader, Peer, Update, Updates } from '../../layer';\r\nimport { logger, LogTypes } from '../logger';\r\nimport apiManager from '../mtproto/mtprotoworker';\r\nimport rootScope from '../rootScope';\r\n//import networkerFactory from '../mtproto/networkerFactory';\r\nimport appUsersManager from \"./appUsersManager\";\r\nimport appChatsManager from \"./appChatsManager\";\r\nimport appPeersManager from \"./appPeersManager\";\r\nimport appStateManager from './appStateManager';\r\nimport serverTimeManager from '../mtproto/serverTimeManager';\r\nimport assumeType from '../../helpers/assumeType';\r\n\r\ntype UpdatesState = {\r\n  pendingPtsUpdates: (Update & {pts: number, pts_count: number})[],\r\n  pendingSeqUpdates?: {[seq: number]: {seq: number, date: number, updates: any[]}},\r\n  syncPending: {\r\n    seqAwaiting?: number,\r\n    ptsAwaiting?: true,\r\n    timeout: number\r\n  },\r\n  syncLoading: Promise<void>,\r\n\r\n  seq?: number,\r\n  pts?: number,\r\n  date?: number,\r\n  lastPtsUpdateTime?: number\r\n};\r\n\r\nconst SYNC_DELAY = 6;\r\n\r\nexport class ApiUpdatesManager {\r\n  public updatesState: UpdatesState = {\r\n    pendingPtsUpdates: [],\r\n    pendingSeqUpdates: {},\r\n    syncPending: null,\r\n    syncLoading: null\r\n  };\r\n\r\n  private channelStates: {[channelId: number]: UpdatesState} = {};\r\n  private attached = false;\r\n\r\n  private log = logger('UPDATES', LogTypes.Error | LogTypes.Warn | LogTypes.Log/*  | LogTypes.Debug */);\r\n  private debug = DEBUG;\r\n\r\n  private setProxy() {\r\n    const self = this;\r\n    this.updatesState = new Proxy(this.updatesState, {\r\n      set: function(target: ApiUpdatesManager['updatesState'], key: keyof ApiUpdatesManager['updatesState'], value: ApiUpdatesManager['updatesState'][typeof key]) {\r\n        // @ts-ignore\r\n        target[key] = value;\r\n        self.saveUpdatesState();\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n\r\n  public saveUpdatesState() {\r\n    const us = this.updatesState;\r\n    appStateManager.pushToState('updates', {\r\n      seq: us.seq,\r\n      pts: us.pts,\r\n      date: us.date\r\n    });\r\n  }\r\n\r\n  private popPendingSeqUpdate() {\r\n    const state = this.updatesState;\r\n    const nextSeq = state.seq + 1;\r\n    const pendingUpdatesData = state.pendingSeqUpdates[nextSeq];\r\n    if(!pendingUpdatesData) {\r\n      return false;\r\n    }\r\n\r\n    const updates = pendingUpdatesData.updates;\r\n    for(let i = 0, length = updates.length; i < length; ++i) {\r\n      this.saveUpdate(updates[i]);\r\n    }\r\n\r\n    state.seq = pendingUpdatesData.seq;\r\n    if(pendingUpdatesData.date && state.date < pendingUpdatesData.date) {\r\n      state.date = pendingUpdatesData.date;\r\n    }\r\n    delete state.pendingSeqUpdates[nextSeq];\r\n  \r\n    if(!this.popPendingSeqUpdate() &&\r\n      state.syncPending &&\r\n      state.syncPending.seqAwaiting &&\r\n      state.seq >= state.syncPending.seqAwaiting) {\r\n      if(!state.syncPending.ptsAwaiting) {\r\n        clearTimeout(state.syncPending.timeout);\r\n        state.syncPending = null;\r\n      } else {\r\n        delete state.syncPending.seqAwaiting;\r\n      }\r\n    }\r\n  \r\n    return true;\r\n  }\r\n\r\n  private popPendingPtsUpdate(channelId: number) {\r\n    const curState = channelId ? this.getChannelState(channelId) : this.updatesState;\r\n    if(!curState.pendingPtsUpdates.length) {\r\n      return false;\r\n    }\r\n\r\n    curState.pendingPtsUpdates.sort((a, b) => {\r\n      return a.pts - b.pts;\r\n    });\r\n    // this.log('pop update', channelId, curState.pendingPtsUpdates)\r\n  \r\n    let curPts = curState.pts;\r\n    let goodPts = 0;\r\n    let goodIndex = 0;\r\n    for(let i = 0, length = curState.pendingPtsUpdates.length; i < length; ++i) {\r\n      const update = curState.pendingPtsUpdates[i];\r\n      curPts += update.pts_count;\r\n      if(curPts >= update.pts) {\r\n        goodPts = update.pts;\r\n        goodIndex = i;\r\n      }\r\n    }\r\n  \r\n    if(!goodPts) {\r\n      return false;\r\n    }\r\n  \r\n    this.debug && this.log.debug('pop pending pts updates', goodPts, curState.pendingPtsUpdates.slice(0, goodIndex + 1));\r\n  \r\n    curState.pts = goodPts;\r\n    for(let i = 0; i <= goodIndex; ++i) {\r\n      const update = curState.pendingPtsUpdates[i];\r\n\r\n      // @ts-ignore\r\n      this.saveUpdate(update);\r\n    }\r\n    curState.pendingPtsUpdates.splice(0, goodIndex + 1);\r\n  \r\n    if(!curState.pendingPtsUpdates.length && curState.syncPending) {\r\n      if(!curState.syncPending.seqAwaiting) {\r\n        clearTimeout(curState.syncPending.timeout);\r\n        curState.syncPending = null;\r\n      } else {\r\n        delete curState.syncPending.ptsAwaiting;\r\n      }\r\n    }\r\n  \r\n    return true;\r\n  }\r\n\r\n  public forceGetDifference() {\r\n    if(!this.updatesState.syncLoading) {\r\n      this.getDifference();\r\n    }\r\n  }\r\n\r\n  public processLocalUpdate(update: Update) {\r\n    this.processUpdateMessage({\r\n      _: 'updateShort',\r\n      update\r\n    } as Updates);\r\n  }\r\n\r\n  public processUpdateMessage = (updateMessage: any, options: Partial<{\r\n    override: boolean\r\n  }> = {}) => {\r\n    // return forceGetDifference()\r\n    const processOpts = {\r\n      date: updateMessage.date,\r\n      seq: updateMessage.seq,\r\n      seqStart: updateMessage.seq_start,\r\n      //ignoreSyncLoading: options.ignoreSyncLoading\r\n    };\r\n\r\n    this.debug && this.log.debug('processUpdateMessage', updateMessage);\r\n  \r\n    switch(updateMessage._) {\r\n      case 'updatesTooLong':\r\n      case 'new_session_created':\r\n        this.forceGetDifference();\r\n        break;\r\n  \r\n      case 'updateShort':\r\n        this.processUpdate(updateMessage.update, processOpts);\r\n        break;\r\n  \r\n      case 'updateShortMessage':\r\n      case 'updateShortChatMessage': {\r\n        assumeType<Updates.updateShortChatMessage | Updates.updateShortMessage>(updateMessage);\r\n        this.debug && this.log.debug('updateShortMessage | updateShortChatMessage', {...updateMessage});\r\n        const isOut = updateMessage.pFlags.out;\r\n        const fromId = (updateMessage as Updates.updateShortChatMessage).from_id || (isOut ? rootScope.myId : (updateMessage as Updates.updateShortMessage).user_id);\r\n        const toId = (updateMessage as Updates.updateShortChatMessage).chat_id\r\n          ? -(updateMessage as Updates.updateShortChatMessage).chat_id\r\n          : ((updateMessage as Updates.updateShortMessage).user_id || rootScope.myId);\r\n  \r\n        this.processUpdate({\r\n          _: 'updateNewMessage',\r\n          message: {\r\n            _: 'message',\r\n            pFlags: updateMessage.pFlags,\r\n            id: updateMessage.id,\r\n            from_id: appPeersManager.getOutputPeer(fromId),\r\n            peer_id: appPeersManager.getOutputPeer(toId),\r\n            date: updateMessage.date,\r\n            message: updateMessage.message,\r\n            fwd_from: updateMessage.fwd_from,\r\n            reply_to: updateMessage.reply_to,\r\n            entities: updateMessage.entities\r\n          },\r\n          pts: updateMessage.pts,\r\n          pts_count: updateMessage.pts_count\r\n        }, processOpts);\r\n        break;\r\n      }\r\n  \r\n      case 'updatesCombined':\r\n      case 'updates':\r\n        appUsersManager.saveApiUsers(updateMessage.users, options.override);\r\n        appChatsManager.saveApiChats(updateMessage.chats, options.override);\r\n  \r\n        updateMessage.updates.forEach((update: Update) => {\r\n          this.processUpdate(update, processOpts);\r\n        });\r\n        break;\r\n  \r\n      default:\r\n        this.log.warn('Unknown update message', updateMessage);\r\n    }\r\n  };\r\n  \r\n  private getDifference(first = false): Promise<void> {\r\n    // this.trace('Get full diff')\r\n    const updatesState = this.updatesState;\r\n    let wasSyncing = updatesState.syncLoading;\r\n    if(!wasSyncing) {\r\n      updatesState.pendingSeqUpdates = {};\r\n      updatesState.pendingPtsUpdates = [];\r\n    }\r\n  \r\n    if(updatesState.syncPending) {\r\n      clearTimeout(updatesState.syncPending.timeout);\r\n      updatesState.syncPending = null;\r\n    }\r\n\r\n    const promise = apiManager.invokeApi('updates.getDifference', {\r\n      pts: updatesState.pts, \r\n      pts_total_limit: first /* && false  */? /* 50 */1200 : undefined,\r\n      date: updatesState.date, \r\n      qts: -1\r\n    }, {\r\n      timeout: 0x7fffffff\r\n    }).then((differenceResult) => {\r\n      this.debug && this.log.debug('Get diff result', differenceResult);\r\n\r\n      if(differenceResult._ === 'updates.differenceEmpty') {\r\n        this.debug && this.log.debug('apply empty diff', differenceResult.seq);\r\n        updatesState.date = differenceResult.date;\r\n        updatesState.seq = differenceResult.seq;\r\n        return;\r\n      }\r\n\r\n      // ! SORRY I'M SORRY I'M SORRY\r\n      if(first) {\r\n        rootScope.dispatchEvent('state_synchronizing');\r\n      }\r\n\r\n      if(differenceResult._ !== 'updates.differenceTooLong') {\r\n        appUsersManager.saveApiUsers(differenceResult.users);\r\n        appChatsManager.saveApiChats(differenceResult.chats);\r\n\r\n        // Should be first because of updateMessageID\r\n        // this.log('applying', differenceResult.other_updates.length, 'other updates')\r\n    \r\n        differenceResult.other_updates.forEach((update) => {\r\n          switch(update._) {\r\n            case 'updateChannelTooLong':\r\n            case 'updateNewChannelMessage':\r\n            case 'updateEditChannelMessage':\r\n              this.processUpdate(update);\r\n              return;\r\n          }\r\n          \r\n          this.saveUpdate(update);\r\n        });\r\n\r\n        // this.log('applying', differenceResult.new_messages.length, 'new messages')\r\n        differenceResult.new_messages.forEach((apiMessage) => {\r\n          this.saveUpdate({\r\n            _: 'updateNewMessage',\r\n            message: apiMessage,\r\n            pts: updatesState.pts,\r\n            pts_count: 0\r\n          });\r\n        });\r\n\r\n        const nextState = differenceResult._ === 'updates.difference' ? differenceResult.state : differenceResult.intermediate_state;\r\n        updatesState.seq = nextState.seq;\r\n        updatesState.pts = nextState.pts;\r\n        updatesState.date = nextState.date;\r\n      } else {\r\n        updatesState.pts = differenceResult.pts;\r\n        updatesState.date = (Date.now() / 1000 | 0) + serverTimeManager.serverTimeOffset;\r\n        delete updatesState.seq;\r\n        \r\n        this.channelStates = {};\r\n        \r\n        this.log.warn('getDifference:', differenceResult._);\r\n        rootScope.dispatchEvent('state_cleared');\r\n      }\r\n  \r\n      // this.log('apply diff', updatesState.seq, updatesState.pts)\r\n  \r\n      if(differenceResult._ === 'updates.differenceSlice') {\r\n        return this.getDifference();\r\n      } else {\r\n        this.debug && this.log.debug('finished get diff');\r\n      }\r\n    });\r\n\r\n    if(!wasSyncing) {\r\n      this.justAName(updatesState, promise);\r\n    }\r\n  \r\n    return promise;\r\n  }\r\n\r\n  private getChannelDifference(channelId: number): Promise<void> {\r\n    const channelState = this.getChannelState(channelId);\r\n    const wasSyncing = channelState.syncLoading;\r\n    if(!wasSyncing) {\r\n      channelState.pendingPtsUpdates = [];\r\n    }\r\n\r\n    if(channelState.syncPending) {\r\n      clearTimeout(channelState.syncPending.timeout);\r\n      channelState.syncPending = null;\r\n    }\r\n\r\n    //this.log.trace('Get channel diff', appChatsManager.getChat(channelId), channelState.pts);\r\n    const promise = apiManager.invokeApi('updates.getChannelDifference', {\r\n      channel: appChatsManager.getChannelInput(channelId),\r\n      filter: {_: 'channelMessagesFilterEmpty'},\r\n      pts: channelState.pts,\r\n      limit: 30\r\n    }, {timeout: 0x7fffffff}).then((differenceResult) => {\r\n      this.debug && this.log.debug('Get channel diff result', differenceResult)\r\n      channelState.pts = 'pts' in differenceResult ? differenceResult.pts : undefined;\r\n  \r\n      if(differenceResult._ === 'updates.channelDifferenceEmpty') {\r\n        this.debug && this.log.debug('apply channel empty diff', differenceResult);\r\n        return;\r\n      }\r\n  \r\n      if(differenceResult._ === 'updates.channelDifferenceTooLong') {\r\n        this.debug && this.log.debug('channel diff too long', differenceResult);\r\n        delete this.channelStates[channelId];\r\n\r\n        this.saveUpdate({_: 'updateChannelReload', channel_id: channelId});\r\n        return;\r\n      }\r\n  \r\n      appUsersManager.saveApiUsers(differenceResult.users);\r\n      appChatsManager.saveApiChats(differenceResult.chats);\r\n  \r\n      // Should be first because of updateMessageID\r\n      this.debug && this.log.debug('applying', differenceResult.other_updates.length, 'channel other updates');\r\n      differenceResult.other_updates.forEach((update) => {\r\n        this.saveUpdate(update);\r\n      });\r\n  \r\n      this.debug && this.log.debug('applying', differenceResult.new_messages.length, 'channel new messages');\r\n      differenceResult.new_messages.forEach((apiMessage) => {\r\n        this.saveUpdate({\r\n          _: 'updateNewChannelMessage',\r\n          message: apiMessage,\r\n          pts: channelState.pts,\r\n          pts_count: 0\r\n        });\r\n      });\r\n  \r\n      this.debug && this.log.debug('apply channel diff', channelState.pts);\r\n  \r\n      if(differenceResult._ === 'updates.channelDifference' &&\r\n        !differenceResult.pFlags['final']) {\r\n        return this.getChannelDifference(channelId);\r\n      } else {\r\n        this.debug && this.log.debug('finished channel get diff');\r\n      }\r\n    });\r\n\r\n    if(!wasSyncing) {\r\n      this.justAName(channelState, promise, channelId);\r\n    }\r\n\r\n    return promise;\r\n  }\r\n\r\n  private justAName(state: UpdatesState, promise: UpdatesState['syncLoading'], channelId?: number) {\r\n    state.syncLoading = promise;\r\n    rootScope.dispatchEvent('state_synchronizing', channelId);\r\n\r\n    promise.then(() => {\r\n      state.syncLoading = null;\r\n      rootScope.dispatchEvent('state_synchronized', channelId);\r\n    }, () => {\r\n      state.syncLoading = null;\r\n    });\r\n  }\r\n  \r\n  public addChannelState(channelId: number, pts: number) {\r\n    if(!pts) {\r\n      throw new Error('Add channel state without pts ' + channelId);\r\n    }\r\n\r\n    if(!(channelId in this.channelStates)) {\r\n      this.channelStates[channelId] = {\r\n        pts,\r\n        pendingPtsUpdates: [],\r\n        syncPending: null,\r\n        syncLoading: null\r\n      };\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  public getChannelState(channelId: number, pts?: number) {\r\n    if(this.channelStates[channelId] === undefined) {\r\n      this.addChannelState(channelId, pts);\r\n    }\r\n\r\n    return this.channelStates[channelId];\r\n  }\r\n\r\n  private processUpdate(update: Update, options: Partial<{\r\n    date: number,\r\n    seq: number,\r\n    seqStart: number/* ,\r\n    ignoreSyncLoading: boolean */\r\n  }> = {}) {\r\n    let channelId = 0;\r\n    switch(update._) {\r\n      case 'updateNewChannelMessage':\r\n      case 'updateEditChannelMessage':\r\n        channelId = -appPeersManager.getPeerId(update.message.peer_id);\r\n        break;\r\n      /* case 'updateDeleteChannelMessages':\r\n        channelId = update.channel_id;\r\n        break; */\r\n      case 'updateChannelTooLong':\r\n        channelId = update.channel_id;\r\n        if(!(channelId in this.channelStates)) {\r\n          return false;\r\n        }\r\n        break;\r\n      default:\r\n        if('channel_id' in update && 'pts' in update) {\r\n          channelId = update.channel_id;\r\n        }\r\n        break;\r\n    }\r\n  \r\n    const {pts, pts_count} = update as Update.updateNewMessage;\r\n    const curState = channelId ? this.getChannelState(channelId, pts) : this.updatesState;\r\n  \r\n    // this.log.log('process', channelId, curState.pts, update)\r\n  \r\n    if(curState.syncLoading/*  && !options.ignoreSyncLoading */) {\r\n      return false;\r\n    }\r\n  \r\n    if(update._ === 'updateChannelTooLong') {\r\n      if(!curState.lastPtsUpdateTime ||\r\n          curState.lastPtsUpdateTime < (Date.now() - SYNC_DELAY)) {\r\n        // this.log.trace('channel too long, get diff', channelId, update)\r\n        this.getChannelDifference(channelId);\r\n      }\r\n      return false;\r\n    }\r\n  \r\n    if(update._ === 'updateNewMessage' ||\r\n        update._ === 'updateEditMessage' ||\r\n        update._ === 'updateNewChannelMessage' ||\r\n        update._ === 'updateEditChannelMessage') {\r\n      const message = update.message as Message.message;\r\n      const toPeerId = appPeersManager.getPeerId(message.peer_id);\r\n      const fwdHeader: MessageFwdHeader.messageFwdHeader = message.fwd_from || {} as any;\r\n      let reason: string;\r\n      if(message.from_id && !appUsersManager.hasUser(appPeersManager.getPeerId(message.from_id), message.pFlags.post/* || channelId*/) && (reason = 'author') ||\r\n          fwdHeader.from_id && !appUsersManager.hasUser(appPeersManager.getPeerId(fwdHeader.from_id), !!(fwdHeader.from_id as Peer.peerChannel).channel_id) && (reason = 'fwdAuthor') ||\r\n          (fwdHeader.from_id as Peer.peerChannel)?.channel_id && !appChatsManager.hasChat((fwdHeader.from_id as Peer.peerChannel).channel_id, true) && (reason = 'fwdChannel') ||\r\n          toPeerId > 0 && !appUsersManager.hasUser(toPeerId) && (reason = 'toPeer User') ||\r\n          toPeerId < 0 && !appChatsManager.hasChat(-toPeerId) && (reason = 'toPeer Chat')) {\r\n        this.log.warn('Not enough data for message update', toPeerId, reason, message);\r\n        if(channelId && appChatsManager.hasChat(channelId)) {\r\n          this.getChannelDifference(channelId);\r\n        } else {\r\n          this.forceGetDifference();\r\n        }\r\n        return false;\r\n      }\r\n    } else if(channelId && !appChatsManager.hasChat(channelId)) {\r\n      // this.log.log('skip update, missing channel', channelId, update)\r\n      return false;\r\n    }\r\n  \r\n    let popPts: boolean;\r\n    let popSeq: boolean;\r\n  \r\n    if(pts) {\r\n      const newPts = curState.pts + (pts_count || 0);\r\n      if(newPts < pts) {\r\n        this.debug && this.log.warn('Pts hole', curState, update, channelId && appChatsManager.getChat(channelId));\r\n        curState.pendingPtsUpdates.push(update as Update.updateNewMessage);\r\n        if(!curState.syncPending && !curState.syncLoading) {\r\n          curState.syncPending = {\r\n            timeout: window.setTimeout(() => {\r\n              curState.syncPending = null;\r\n\r\n              if(curState.syncLoading) {\r\n                return;\r\n              }\r\n\r\n              if(channelId) {\r\n                this.getChannelDifference(channelId);\r\n              } else {\r\n                this.getDifference();\r\n              }\r\n            }, SYNC_DELAY)\r\n          };\r\n        }\r\n\r\n        curState.syncPending.ptsAwaiting = true;\r\n        return false;\r\n      }\r\n\r\n      if(pts > curState.pts) {\r\n        curState.pts = pts;\r\n        popPts = true;\r\n  \r\n        curState.lastPtsUpdateTime = Date.now();\r\n      } else if(pts_count) {\r\n        // this.log.warn('Duplicate update', update)\r\n        return false;\r\n      }\r\n\r\n      if(channelId && options.date && this.updatesState.date < options.date) {\r\n        this.updatesState.date = options.date;\r\n      }\r\n    } else if(!channelId && options.seq > 0) {\r\n      const seq = options.seq;\r\n      const seqStart = options.seqStart || seq;\r\n  \r\n      if(seqStart !== curState.seq + 1) {\r\n        if(seqStart > curState.seq) {\r\n          this.debug && this.log.warn('Seq hole', curState, curState.syncPending && curState.syncPending.seqAwaiting);\r\n  \r\n          if(curState.pendingSeqUpdates[seqStart] === undefined) {\r\n            curState.pendingSeqUpdates[seqStart] = {seq, date: options.date, updates: []};\r\n          }\r\n          curState.pendingSeqUpdates[seqStart].updates.push(update);\r\n  \r\n          if(!curState.syncPending) {\r\n            curState.syncPending = {\r\n              timeout: window.setTimeout(() => {\r\n                curState.syncPending = null;\r\n\r\n                if(curState.syncLoading) {\r\n                  return;\r\n                }\r\n\r\n                this.getDifference();\r\n              }, SYNC_DELAY)\r\n            };\r\n          }\r\n\r\n          if(!curState.syncPending.seqAwaiting ||\r\n            curState.syncPending.seqAwaiting < seqStart) {\r\n            curState.syncPending.seqAwaiting = seqStart;\r\n          }\r\n          return false;\r\n        }\r\n      }\r\n  \r\n      if(curState.seq !== seq) {\r\n        curState.seq = seq;\r\n        if(options.date && curState.date < options.date) {\r\n          curState.date = options.date;\r\n        }\r\n\r\n        popSeq = true;\r\n      }\r\n    }\r\n  \r\n    this.saveUpdate(update);\r\n  \r\n    if(popPts) {\r\n      this.popPendingPtsUpdate(channelId);\r\n    } else if(popSeq) {\r\n      this.popPendingSeqUpdate();\r\n    }\r\n  }\r\n\r\n  public saveUpdate(update: Update) {\r\n    //this.debug && this.log('saveUpdate', update);\r\n    rootScope.dispatchEvent(update._, update as any);\r\n  }\r\n  \r\n  public attach() {\r\n    if(this.attached) return;\r\n\r\n    //return;\r\n\r\n    this.log('attach');\r\n    \r\n    this.attached = true;\r\n\r\n    appStateManager.getState().then(_state => {\r\n      const state = _state.updates;\r\n\r\n      //rootScope.broadcast('state_synchronizing');\r\n      if(!state || !state.pts || !state.date || !state.seq) {\r\n        this.log('will get new state');\r\n\r\n        this.updatesState.syncLoading = new Promise((resolve) => {\r\n          apiManager.invokeApi('updates.getState', {}, {noErrorBox: true}).then((stateResult) => {\r\n            this.updatesState.seq = stateResult.seq;\r\n            this.updatesState.pts = stateResult.pts;\r\n            this.updatesState.date = stateResult.date;\r\n            this.saveUpdatesState();\r\n            //setTimeout(() => {\r\n              this.updatesState.syncLoading = null;\r\n              resolve();\r\n              //rootScope.broadcast('state_synchronized');\r\n            //}, 1000);\r\n        \r\n          // ! for testing\r\n          // updatesState.seq = 1\r\n          // updatesState.pts = stateResult.pts - 5000\r\n          // updatesState.date = 1\r\n          // getDifference()\r\n          });\r\n        });\r\n      } else {\r\n        // ! for testing\r\n        /* state.seq = 1;\r\n        state.pts = state.pts - 15;\r\n        state.date = 1; */\r\n        // state.pts -= 100;\r\n\r\n        Object.assign(this.updatesState, state);\r\n        \r\n        this.log('will get difference', Object.assign({}, state));\r\n        \r\n        this.getDifference(true)/* .finally(() => {\r\n          if(this.updatesState.syncLoading) {\r\n            rootScope.broadcast('state_synchronizing');\r\n          }\r\n        }) */;\r\n      }\r\n\r\n      apiManager.setUpdatesProcessor(this.processUpdateMessage);\r\n\r\n      // this.updatesState.syncLoading.then(() => {\r\n        this.setProxy();\r\n      // });\r\n    });\r\n  }\r\n}\r\n\r\nconst apiUpdatesManager = new ApiUpdatesManager();\r\nMOUNT_CLASS_TO.apiUpdatesManager = apiUpdatesManager;\r\nexport default apiUpdatesManager\r\n","export default function assumeType<T>(x: unknown): asserts x is T {\r\n  return; // ¯\\_(ツ)_/¯\r\n}\r\n"],"sourceRoot":""}