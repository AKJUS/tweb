{"version":3,"sources":["webpack:///./src/helpers/cleanSearchText.ts","webpack:///./src/helpers/cleanUsername.ts","webpack:///./src/lib/appManagers/appUsersManager.ts","webpack:///./src/lib/appManagers/appPeersManager.ts","webpack:///./src/lib/appManagers/appChatsManager.ts","webpack:///./src/lib/appManagers/apiUpdatesManager.ts","webpack:///./src/lib/searchIndex.ts","webpack:///./src/lib/mtproto/mtproto_config.ts","webpack:///./src/helpers/dom/htmlToSpan.ts"],"names":["badCharsRe","trimRe","cleanSearchText","text","latinize","hasTag","charAt","replace","ch","latinizeCh","LatinizeMap","undefined","toLowerCase","cleanUsername","username","appUsersManager","storage","appStateManager","storages","users","updateUsersStatuses","timestampNow","i","this","user","status","_","expires","was_online","rootScope","dispatchEvent","id","setUserToStateIfNeeded","clear","setInterval","addEventListener","addMultipleEventsListeners","updateUserStatus","update","userId","user_id","serverTimeManager","serverTimeOffset","updateUserPhoto","forceUserOnline","photo","console","warn","updateUserName","saveApiUser","Object","assign","first_name","last_name","e","getSelf","contactsIndex","indexObject","getUserSearchText","getState","then","state","storagesResults","length","contactsList","Array","isArray","forEach","pushContact","contactsFillPromise","Promise","resolve","peerId","getFromCache","set","getUser","delete","isPeerNeeded","usernames","Set","updatedContactsList","pushToState","promise","invokeApi","result","saveApiUsers","contacts","contact","onContactsModified","slice","resolvedPeer","appChatsManager","saveApiChats","chats","appPeersManager","getPeer","getPeerId","peer","add","requestPeer","phone","pFlags","self","format","filter","Boolean","join","query","includeSaved","fillContacts","_contactsList","results","search","has","sort","userId1","userId2","sortName1","sortName","sortName2","localeCompare","testSelfSearch","findAndSplice","p","myId","unshift","block","getInputPeerById","value","apiUpdatesManager","processUpdateMessage","peer_id","getOutputPeer","blocked","index","apiUsers","override","oldUser","min","fullName","searchUsername","deleted","initials","getAbbreviation","changedTitle","formatted","access_hash","key","args","isBot","support","date","now","Date","d","getDate","getMonth","getHours","getMinutes","bot","isRegularUser","isContact","allowMin","eventTimestamp","timestamp","updatesState","syncLoading","getTopPeersPromise","topPeers","correspondents","offset","limit","hash","peerIds","categories","peers","map","topPeer","contactsBlocked","count","u","concat","c","q","my_results","offline","showPhone","getUserInput","add_phone_privacy_exception","updates","onContactUpdated","userIds","DialogColorsFg","DialogColors","DialogColorsMap","updatePeerBlocked","hasRights","getUserPhoto","getChatPhoto","chat","getChat","migrated_to","deactivated","plainText","onlyFirstName","title","trim","split","wrapEmojiText","chatId","isChannel","channel_id","chat_id","getUserString","getChatString","isUser","peerParams","substr","isMegagroup","isBroadcast","ignorePeerId","getChannelInputPeer","getChatInputPeer","pic","getDialogType","onChatUpdated","updateChannelParticipant","clearCache","params","channel","updateChatDefaultBannedRights","default_banned_rights","apiChats","saveApiChat","oldChat","participants_count","changedPhoto","photo_id","rights","defaultRights","action","isThread","kicked","left","megagroup","creator","admin_rights","banned_rights","myFlags","post_messages","delete_messages","broadcast","until_date","bind","good","about","channelId","input","getChannelInput","usersInputs","fwdLimit","fwd_limit","deleteChatUser","leaveChannel","leaveChat","deleteChannel","deleteChat","find","bool","inputFile","inputChatPhoto","file","participant","getParticipantPeerId","actor_id","qts","prev_participant","new_participant","keys","kicked_by","editBanned","view_messages","pendingPtsUpdates","pendingSeqUpdates","syncPending","channelStates","attached","log","Error","Warn","Log","debug","updateMessage","options","processOpts","seq","seqStart","seq_start","forceGetDifference","processUpdate","isOut","out","fromId","from_id","toId","message","fwd_from","reply_to","entities","pts","pts_count","Proxy","target","saveUpdatesState","us","nextSeq","pendingUpdatesData","saveUpdate","popPendingSeqUpdate","seqAwaiting","ptsAwaiting","clearTimeout","timeout","curState","getChannelState","a","b","curPts","goodPts","goodIndex","splice","getDifference","first","wasSyncing","differenceResult","other_updates","new_messages","apiMessage","nextState","intermediate_state","justAName","channelState","getChannelDifference","addChannelState","lastPtsUpdateTime","toPeerId","fwdHeader","reason","hasUser","post","hasChat","popPts","popSeq","push","window","setTimeout","popPendingPtsUpdate","_state","noErrorBox","stateResult","setUpdatesProcessor","setProxy","SearchIndex","cleanText","fullTexts","Map","searchText","newFoundObjs","queryWords","queryWordsLength","fullText","what","found","word","idx","indexOf","o","REPLIES_PEER_ID","htmlToSpan","html","span","document","createElement","innerHTML"],"mappings":"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","file":"3.bb925ea01d08900017e6.chunk.js","sourcesContent":["/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport Config from \"../lib/config\";\n\nconst badCharsRe = /[`~!@#$%^&*()\\-_=+\\[\\]\\\\|{}'\";:\\/?.>,<]+/g;\nconst trimRe = /^\\s+|\\s$/g;\n\nexport default function cleanSearchText(text: string, latinize = true) {\n  const hasTag = text.charAt(0) === '%';\n  text = text.replace(badCharsRe, '').replace(trimRe, '');\n  if(latinize) {\n    text = text.replace(/[^A-Za-z0-9]/g, (ch) => {\n      const latinizeCh = Config.LatinizeMap[ch];\n      return latinizeCh !== undefined ? latinizeCh : ch;\n    });\n  }\n  \n  text = text.toLowerCase();\n  if(hasTag) {\n    text = '%' + text;\n  }\n\n  return text;\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nexport default function cleanUsername(username: string) {\n  return username && username.toLowerCase() || '';\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport { formatPhoneNumber } from \"../../components/misc\";\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\nimport cleanSearchText from \"../../helpers/cleanSearchText\";\nimport cleanUsername from \"../../helpers/cleanUsername\";\nimport { tsNow } from \"../../helpers/date\";\nimport { safeReplaceObject, isObject } from \"../../helpers/object\";\nimport { InputUser, Update, User as MTUser, UserStatus } from \"../../layer\";\nimport I18n, { i18n, LangPackKey } from \"../langPack\";\n//import apiManager from '../mtproto/apiManager';\nimport apiManager from '../mtproto/mtprotoworker';\nimport { REPLIES_PEER_ID } from \"../mtproto/mtproto_config\";\nimport serverTimeManager from \"../mtproto/serverTimeManager\";\nimport { RichTextProcessor } from \"../richtextprocessor\";\nimport rootScope from \"../rootScope\";\nimport SearchIndex from \"../searchIndex\";\nimport apiUpdatesManager from \"./apiUpdatesManager\";\nimport appChatsManager from \"./appChatsManager\";\nimport appPeersManager from \"./appPeersManager\";\nimport appStateManager from \"./appStateManager\";\n\n// TODO: updateUserBlocked\n\nexport type User = MTUser.user;\n\nexport class AppUsersManager {\n  private storage = appStateManager.storages.users;\n  \n  private users: {[userId: number]: User};\n  private usernames: {[username: string]: number};\n  private contactsIndex: SearchIndex<number>;\n  private contactsFillPromise: Promise<Set<number>>;\n  private contactsList: Set<number>;\n  private updatedContactsList: boolean;\n  \n  private getTopPeersPromise: Promise<number[]>;\n\n  constructor() {\n    this.clear();\n\n    setInterval(this.updateUsersStatuses, 60000);\n\n    rootScope.addEventListener('state_synchronized', this.updateUsersStatuses);\n\n    rootScope.addMultipleEventsListeners({\n      updateUserStatus: (update) => {\n        const userId = update.user_id;\n        const user = this.users[userId];\n        if(user) {\n          user.status = update.status;\n          if(user.status) {\n            if('expires' in user.status) {\n              user.status.expires -= serverTimeManager.serverTimeOffset;\n            }\n\n            if('was_online' in user.status) {\n              user.status.was_online -= serverTimeManager.serverTimeOffset;\n            }\n          }\n\n          //user.sortStatus = this.getUserStatusForSort(user.status);\n          rootScope.dispatchEvent('user_update', userId);\n          this.setUserToStateIfNeeded(user);\n        } //////else console.warn('No user by id:', userId);\n      },\n\n      updateUserPhoto: (update) => {\n        const userId = update.user_id;\n        const user = this.users[userId];\n        if(user) {\n          this.forceUserOnline(userId);\n\n          if(update.photo._ === 'userProfilePhotoEmpty') {\n            delete user.photo;\n          } else {\n            user.photo = safeReplaceObject(user.photo, update.photo);\n          }\n\n          this.setUserToStateIfNeeded(user);\n\n          rootScope.dispatchEvent('user_update', userId);\n          rootScope.dispatchEvent('avatar_update', userId);\n        } else console.warn('No user by id:', userId);\n      },\n\n      updateUserName: (update) => {\n        const userId = update.user_id;\n        const user = this.users[userId];\n        if(user) {\n          this.forceUserOnline(userId);\n          \n          this.saveApiUser(Object.assign({}, user, {\n            first_name: update.first_name,\n            last_name: update.last_name,\n            username: update.username\n          }), true);\n        }\n      }\n    });\n\n    /* case 'updateContactLink':\n    this.onContactUpdated(update.user_id, update.my_link._ === 'contactLinkContact');\n    break; */\n\n    rootScope.addEventListener('language_change', (e) => {\n      const userId = this.getSelf().id;\n      this.contactsIndex.indexObject(userId, this.getUserSearchText(userId));\n    });\n\n    appStateManager.getState().then((state) => {\n      const users = appStateManager.storagesResults.users;\n      if(users.length) {\n        this.users = {};\n        for(let i = 0, length = users.length; i < length; ++i) {\n          const user = users[i];\n          if(user) {\n            this.users[user.id] = user;\n          }\n        }\n      }\n\n      const contactsList = state.contactsList;\n      if(contactsList && Array.isArray(contactsList)) {\n        contactsList.forEach(userId => {\n          this.pushContact(userId);\n        });\n\n        if(contactsList.length) {\n          this.contactsFillPromise = Promise.resolve(this.contactsList);\n        }\n      }\n\n      appStateManager.addEventListener('peerNeeded', (peerId: number) => {\n        if(peerId < 0 || this.storage.getFromCache(peerId)) {\n          return;\n        }\n\n        this.storage.set({\n          [peerId]: this.getUser(peerId)\n        });\n      });\n\n      appStateManager.addEventListener('peerUnneeded', (peerId: number) => {\n        if(peerId < 0 || !this.storage.getFromCache(peerId)) {\n          return;\n        }\n\n        this.storage.delete(peerId);\n      });\n    });\n  }\n\n  public clear() {\n    if(this.users) {\n      for(const userId in this.users) {\n        if(!appStateManager.isPeerNeeded(+userId)) {\n          const user = this.users[userId];\n          if(user.username) {\n            delete this.usernames[cleanUsername(user.username)];\n          }\n  \n          delete this.users[userId];\n        }\n      }\n    } else {\n      this.users = {};\n      this.usernames = {};\n    }\n    \n    this.contactsIndex = new SearchIndex();\n    this.contactsFillPromise = undefined;\n    this.contactsList = new Set();\n    this.updatedContactsList = false;\n  }\n\n  private onContactsModified() {\n    const contactsList = [...this.contactsList];\n    appStateManager.pushToState('contactsList', contactsList);\n  }\n\n  public fillContacts() {\n    if(this.contactsFillPromise && this.updatedContactsList) {\n      return this.contactsFillPromise;\n    }\n\n    this.updatedContactsList = true;\n\n    const promise = apiManager.invokeApi('contacts.getContacts').then((result) => {\n      if(result._ === 'contacts.contacts') {\n        this.saveApiUsers(result.users);\n\n        result.contacts.forEach((contact) => {\n          this.pushContact(contact.user_id);\n        });\n\n        this.onContactsModified();\n      }\n\n      this.contactsFillPromise = promise;\n\n      return this.contactsList;\n    });\n\n    return this.contactsFillPromise || (this.contactsFillPromise = promise);\n  }\n\n  public resolveUsername(username: string) {\n    if(username[0] === '@') {\n      username = username.slice(1);\n    }\n\n    username = username.toLowerCase();\n    if(this.usernames[username]) {\n      return Promise.resolve(this.users[this.usernames[username]]);\n    }\n\n    return apiManager.invokeApi('contacts.resolveUsername', {username}).then(resolvedPeer => {\n      this.saveApiUsers(resolvedPeer.users);\n      appChatsManager.saveApiChats(resolvedPeer.chats);\n\n      return appPeersManager.getPeer(appPeersManager.getPeerId(resolvedPeer.peer));\n    });\n  }\n\n  public pushContact(userId: number) {\n    this.contactsList.add(userId);\n    this.contactsIndex.indexObject(userId, this.getUserSearchText(userId));\n    appStateManager.requestPeer(userId, 'contacts');\n  }\n\n  public getUserSearchText(id: number) {\n    const user = this.users[id];\n    if(!user) {\n      return '';\n    }\n\n    const arr: string[] = [\n      user.first_name,\n      user.last_name,\n      user.phone,\n      user.username,\n      user.pFlags.self ? I18n.format('SavedMessages', true) : '',\n      user.pFlags.self ? 'Saved Messages' : ''\n    ];\n\n    return arr.filter(Boolean).join(' ');\n  }\n\n  public getContacts(query?: string, includeSaved = false) {\n    return this.fillContacts().then(_contactsList => {\n      let contactsList = [..._contactsList];\n      if(query) {\n        const results = this.contactsIndex.search(query);\n        const filteredContactsList = [...contactsList].filter(id => results.has(id));\n\n        contactsList = filteredContactsList;\n      }\n\n      contactsList.sort((userId1: number, userId2: number) => {\n        const sortName1 = (this.users[userId1] || {}).sortName || '';\n        const sortName2 = (this.users[userId2] || {}).sortName || '';\n\n        return sortName1.localeCompare(sortName2);\n      });\n\n      if(includeSaved) {\n        if(this.testSelfSearch(query)) {\n          contactsList.findAndSplice(p => p === rootScope.myId);\n          contactsList.unshift(rootScope.myId);\n        }\n      }\n\n      /* contactsList.sort((userId1: number, userId2: number) => {\n        const sortName1 = (this.users[userId1] || {}).sortName || '';\n        const sortName2 = (this.users[userId2] || {}).sortName || '';\n        if(sortName1 === sortName2) {\n          return 0;\n        } \n        \n        return sortName1 > sortName2 ? 1 : -1;\n      }); */\n\n      return contactsList;\n    });\n  }\n\n  public toggleBlock(peerId: number, block: boolean) {\n    return apiManager.invokeApi(block ? 'contacts.block' : 'contacts.unblock', {\n      id: appPeersManager.getInputPeerById(peerId)\n    }).then(value => {\n      if(value) {\n        apiUpdatesManager.processUpdateMessage({\n          _: 'updateShort',\n          update: {\n            _: 'updatePeerBlocked',\n            peer_id: appPeersManager.getOutputPeer(peerId),\n            blocked: block\n          } as Update.updatePeerBlocked\n        });\n      }\n\n      return value;\n    });\n  }\n\n  public testSelfSearch(query: string) {\n    const user = this.getSelf();\n    const index = new SearchIndex();\n    index.indexObject(user.id, this.getUserSearchText(user.id));\n    return index.search(query).has(user.id);\n  }\n\n  public saveApiUsers(apiUsers: any[], override?: boolean) {\n    apiUsers.forEach((user) => this.saveApiUser(user, override));\n  }\n\n  public saveApiUser(user: MTUser, override?: boolean) {\n    if(user._ === 'userEmpty') return;\n\n    const userId = user.id;\n    const oldUser = this.users[userId];\n\n    if(oldUser && !override) {\n      return;\n    }\n\n    if(user.pFlags === undefined) {\n      user.pFlags = {};\n    }\n\n    if(user.pFlags.min && oldUser !== undefined) {\n      return;\n    }\n\n    // * exclude from state\n    // defineNotNumerableProperties(user, ['initials', 'num', 'rFirstName', 'rFullName', 'rPhone', 'sortName', 'sortStatus']);\n\n    const fullName = user.first_name + ' ' + (user.last_name || '');\n    if(user.username) {\n      const searchUsername = cleanUsername(user.username);\n      this.usernames[searchUsername] = userId;\n    }\n\n    user.sortName = user.pFlags.deleted ? '' : cleanSearchText(fullName, false);\n\n    user.initials = RichTextProcessor.getAbbreviation(fullName);\n\n    if(user.status) {\n      if((user.status as UserStatus.userStatusOnline).expires) {\n        (user.status as UserStatus.userStatusOnline).expires -= serverTimeManager.serverTimeOffset;\n      }\n\n      if((user.status as UserStatus.userStatusOffline).was_online) {\n        (user.status as UserStatus.userStatusOffline).was_online -= serverTimeManager.serverTimeOffset;\n      }\n    }\n\n    //user.sortStatus = user.pFlags.bot ? -1 : this.getUserStatusForSort(user.status);\n\n    let changedTitle = false;\n    if(oldUser === undefined) {\n      this.users[userId] = user;\n    } else {\n      if(user.first_name !== oldUser.first_name \n        || user.last_name !== oldUser.last_name \n        || user.username !== oldUser.username) {\n        changedTitle = true;\n      }\n\n      /* if(user.pFlags.bot && user.bot_info_version !== oldUser.bot_info_version) {\n        \n      } */\n\n      safeReplaceObject(oldUser, user);\n      rootScope.dispatchEvent('user_update', userId);\n    }\n\n    if(changedTitle) {\n      rootScope.dispatchEvent('peer_title_edit', user.id);\n    }\n\n    this.setUserToStateIfNeeded(user);\n  }\n\n  public setUserToStateIfNeeded(user: User) {\n    if(appStateManager.isPeerNeeded(user.id)) {\n      this.storage.set({\n        [user.id]: user\n      });\n    }\n  }\n\n  public formatUserPhone(phone: string) {\n    return '+' + formatPhoneNumber(phone).formatted;\n  }\n\n  public getUserStatusForSort(status: User['status'] | number) {\n    if(typeof(status) === 'number') {\n      status = this.getUser(status).status;\n    }\n\n    if(status) {\n      const expires = status._ === 'userStatusOnline' ? status.expires : (status._ === 'userStatusOffline' ? status.was_online : 0);\n      if(expires) {\n        return expires;\n      }\n\n      /* const timeNow = tsNow(true);\n      switch(status._) {\n        case 'userStatusRecently':\n          return timeNow - 86400 * 3;\n        case 'userStatusLastWeek':\n          return timeNow - 86400 * 7;\n        case 'userStatusLastMonth':\n          return timeNow - 86400 * 30;\n      } */\n      switch(status._) {\n        case 'userStatusRecently':\n          return 3;\n        case 'userStatusLastWeek':\n          return 2;\n        case 'userStatusLastMonth':\n          return 1;\n      }\n    }\n\n    return 0;\n  }\n\n  public getUser(id: any): User {\n    if(isObject(id)) {\n      return id;\n    }\n\n    return this.users[id] || {id: id, pFlags: {deleted: true}, access_hash: ''} as User;\n  }\n\n  public getSelf() {\n    return this.getUser(rootScope.myId);\n  }\n\n  public getUserStatusString(userId: number): HTMLElement {\n    let key: LangPackKey;\n    let args: any[];\n\n    switch(userId) {\n      case REPLIES_PEER_ID:\n        key = 'Peer.RepliesNotifications';\n        break;\n      case 777000:\n        key = 'Peer.ServiceNotifications';\n        break;\n      default: {\n        if(this.isBot(userId)) {\n          key = 'Bot';\n          break;\n        }\n\n        const user = this.getUser(userId);\n        if(!user) {\n          key = '' as any;\n          break;\n        }\n\n        if(user.pFlags.support) {\n          key = 'SupportStatus';\n          break;\n        }\n\n        switch(user.status?._) {\n          case 'userStatusRecently': {\n            key = 'Lately';\n            break;\n          }\n    \n          case 'userStatusLastWeek': {\n            key = 'WithinAWeek';\n            break;\n          }\n    \n          case 'userStatusLastMonth': {\n            key = 'WithinAMonth';\n            break;\n          }\n          \n          case 'userStatusOffline': {\n            const date = user.status.was_online;\n            const now = Date.now() / 1000;\n            \n            if((now - date) < 60) {\n              key = 'Peer.Status.justNow';\n            } else if((now - date) < 3600) {\n              key = 'Peer.Status.minAgo';\n              const c = (now - date) / 60 | 0;\n              args = [c];\n            } else if(now - date < 86400) {\n              key = 'LastSeen.HoursAgo';\n              const c = (now - date) / 3600 | 0;\n              args = [c];\n            } else {\n              key = 'Peer.Status.LastSeenAt';\n              const d = new Date(date * 1000);\n              args = [('0' + d.getDate()).slice(-2) + '.' + ('0' + (d.getMonth() + 1)).slice(-2), \n                ('0' + d.getHours()).slice(-2) + ':' + ('0' + d.getMinutes()).slice(-2)];\n            }\n            \n            break;\n          }\n    \n          case 'userStatusOnline': {\n            key = 'Online';\n            break;\n          }\n    \n          default: {\n            key = 'ALongTimeAgo';\n            break;\n          }\n        }\n\n        break;\n      }\n    }\n    \n    return i18n(key, args);\n  }\n\n  public isBot(id: number) {\n    return this.users[id] && this.users[id].pFlags.bot;\n  }\n\n  public isContact(id: number) {\n    return this.contactsList.has(id);\n  }\n  \n  public isRegularUser(id: number) {\n    const user = this.users[id];\n    return user && !this.isBot(id) && !user.pFlags.deleted && !user.pFlags.support;\n  }\n\n  public isNonContactUser(id: number) {\n    return this.isRegularUser(id) && !this.isContact(id) && id !== rootScope.myId;\n  }\n\n  public hasUser(id: number, allowMin?: boolean) {\n    var user = this.users[id];\n    return isObject(user) && (allowMin || !user.pFlags.min);\n  }\n\n  public canSendToUser(id: number) {\n    const user = this.getUser(id);\n    return !user.pFlags.deleted && user.username !== 'replies';\n  }\n\n  public getUserPhoto(id: number) {\n    const user = this.getUser(id);\n\n    return user && user.photo || {\n      _: 'userProfilePhotoEmpty'\n    };\n  }\n\n  public getUserString(id: number) {\n    const user = this.getUser(id);\n    return 'u' + id + (user.access_hash ? '_' + user.access_hash : '');\n  }\n\n  public getUserInput(id: number): InputUser {\n    const user = this.getUser(id);\n    if(user.pFlags && user.pFlags.self) {\n      return {_: 'inputUserSelf'};\n    }\n\n    return {\n      _: 'inputUser',\n      user_id: id,\n      access_hash: user.access_hash\n    };\n  }\n\n  public updateUsersStatuses = () => {\n    const timestampNow = tsNow(true);\n    for(const i in this.users) {\n      const user = this.users[i];\n\n      if(user.status &&\n        user.status._ === 'userStatusOnline' &&\n        user.status.expires < timestampNow) {\n\n        user.status = {_: 'userStatusOffline', was_online: user.status.expires};\n        rootScope.dispatchEvent('user_update', user.id);\n\n        this.setUserToStateIfNeeded(user);\n      }\n    }\n  };\n\n  public forceUserOnline(id: number, eventTimestamp?: number) {\n    if(this.isBot(id)) {\n      return;\n    }\n\n    const timestamp = tsNow(true);\n    const onlineTimeFor = 60;\n    if(eventTimestamp) {\n      if((timestamp - eventTimestamp) >= onlineTimeFor) {\n        return;\n      }\n    } else if(apiUpdatesManager.updatesState.syncLoading) {\n      return;\n    }\n\n    const user = this.getUser(id);\n    if(user &&\n      user.status &&\n      user.status._ !== 'userStatusOnline' &&\n      user.status._ !== 'userStatusEmpty' &&\n      !user.pFlags.support &&\n      !user.pFlags.deleted) {\n\n      user.status = {\n        _: 'userStatusOnline',\n        expires: timestamp + onlineTimeFor\n      };\n      \n      //user.sortStatus = this.getUserStatusForSort(user.status);\n      rootScope.dispatchEvent('user_update', id);\n\n      this.setUserToStateIfNeeded(user);\n    }\n  }\n\n  /* function importContact (phone, firstName, lastName) {\n      return MtpApiManager.invokeApi('contacts.importContacts', {\n        contacts: [{\n          _: 'inputPhoneContact',\n          client_id: '1',\n          phone: phone,\n          first_name: firstName,\n          last_name: lastName\n        }],\n        replace: false\n      }).then(function (importedContactsResult) {\n        saveApiUsers(importedContactsResult.users)\n\n        var foundUserID = false\n        angular.forEach(importedContactsResult.imported, function (importedContact) {\n          onContactUpdated(foundUserID = importedContact.user_id, true)\n        })\n\n        return foundUserID || false\n      })\n  }\n\n  function importContacts (contacts) {\n    var inputContacts = [],\n      i\n    var j\n\n    for (i = 0; i < contacts.length; i++) {\n      for (j = 0; j < contacts[i].phones.length; j++) {\n        inputContacts.push({\n          _: 'inputPhoneContact',\n          client_id: (i << 16 | j).toString(10),\n          phone: contacts[i].phones[j],\n          first_name: contacts[i].first_name,\n          last_name: contacts[i].last_name\n        })\n      }\n    }\n\n    return MtpApiManager.invokeApi('contacts.importContacts', {\n      contacts: inputContacts,\n      replace: false\n    }).then(function (importedContactsResult) {\n      saveApiUsers(importedContactsResult.users)\n\n      var result = []\n      angular.forEach(importedContactsResult.imported, function (importedContact) {\n        onContactUpdated(importedContact.user_id, true)\n        result.push(importedContact.user_id)\n      })\n\n      return result\n    })\n  } */\n\n  /* public deleteContacts(userIds: number[]) {\n    var ids: any[] = [];\n    userIds.forEach((userId) => {\n      ids.push(this.getUserInput(userId));\n    })\n\n    return apiManager.invokeApi('contacts.deleteContacts', {\n      id: ids\n    }).then(() => {\n      userIds.forEach((userId) => {\n        this.onContactUpdated(userId, false);\n      });\n    });\n  } */\n\n  public getTopPeers(): Promise<number[]> {\n    if(this.getTopPeersPromise) return this.getTopPeersPromise;\n\n    return this.getTopPeersPromise = appStateManager.getState().then((state) => {\n      if(state?.topPeers?.length) {\n        return state.topPeers;\n      }\n\n      return apiManager.invokeApi('contacts.getTopPeers', {\n        correspondents: true,\n        offset: 0,\n        limit: 15,\n        hash: 0,\n      }).then((result) => {\n        let peerIds: number[] = [];\n        if(result._ === 'contacts.topPeers') {\n          //console.log(result);\n          this.saveApiUsers(result.users);\n          appChatsManager.saveApiChats(result.chats);\n\n          if(result.categories.length) {\n            peerIds = result.categories[0].peers.map((topPeer) => {\n              const peerId = appPeersManager.getPeerId(topPeer.peer);\n              appStateManager.requestPeer(peerId, 'topPeer');\n              return peerId;\n            });\n          }\n        }\n  \n        appStateManager.pushToState('topPeers', peerIds);\n  \n        return peerIds;\n      });\n    });\n  }\n\n  public getBlocked(offset = 0, limit = 0) {\n    return apiManager.invokeApi('contacts.getBlocked', {offset, limit}).then(contactsBlocked => {\n      this.saveApiUsers(contactsBlocked.users);\n      appChatsManager.saveApiChats(contactsBlocked.chats);\n      const count = contactsBlocked._ === 'contacts.blocked' ? contactsBlocked.users.length + contactsBlocked.chats.length : contactsBlocked.count;\n\n      const peerIds = contactsBlocked.users.map(u => u.id).concat(contactsBlocked.chats.map(c => -c.id));\n\n      return {count, peerIds};\n    });\n  }\n\n  /* public searchContacts(query: string, limit = 20) {\n    return Promise.all([\n      this.getContacts(query),\n      apiManager.invokeApi('contacts.search', {\n        q: query,\n        limit\n      })\n    ]).then(results => {\n      const [myContacts, peers] = results;\n\n      this.saveApiUsers(peers.users);\n      appChatsManager.saveApiChats(peers.chats);\n\n      // * contacts.search returns duplicates in my_results\n      const myResults = new Set(myContacts.concat(peers.my_results.map(p => appPeersManager.getPeerID(p))));\n\n      const out = {\n        my_results: [...myResults].slice(0, limit),\n        results: peers.results.map(p => appPeersManager.getPeerID(p))\n      };\n\n      return out;\n    });\n  } */\n  public searchContacts(query: string, limit = 20) {\n    return apiManager.invokeApi('contacts.search', {\n      q: query,\n      limit\n    }).then(peers => {\n      this.saveApiUsers(peers.users);\n      appChatsManager.saveApiChats(peers.chats);\n\n      const out = {\n        my_results: [...new Set(peers.my_results.map(p => appPeersManager.getPeerId(p)))], // ! contacts.search returns duplicates in my_results\n        results: peers.results.map(p => appPeersManager.getPeerId(p))\n      };\n\n      return out;\n    });\n  }\n\n  private onContactUpdated(userId: number, isContact: boolean) {\n    const curIsContact = this.isContact(userId);\n    if(isContact !== curIsContact) {\n      if(isContact) {\n        this.pushContact(userId);\n      } else {\n        this.contactsList.delete(userId);\n      }\n\n      this.onContactsModified();\n\n      rootScope.dispatchEvent('contacts_update', userId);\n    }\n  }\n\n  public updateUsername(username: string) {\n    return apiManager.invokeApi('account.updateUsername', {\n      username\n    }).then((user) => {\n      this.saveApiUser(user);\n    });\n  }\n\n  public setUserStatus(userId: number, offline: boolean) {\n    if(this.isBot(userId)) {\n      return;\n    }\n\n    const user = this.users[userId];\n    if(user) {\n      const status: any = offline ? {\n        _: 'userStatusOffline',\n        was_online: tsNow(true)\n      } : {\n        _: 'userStatusOnline',\n        expires: tsNow(true) + 500\n      };\n\n      user.status = status;\n      //user.sortStatus = this.getUserStatusForSort(user.status);\n      rootScope.dispatchEvent('user_update', userId);\n    }\n  }\n\n  public addContact(userId: number, first_name: string, last_name: string, phone: string, showPhone?: true) {\n    return apiManager.invokeApi('contacts.addContact', {\n      id: this.getUserInput(userId),\n      first_name,\n      last_name,\n      phone,\n      add_phone_privacy_exception: showPhone\n    }).then((updates) => {\n      apiUpdatesManager.processUpdateMessage(updates, {override: true});\n\n      this.onContactUpdated(userId, true);\n    });\n  }\n\n  public deleteContacts(userIds: number[]) {\n    return apiManager.invokeApi('contacts.deleteContacts', {\n      id: userIds.map(userId => this.getUserInput(userId))\n    }).then((updates) => {\n      apiUpdatesManager.processUpdateMessage(updates, {override: true});\n\n      userIds.forEach(userId => {\n        this.onContactUpdated(userId, false);\n      });\n    });\n  }\n}\n\nconst appUsersManager = new AppUsersManager();\nMOUNT_CLASS_TO.appUsersManager = appUsersManager;\nexport default appUsersManager\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport type { ChatPhoto, DialogPeer, InputDialogPeer, InputNotifyPeer, InputPeer, Peer, Update, UserProfilePhoto } from \"../../layer\";\nimport type { LangPackKey } from \"../langPack\";\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\nimport { isObject } from \"../../helpers/object\";\nimport { RichTextProcessor } from \"../richtextprocessor\";\nimport rootScope from \"../rootScope\";\nimport appChatsManager from \"./appChatsManager\";\nimport appUsersManager from \"./appUsersManager\";\nimport I18n from '../langPack';\n\n// https://github.com/eelcohn/Telegram-API/wiki/Calculating-color-for-a-Telegram-user-on-IRC\n/*\n  HTML-color  IRC-color  Description\n  #c03d33     4          red\n  #4fad2d     3          green\n  #d09306     7          yellow\n  #168acd     10         blue\n  #8544d6     6          purple\n  #cd4073     13         pink\n  #2996ad     11         sea\n  #ce671b     5          orange\n  */\nconst DialogColorsFg = ['#fc5c51', '#0fb297', '#d09306', '#3d72ed', '#895dd5', '#cd4073', '#00c1a6', '#fa790f'];\nconst DialogColors = ['red', 'green', 'yellow', 'blue', 'violet', 'pink', 'cyan', 'orange'];\nconst DialogColorsMap = [0, 7, 4, 1, 6, 3, 5];\n\nexport type PeerType = 'channel' | 'chat' | 'megagroup' | 'group' | 'saved';\nexport class AppPeersManager {\n  constructor() {\n    rootScope.addMultipleEventsListeners({\n      updatePeerBlocked: (update) => {\n        rootScope.dispatchEvent('peer_block', {peerId: this.getPeerId(update.peer_id), blocked: update.blocked});\n      }\n    });\n  }\n  /* public savePeerInstance(peerId: number, instance: any) {\n    if(peerId < 0) appChatsManager.saveApiChat(instance);\n    else appUsersManager.saveApiUser(instance);\n  } */\n\n  public canPinMessage(peerId: number) {\n    return peerId > 0 || appChatsManager.hasRights(-peerId, 'pin_messages');\n  }\n\n  public getPeerPhoto(peerId: number): UserProfilePhoto.userProfilePhoto | ChatPhoto.chatPhoto {\n    const photo = peerId > 0\n      ? appUsersManager.getUserPhoto(peerId)\n      : appChatsManager.getChatPhoto(-peerId);\n\n    return photo._ !== 'chatPhotoEmpty' && photo._ !== 'userProfilePhotoEmpty' ? photo : null;\n  }\n\n  public getPeerMigratedTo(peerId: number) {\n    if(peerId >= 0) {\n      return false;\n    }\n\n    let chat = appChatsManager.getChat(-peerId);\n    if(chat && chat.migrated_to && chat.pFlags.deactivated) {\n      return this.getPeerId(chat.migrated_to);\n    }\n    \n    return false;\n  }\n\n  public getPeerTitle(peerId: number | any, plainText = false, onlyFirstName = false) {\n    if(!peerId) {\n      peerId = rootScope.myId;\n    }\n    \n    let peer: any = {}; \n    if(!isObject(peerId)) {\n      peer = this.getPeer(peerId);\n    } else peer = peerId;\n\n    let title = '';\n    if(peerId > 0) {\n      if(peer.first_name) title += peer.first_name;\n      if(peer.last_name) title += ' ' + peer.last_name;\n  \n      if(!title) title = peer.pFlags.deleted ? I18n.format('HiddenName', true) : peer.username;\n      else title = title.trim();\n    } else {\n      title = peer.title;\n    }\n\n    if(onlyFirstName) {\n      title = title.split(' ')[0];\n    }\n    \n    return plainText ? title : RichTextProcessor.wrapEmojiText(title);\n  }\n  \n  public getOutputPeer(peerId: number): Peer {\n    if(peerId > 0) {\n      return {_: 'peerUser', user_id: peerId};\n    }\n\n    let chatId = -peerId;\n    if(appChatsManager.isChannel(chatId)) {\n      return {_: 'peerChannel', channel_id: chatId};\n    }\n\n    return {_: 'peerChat', chat_id: chatId};\n  }\n\n  public getPeerString(peerId: number) {\n    if(peerId > 0) {\n      return appUsersManager.getUserString(peerId);\n    }\n    return appChatsManager.getChatString(-peerId);\n  }\n\n  public getPeerUsername(peerId: number): string {\n    if(peerId > 0) {\n      return appUsersManager.getUser(peerId).username || '';\n    }\n    return appChatsManager.getChat(-peerId).username || '';\n  }\n\n  public getPeer(peerId: number) {\n    return peerId > 0\n      ? appUsersManager.getUser(peerId)\n      : appChatsManager.getChat(-peerId)\n  }\n\n  public getPeerId(peerId: Peer | InputPeer | number | string): number {\n    if(typeof(peerId) === 'number') return peerId;\n    else if(isObject(peerId)) return (peerId as Peer.peerUser).user_id || -((peerId as Peer.peerChannel).channel_id || (peerId as Peer.peerChat).chat_id);\n    else if(!peerId) return 0;\n    \n    const isUser = (peerId as string).charAt(0) === 'u';\n    const peerParams = (peerId as string).substr(1).split('_');\n\n    return isUser ? +peerParams[0] : -peerParams[0] || 0;\n  }\n\n  public getDialogPeer(peerId: number): DialogPeer {\n    return {\n      _: 'dialogPeer',\n      peer: this.getOutputPeer(peerId)\n    };\n  }\n\n  public isChannel(peerId: number): boolean {\n    return (peerId < 0) && appChatsManager.isChannel(-peerId);\n  }\n\n  public isMegagroup(peerId: number) {\n    return (peerId < 0) && appChatsManager.isMegagroup(-peerId);\n  }\n\n  public isAnyGroup(peerId: number): boolean {\n    return (peerId < 0) && !appChatsManager.isBroadcast(-peerId);\n  }\n\n  public isBroadcast(peerId: number): boolean {\n    return this.isChannel(peerId) && !this.isMegagroup(peerId);\n  }\n\n  public isBot(peerId: number): boolean {\n    return (peerId > 0) && appUsersManager.isBot(peerId);\n  }\n\n  /* public getInputPeer(peerString: string): InputPeer {\n    var firstChar = peerString.charAt(0);\n    var peerParams = peerString.substr(1).split('_');\n    let id = +peerParams[0];\n\n    if(firstChar === 'u') {\n      //appUsersManager.saveUserAccess(id, peerParams[1]);\n\n      return {\n        _: 'inputPeerUser',\n        user_id: id,\n        access_hash: peerParams[1]\n      };\n    } else if(firstChar === 'c' || firstChar === 's') {\n      //appChatsManager.saveChannelAccess(id, peerParams[1]);\n      if(firstChar === 's') {\n        appChatsManager.saveIsMegagroup(id);\n      }\n\n      return {\n        _: 'inputPeerChannel',\n        channel_id: id,\n        access_hash: peerParams[1] || '0'\n      };\n    } else {\n      return {\n        _: 'inputPeerChat',\n        chat_id: id\n      };\n    }\n  } */\n\n  public getInputNotifyPeerById(peerId: number, ignorePeerId: true): Exclude<InputNotifyPeer, InputNotifyPeer.inputNotifyPeer>;\n  public getInputNotifyPeerById(peerId: number, ignorePeerId?: false): InputNotifyPeer.inputNotifyPeer;\n  public getInputNotifyPeerById(peerId: number, ignorePeerId?: boolean): InputNotifyPeer {\n    if(ignorePeerId) {\n      if(peerId > 0) {\n        return {_: 'inputNotifyUsers'};\n      } else {\n        if(appPeersManager.isBroadcast(peerId)) {\n          return {_: 'inputNotifyBroadcasts'};\n        } else {\n          return {_: 'inputNotifyChats'};\n        }\n      }\n    } else {\n      return {\n        _: 'inputNotifyPeer', \n        peer: this.getInputPeerById(peerId)\n      };\n    }\n  }\n\n  public getInputPeerById(peerId: number): InputPeer {\n    if(!peerId) {\n      return {_: 'inputPeerEmpty'};\n    }\n\n    if(peerId < 0) {\n      const chatId = -peerId;\n      if(!appChatsManager.isChannel(chatId)) {\n        return appChatsManager.getChatInputPeer(chatId);\n      } else {\n        return appChatsManager.getChannelInputPeer(chatId);\n      }\n    }\n\n    return {\n      _: 'inputPeerUser',\n      user_id: peerId,\n      access_hash: appUsersManager.getUser(peerId).access_hash\n    };\n  }\n\n  public getInputDialogPeerById(peerId: number): InputDialogPeer {\n    return {\n      _: 'inputDialogPeer',\n      peer: this.getInputPeerById(peerId)\n    }\n  }\n\n  public getPeerColorById(peerId: number, pic = true) {\n    if(!peerId) return '';\n\n    const idx = DialogColorsMap[(peerId < 0 ? -peerId : peerId) % 7];\n    const color = (pic ? DialogColors : DialogColorsFg)[idx];\n    return color;\n  }\n\n  public getPeerSearchText(peerId: number) {\n    let text;\n    if(peerId > 0) {\n      text = '%pu ' + appUsersManager.getUserSearchText(peerId);\n    } else if(peerId < 0) {\n      const chat = appChatsManager.getChat(-peerId);\n      text = '%pg ' + (chat.title || '');\n    }\n    return text;\n  }\n\n  public getDialogType(peerId: number): PeerType {\n    if(appPeersManager.isMegagroup(peerId)) {\n      return 'megagroup';\n    } else if(appPeersManager.isChannel(peerId)) {\n      return 'channel';\n    } else if(peerId < 0) {\n      return 'group';\n    } else {\n      return peerId === rootScope.myId ? 'saved' : 'chat';\n    }\n  }\n\n  public getDeleteButtonText(peerId: number): LangPackKey {\n    switch(this.getDialogType(peerId)) {\n      case 'channel':\n        return 'ChatList.Context.LeaveChannel';\n\n      case 'megagroup':\n        return 'ChatList.Context.LeaveGroup';\n\n      case 'group':\n        return 'ChatList.Context.DeleteAndExit';\n      \n      default:\n        return 'ChatList.Context.DeleteChat';\n    }\n  }\n}\n\nconst appPeersManager = new AppPeersManager();\nMOUNT_CLASS_TO.appPeersManager = appPeersManager;\nexport default appPeersManager;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\nimport { isObject, safeReplaceObject, copy, deepEqual } from \"../../helpers/object\";\nimport { ChannelParticipant, Chat, ChatAdminRights, ChatBannedRights, ChatParticipant, ChatPhoto, InputChannel, InputChatPhoto, InputFile, InputPeer, Update, Updates } from \"../../layer\";\nimport apiManagerProxy from \"../mtproto/mtprotoworker\";\nimport apiManager from '../mtproto/mtprotoworker';\nimport { RichTextProcessor } from \"../richtextprocessor\";\nimport rootScope from \"../rootScope\";\nimport apiUpdatesManager from \"./apiUpdatesManager\";\nimport appPeersManager from \"./appPeersManager\";\nimport appStateManager from \"./appStateManager\";\nimport appUsersManager from \"./appUsersManager\";\n\nexport type Channel = Chat.channel;\n\nexport type ChatRights = keyof ChatBannedRights['pFlags'] | keyof ChatAdminRights['pFlags'] | 'change_type' | 'change_permissions' | 'delete_chat' | 'view_participants';\n\nexport class AppChatsManager {\n  private storage = appStateManager.storages.chats;\n  \n  private chats: {[id: number]: Chat.channel | Chat.chat | any};\n  //private usernames: any;\n  //private channelAccess: any;\n  //private megagroups: {[id: number]: true};\n\n  constructor() {\n    this.clear();\n\n    rootScope.addMultipleEventsListeners({\n      /* updateChannel: (update) => {\n        const channelId = update.channel_id;\n        //console.log('updateChannel:', update);\n        rootScope.broadcast('channel_settings', {channelId});\n      }, */\n\n      updateChannelParticipant: (update) => {\n        apiManagerProxy.clearCache('channels.getParticipants', (params) => {\n          return (params.channel as InputChannel.inputChannel).channel_id === update.channel_id;\n        });\n      },\n\n      updateChatDefaultBannedRights: (update) => {\n        const chatId = -appPeersManager.getPeerId(update.peer);\n        const chat: Chat.chat = this.chats[chatId];\n        if(chat) {\n          chat.default_banned_rights = update.default_banned_rights;\n          rootScope.dispatchEvent('chat_update', chatId);\n        }\n      }\n    });\n\n    appStateManager.getState().then((state) => {\n      const chats = appStateManager.storagesResults.chats;\n      if(chats.length) {\n        this.chats = {};\n        for(let i = 0, length = chats.length; i < length; ++i) {\n          const chat = chats[i];\n          if(chat) {\n            this.chats[chat.id] = chat;\n          }\n        }\n      }\n\n      appStateManager.addEventListener('peerNeeded', (peerId: number) => {\n        if(peerId > 0 || this.storage.getFromCache(-peerId)) {\n          return;\n        }\n\n        this.storage.set({\n          [-peerId]: this.getChat(-peerId)\n        });\n      });\n\n      appStateManager.addEventListener('peerUnneeded', (peerId: number) => {\n        if(peerId > 0 || !this.storage.getFromCache(-peerId)) {\n          return;\n        }\n\n        this.storage.delete(-peerId);\n      });\n    });\n  }\n\n  public clear() {\n    if(this.chats) {\n      for(const chatId in this.chats) {\n        if(!appStateManager.isPeerNeeded(-+chatId)) {\n          /* const chat = this.chats[chatId];\n          if(chat.username) {\n            delete this.usernames[cleanUsername(chat.username)];\n          } */\n  \n          delete this.chats[chatId];\n        }\n      }\n    } else {\n      this.chats = {};\n    }\n  }\n\n  public saveApiChats(apiChats: any[], override?: boolean) {\n    apiChats.forEach(chat => this.saveApiChat(chat, override));\n  }\n\n  public saveApiChat(chat: Chat, override?: boolean) {\n    if(chat._ === 'chatEmpty') return;\n    /* if(chat._ !== 'chat' && chat._ !== 'channel') {\n      return;\n    } */\n    \n    // * exclude from state\n    // defineNotNumerableProperties(chat, ['rTitle', 'initials']);\n\n    const oldChat: Exclude<Chat, Chat.chatEmpty> = this.chats[chat.id];\n\n    /* if(oldChat && !override) {\n      return;\n    } */\n\n    if((chat as Chat.chat).pFlags === undefined) {\n      (chat as Chat.chat).pFlags = {};\n    }\n\n    if((chat as Chat.channel).pFlags.min && oldChat !== undefined) {\n      return;\n    }\n\n    chat.initials = RichTextProcessor.getAbbreviation(chat.title);\n\n    if(chat._ === 'channel' &&\n        chat.participants_count === undefined &&\n        oldChat !== undefined &&\n        (oldChat as Chat.channel).participants_count) {\n      chat.participants_count = (oldChat as Chat.channel).participants_count;\n    }\n\n    /* if(chat.username) {\n      let searchUsername = searchIndexManager.cleanUsername(chat.username);\n      this.usernames[searchUsername] = chat.id;\n    } */\n\n    let changedPhoto = false, changedTitle = false;\n    if(oldChat === undefined) {\n      this.chats[chat.id] = chat;\n    } else {\n      const oldPhotoId = ((oldChat as Chat.chat).photo as ChatPhoto.chatPhoto)?.photo_id;\n      const newPhotoId = ((chat as Chat.chat).photo as ChatPhoto.chatPhoto)?.photo_id;\n      if(oldPhotoId !== newPhotoId) {\n        changedPhoto = true;\n      }\n\n      if(oldChat.title !== chat.title) {\n        changedTitle = true;\n      }\n\n      safeReplaceObject(oldChat, chat);\n      rootScope.dispatchEvent('chat_update', chat.id);\n    }\n\n    if(changedPhoto) {\n      rootScope.dispatchEvent('avatar_update', -chat.id);\n    }\n\n    if(changedTitle) {\n      rootScope.dispatchEvent('peer_title_edit', -chat.id);\n    }\n\n    if(appStateManager.isPeerNeeded(-chat.id)) {\n      this.storage.set({\n        [chat.id]: chat\n      });\n    }\n  }\n\n  public getChat(id: number) {\n    if(id < 0) id = -id;\n    return this.chats[id] || {_: 'chatEmpty', id, deleted: true, access_hash: '', pFlags: {}/* this.channelAccess[id] */};\n  }\n\n  public combineParticipantBannedRights(id: number, rights: ChatBannedRights) {\n    const chat: Chat.channel = this.getChat(id);\n\n    if(chat.default_banned_rights) {\n      rights = copy(rights);\n      const defaultRights = chat.default_banned_rights.pFlags;\n      for(let i in defaultRights) {\n        // @ts-ignore\n        rights.pFlags[i] = defaultRights[i];\n      }\n    }\n\n    return rights;\n  }\n\n  public hasRights(id: number, action: ChatRights, rights?: ChatAdminRights | ChatBannedRights, isThread?: boolean) {\n    const chat: Chat = this.getChat(id);\n    if(chat._ === 'chatEmpty') return false;\n\n    if(chat._ === 'chatForbidden' ||\n        chat._ === 'channelForbidden' ||\n        (chat as Chat.chat).pFlags.kicked ||\n        (chat.pFlags.left && !(chat as Chat.channel).pFlags.megagroup)) {\n      return false;\n    }\n\n    if(chat.pFlags.creator && rights === undefined) {\n      return true;\n    }\n\n    if(!rights) {\n      rights = chat.admin_rights || (chat as Chat.channel).banned_rights || chat.default_banned_rights;\n\n      if(!rights) {\n        return false;\n      }\n    }\n\n    let myFlags: Partial<{[flag in keyof ChatBannedRights['pFlags'] | keyof ChatAdminRights['pFlags']]: true}> = {};\n    if(rights) {\n      myFlags = rights.pFlags as any;\n    }\n\n    switch(action) {\n      case 'embed_links':\n      case 'send_games':\n      case 'send_gifs':\n      case 'send_inline':\n      case 'send_media':\n      case 'send_messages':\n      case 'send_polls':\n      case 'send_stickers': {\n        if(!isThread && chat.pFlags.left) {\n          return false;\n        }\n\n        if(rights._ === 'chatBannedRights' && myFlags[action]) {\n          return false;\n        }\n\n        if(chat._ === 'channel') {\n          if(!chat.pFlags.megagroup && !myFlags.post_messages) {\n            return false;\n          }\n        }\n\n        break;\n      }\n\n      // * revoke foreign messages\n      case 'delete_messages': {\n        return !!myFlags.delete_messages;\n      }\n\n      case 'pin_messages': {\n        return rights._ === 'chatAdminRights' ? myFlags[action] || !!myFlags.post_messages : !myFlags[action];\n      }\n\n      case 'invite_users':\n      case 'change_info': {\n        return rights._ === 'chatAdminRights' ? myFlags[action] : !myFlags[action];\n      }\n\n      // * only creator can do that\n      case 'change_type':\n      case 'delete_chat': {\n        return false;\n      }\n\n      case 'change_permissions': {\n        return rights._ === 'chatAdminRights' && myFlags['ban_users'];\n      }\n\n      case 'view_participants': {\n        return !!(chat._ === 'chat' || !chat.pFlags.broadcast || chat.pFlags.creator || chat.admin_rights);\n      }\n    }\n\n    return true;\n  }\n\n  public editChatDefaultBannedRights(id: number, banned_rights: ChatBannedRights) {\n    const chat: Chat.chat = this.getChat(id);\n    if(chat.default_banned_rights) {\n      if(chat.default_banned_rights.until_date === banned_rights.until_date && deepEqual(chat.default_banned_rights.pFlags, banned_rights.pFlags)) {\n        return Promise.resolve();\n      }\n    }\n    \n    return apiManager.invokeApi('messages.editChatDefaultBannedRights', {\n      peer: appPeersManager.getInputPeerById(-id),\n      banned_rights\n    }).then(this.onChatUpdated.bind(this, id));\n  }\n\n  /* public resolveUsername(username: string) {\n    return this.usernames[username] || 0;\n  } */\n\n  /* public saveChannelAccess(id: number, accessHash: string) {\n    this.channelAccess[id] = accessHash;\n  } */\n\n  /* public saveIsMegagroup(id: number) {\n    this.megagroups[id] = true;\n  } */\n\n  public isChannel(id: number) {\n    const chat = this.chats[id];\n    return chat && (chat._ === 'channel' || chat._ === 'channelForbidden')/*  || this.channelAccess[id] */;\n  }\n\n  public isMegagroup(id: number) {\n    /* if(this.megagroups[id]) {\n      return true;\n    } */\n\n    const chat = this.chats[id];\n    return chat && chat._ === 'channel' && chat.pFlags.megagroup;\n  }\n\n  public isBroadcast(id: number) {\n    return this.isChannel(id) && !this.isMegagroup(id);\n  }\n\n  public isInChat(id: number) {\n    let good = true;\n    const chat: Chat = this.getChat(id);\n    if(chat._ === 'channelForbidden' \n      || chat._ === 'chatForbidden' \n      || chat._ === 'chatEmpty' \n      || (chat as Chat.chat).pFlags.left \n      || (chat as Chat.chat).pFlags.kicked \n      || (chat as Chat.chat).pFlags.deactivated) {\n      good = false;\n    }\n\n    return good;\n  }\n\n  public getChannelInput(id: number): InputChannel {\n    const chat: Chat = this.getChat(id);\n    if(chat._ === 'chatEmpty' || !(chat as Chat.channel).access_hash) {\n      return {\n        _: 'inputChannelEmpty'\n      };\n    } else {\n      return {\n        _: 'inputChannel',\n        channel_id: id,\n        access_hash: (chat as Chat.channel).access_hash/*  || this.channelAccess[id] */ || '0'\n      };\n    }\n  }\n\n  public getChatInputPeer(id: number): InputPeer.inputPeerChat {\n    return {\n      _: 'inputPeerChat',\n      chat_id: id\n    };\n  }\n\n  public getChannelInputPeer(id: number): InputPeer.inputPeerChannel {\n    return {\n      _: 'inputPeerChannel',\n      channel_id: id,\n      access_hash: this.getChat(id).access_hash/*  || this.channelAccess[id] */ || 0\n    };\n  }\n\n  public hasChat(id: number, allowMin?: true) {\n    const chat = this.chats[id]\n    return isObject(chat) && (allowMin || !chat.pFlags.min);\n  }\n\n  public getChatPhoto(id: number) {\n    const chat: Chat.chat = this.getChat(id);\n\n    return chat && chat.photo || {\n      _: 'chatPhotoEmpty'\n    };\n  }\n\n  public getChatString(id: number) {\n    const chat = this.getChat(id);\n    if(this.isChannel(id)) {\n      return (this.isMegagroup(id) ? 's' : 'c') + id + '_' + chat.access_hash;\n    }\n    return 'g' + id;\n  }\n\n  /* public wrapForFull(id: number, fullChat: any) {\n    const chatFull = copy(fullChat);\n    const chat = this.getChat(id);\n\n    if(!chatFull.participants_count) {\n      chatFull.participants_count = chat.participants_count;\n    }\n\n    if(chatFull.participants &&\n        chatFull.participants._ === 'chatParticipants') {\n      chatFull.participants.participants = this.wrapParticipants(id, chatFull.participants.participants);\n    }\n\n    if(chatFull.about) {\n      chatFull.rAbout = RichTextProcessor.wrapRichText(chatFull.about, {noLinebreaks: true});\n    }\n\n    //chatFull.peerString = this.getChatString(id);\n    chatFull.chat = chat;\n\n    return chatFull;\n  }\n\n  public wrapParticipants(id: number, participants: any[]) {\n    const chat = this.getChat(id);\n    const myId = appUsersManager.getSelf().id;\n    if(this.isChannel(id)) {\n      const isAdmin = chat.pFlags.creator;\n      participants.forEach((participant) => {\n        participant.canLeave = myId === participant.user_id;\n        participant.canKick = isAdmin && participant._ === 'channelParticipant';\n\n        // just for order by last seen\n        participant.user = appUsersManager.getUser(participant.user_id);\n      });\n    } else {\n      const isAdmin = chat.pFlags.creator || chat.pFlags.admins_enabled && chat.pFlags.admin;\n      participants.forEach((participant) => {\n        participant.canLeave = myId === participant.user_id;\n        participant.canKick = !participant.canLeave && (\n          chat.pFlags.creator ||\n          participant._ === 'chatParticipant' && (isAdmin || myId === participant.inviter_id)\n        );\n\n        // just for order by last seen\n        participant.user = appUsersManager.getUser(participant.user_id);\n      });\n    }\n\n    return participants;\n  } */\n\n  public createChannel(title: string, about: string): Promise<number> {\n    return apiManager.invokeApi('channels.createChannel', {\n      broadcast: true,\n      title,\n      about\n    }).then((updates: any) => {\n      apiUpdatesManager.processUpdateMessage(updates);\n\n      const channelId = updates.chats[0].id;\n      rootScope.dispatchEvent('history_focus', {peerId: -channelId});\n\n      return channelId;\n    });\n  }\n\n  public inviteToChannel(id: number, userIds: number[]) {\n    const input = this.getChannelInput(id);\n    const usersInputs = userIds.map(u => appUsersManager.getUserInput(u));\n\n    return apiManager.invokeApi('channels.inviteToChannel', {\n      channel: input,\n      users: usersInputs\n    }).then(updates => {\n      apiUpdatesManager.processUpdateMessage(updates);\n    });\n  }\n\n  public createChat(title: string, userIds: number[]): Promise<number> {\n    return apiManager.invokeApi('messages.createChat', {\n      users: userIds.map(u => appUsersManager.getUserInput(u)),\n      title\n    }).then(updates => {\n      apiUpdatesManager.processUpdateMessage(updates);\n\n      const chatId = (updates as any as Updates.updates).chats[0].id;\n      rootScope.dispatchEvent('history_focus', {peerId: -chatId});\n\n      return chatId;\n    });\n  }\n\n  private onChatUpdated = (chatId: number, updates: any) => {\n    //console.log('onChatUpdated', chatId, updates);\n\n    apiUpdatesManager.processUpdateMessage(updates);\n    if(updates &&\n        /* updates.updates &&\n        updates.updates.length && */\n        this.isChannel(chatId)) {\n      rootScope.dispatchEvent('invalidate_participants', chatId);\n    }\n  };\n\n  public leaveChannel(id: number) {\n    return apiManager.invokeApi('channels.leaveChannel', {\n      channel: this.getChannelInput(id)\n    }).then(this.onChatUpdated.bind(this, id));\n  }\n\n  public joinChannel(id: number) {\n    return apiManager.invokeApi('channels.joinChannel', {\n      channel: this.getChannelInput(id)\n    }).then(this.onChatUpdated.bind(this, id));\n  }\n\n  public addChatUser(id: number, userId: number, fwdLimit = 100) {\n    return apiManager.invokeApi('messages.addChatUser', {\n      chat_id: id,\n      user_id: appUsersManager.getUserInput(userId),\n      fwd_limit: fwdLimit\n    }).then(this.onChatUpdated.bind(this, id));\n  }\n\n  public deleteChatUser(id: number, userId: number) {\n    return apiManager.invokeApi('messages.deleteChatUser', {\n      chat_id: id,\n      user_id: appUsersManager.getUserInput(userId)\n    }).then(this.onChatUpdated.bind(this, id));\n  }\n\n  public leaveChat(id: number) {\n    return this.deleteChatUser(id, appUsersManager.getSelf().id);\n  }\n\n  public leave(id: number) {\n    return this.isChannel(id) ? this.leaveChannel(id) : this.leaveChat(id);\n  }\n\n  public delete(id: number) {\n    return this.isChannel(id) ? this.deleteChannel(id) : this.deleteChat(id);\n  }\n\n  public deleteChannel(id: number) {\n    return apiManager.invokeApi('channels.deleteChannel', {\n      channel: this.getChannelInput(id)\n    }).then(this.onChatUpdated.bind(this, id));\n  }\n\n  public deleteChat(id: number) {\n    //return this.leaveChat(id).then(() => {\n      return apiManager.invokeApi('messages.deleteChat', {\n        chat_id: id\n      });\n    //});\n  }\n\n  public migrateChat(id: number): Promise<number> {\n    const chat: Chat = this.getChat(id);\n    if(chat._ === 'channel') return Promise.resolve(chat.id);\n    return apiManager.invokeApi('messages.migrateChat', {\n      chat_id: id\n    }).then((updates) => {\n      this.onChatUpdated(id, updates);\n      const update: Update.updateChannel = (updates as Updates.updates).updates.find(u => u._ === 'updateChannel') as any;\n      return update.channel_id;\n    });\n  }\n\n  public updateUsername(id: number, username: string) {\n    return apiManager.invokeApi('channels.updateUsername', {\n      channel: this.getChannelInput(id),\n      username\n    }).then((bool) => {\n      if(bool) {\n        const chat: Chat.channel = this.getChat(id);\n        chat.username = username;\n      }\n\n      return bool;\n    });\n  }\n\n  public editPhoto(id: number, inputFile: InputFile) {\n    const inputChatPhoto: InputChatPhoto = {\n      _: 'inputChatUploadedPhoto',\n      file: inputFile\n    };\n\n    let promise: any;\n    if(this.isChannel(id)) {\n      promise = apiManager.invokeApi('channels.editPhoto', {\n        channel: this.getChannelInput(id),\n        photo: inputChatPhoto\n      });\n    } else {\n      promise = apiManager.invokeApi('messages.editChatPhoto', {\n        chat_id: id,\n        photo: inputChatPhoto\n      });\n    }\n\n    return promise.then((updates: any) => {\n      apiUpdatesManager.processUpdateMessage(updates);\n    });\n  }\n\n  public editTitle(id: number, title: string) {\n    let promise: any;\n\n    if(this.isChannel(id)) {\n      promise = apiManager.invokeApi('channels.editTitle', {\n        channel: this.getChannelInput(id),\n        title\n      });\n    } else {\n      promise = apiManager.invokeApi('messages.editChatTitle', {\n        chat_id: id,\n        title\n      });\n    }\n\n    return promise.then((updates: any) => {\n      apiUpdatesManager.processUpdateMessage(updates);\n    });\n  }\n\n  public editAbout(id: number, about: string) {\n    return apiManager.invokeApi('messages.editChatAbout', {\n      peer: appPeersManager.getInputPeerById(-id),\n      about\n    }).then(bool => {\n      //apiUpdatesManager.processUpdateMessage(updates);\n      rootScope.dispatchEvent('peer_bio_edit', -id);\n    });\n  }\n\n  public getParticipantPeerId(participant: ChannelParticipant | ChatParticipant) {\n    const peerId = (participant as ChannelParticipant.channelParticipantBanned).peer ? \n      appPeersManager.getPeerId((participant as ChannelParticipant.channelParticipantBanned).peer) : \n      (participant as ChatParticipant.chatParticipant).user_id;\n    return peerId;\n  }\n\n  public editBanned(id: number, participant: number | ChannelParticipant, banned_rights: ChatBannedRights) {\n    const peerId = typeof(participant) === 'number' ? participant : this.getParticipantPeerId(participant);\n    return apiManager.invokeApi('channels.editBanned', {\n      channel: this.getChannelInput(id),\n      participant: appPeersManager.getInputPeerById(peerId),\n      banned_rights\n    }).then((updates) => {\n      this.onChatUpdated(id, updates);\n\n      if(typeof(participant) !== 'number') {\n        const timestamp = Date.now() / 1000 | 0;\n        apiUpdatesManager.processUpdateMessage({\n          _: 'updateShort',\n          update: {\n            _: 'updateChannelParticipant',\n            channel_id: id,\n            date: timestamp,\n            actor_id: undefined,\n            qts: undefined,\n            user_id: peerId,\n            prev_participant: participant,\n            new_participant: Object.keys(banned_rights.pFlags).length ? {\n              _: 'channelParticipantBanned',\n              date: timestamp,\n              banned_rights,\n              kicked_by: appUsersManager.getSelf().id,\n              peer: appPeersManager.getOutputPeer(peerId),\n              pFlags: {}\n            } : undefined\n          } as Update.updateChannelParticipant\n        });\n      }\n    });\n  }\n\n  public clearChannelParticipantBannedRights(id: number, participant: number | ChannelParticipant) {\n    return this.editBanned(id, participant, {\n      _: 'chatBannedRights',\n      until_date: 0,\n      pFlags: {}\n    });\n  }\n  \n  public kickFromChannel(id: number, participant: number | ChannelParticipant) {\n    return this.editBanned(id, participant, {\n      _: 'chatBannedRights',\n      until_date: 0,\n      pFlags: {\n        view_messages: true\n      }\n    });\n  }\n}\n\nconst appChatsManager = new AppChatsManager();\nMOUNT_CLASS_TO.appChatsManager = appChatsManager;\nexport default appChatsManager;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\n//import apiManager from '../mtproto/apiManager';\nimport DEBUG, { MOUNT_CLASS_TO } from '../../config/debug';\nimport { Update } from '../../layer';\nimport { logger, LogTypes } from '../logger';\nimport apiManager from '../mtproto/mtprotoworker';\nimport rootScope from '../rootScope';\n//import networkerFactory from '../mtproto/networkerFactory';\nimport appUsersManager from \"./appUsersManager\";\nimport appChatsManager from \"./appChatsManager\";\nimport appPeersManager from \"./appPeersManager\";\nimport appStateManager from './appStateManager';\n\ntype UpdatesState = {\n  pendingPtsUpdates: {pts: number, pts_count: number}[],\n  pendingSeqUpdates?: {[seq: number]: {seq: number, date: number, updates: any[]}},\n  syncPending: {\n    seqAwaiting?: number,\n    ptsAwaiting?: true,\n    timeout: number\n  },\n  syncLoading: Promise<void>,\n\n  seq?: number,\n  pts?: number,\n  date?: number,\n  lastPtsUpdateTime?: number\n};\n\nconst SYNC_DELAY = 6;\n\nexport class ApiUpdatesManager {\n  public updatesState: UpdatesState = {\n    pendingPtsUpdates: [],\n    pendingSeqUpdates: {},\n    syncPending: null,\n    syncLoading: null\n  };\n\n  private channelStates: {[channelId: number]: UpdatesState} = {};\n  private attached = false;\n\n  private log = logger('UPDATES', LogTypes.Error | LogTypes.Warn | LogTypes.Log/*  | LogTypes.Debug */);\n  private debug = DEBUG;\n\n  private setProxy() {\n    const self = this;\n    this.updatesState = new Proxy(this.updatesState, {\n      set: function(target: ApiUpdatesManager['updatesState'], key: keyof ApiUpdatesManager['updatesState'], value: ApiUpdatesManager['updatesState'][typeof key]) {\n        // @ts-ignore\n        target[key] = value;\n        self.saveUpdatesState();\n        return true;\n      }\n    });\n  }\n\n  public saveUpdatesState() {\n    const us = this.updatesState;\n    appStateManager.pushToState('updates', {\n      seq: us.seq,\n      pts: us.pts,\n      date: us.date\n    });\n  }\n\n  private popPendingSeqUpdate() {\n    const state = this.updatesState;\n    const nextSeq = state.seq + 1;\n    const pendingUpdatesData = state.pendingSeqUpdates[nextSeq];\n    if(!pendingUpdatesData) {\n      return false;\n    }\n\n    const updates = pendingUpdatesData.updates;\n    for(let i = 0, length = updates.length; i < length; ++i) {\n      this.saveUpdate(updates[i]);\n    }\n\n    state.seq = pendingUpdatesData.seq;\n    if(pendingUpdatesData.date && state.date < pendingUpdatesData.date) {\n      state.date = pendingUpdatesData.date;\n    }\n    delete state.pendingSeqUpdates[nextSeq];\n  \n    if(!this.popPendingSeqUpdate() &&\n      state.syncPending &&\n      state.syncPending.seqAwaiting &&\n      state.seq >= state.syncPending.seqAwaiting) {\n      if(!state.syncPending.ptsAwaiting) {\n        clearTimeout(state.syncPending.timeout);\n        state.syncPending = null;\n      } else {\n        delete state.syncPending.seqAwaiting;\n      }\n    }\n  \n    return true;\n  }\n\n  private popPendingPtsUpdate(channelId: number) {\n    const curState = channelId ? this.getChannelState(channelId) : this.updatesState;\n    if(!curState.pendingPtsUpdates.length) {\n      return false;\n    }\n\n    curState.pendingPtsUpdates.sort((a, b) => {\n      return a.pts - b.pts;\n    });\n    // this.log('pop update', channelId, curState.pendingPtsUpdates)\n  \n    let curPts = curState.pts;\n    let goodPts = 0;\n    let goodIndex = 0;\n    for(let i = 0, length = curState.pendingPtsUpdates.length; i < length; ++i) {\n      const update = curState.pendingPtsUpdates[i];\n      curPts += update.pts_count;\n      if(curPts >= update.pts) {\n        goodPts = update.pts;\n        goodIndex = i;\n      }\n    }\n  \n    if(!goodPts) {\n      return false;\n    }\n  \n    this.debug && this.log.debug('pop pending pts updates', goodPts, curState.pendingPtsUpdates.slice(0, goodIndex + 1));\n  \n    curState.pts = goodPts;\n    for(let i = 0; i <= goodIndex; ++i) {\n      const update = curState.pendingPtsUpdates[i];\n\n      // @ts-ignore\n      this.saveUpdate(update);\n    }\n    curState.pendingPtsUpdates.splice(0, goodIndex + 1);\n  \n    if(!curState.pendingPtsUpdates.length && curState.syncPending) {\n      if(!curState.syncPending.seqAwaiting) {\n        clearTimeout(curState.syncPending.timeout);\n        curState.syncPending = null;\n      } else {\n        delete curState.syncPending.ptsAwaiting;\n      }\n    }\n  \n    return true;\n  }\n\n  public forceGetDifference() {\n    if(!this.updatesState.syncLoading) {\n      this.getDifference();\n    }\n  }\n\n  public processUpdateMessage = (updateMessage: any, options: Partial<{\n    override: boolean\n  }> = {}) => {\n    // return forceGetDifference()\n    const processOpts = {\n      date: updateMessage.date,\n      seq: updateMessage.seq,\n      seqStart: updateMessage.seq_start,\n      //ignoreSyncLoading: options.ignoreSyncLoading\n    };\n\n    this.debug && this.log.debug('processUpdateMessage', updateMessage);\n  \n    switch(updateMessage._) {\n      case 'updatesTooLong':\n      case 'new_session_created':\n        this.forceGetDifference();\n        break;\n  \n      case 'updateShort':\n        this.processUpdate(updateMessage.update, processOpts);\n        break;\n  \n      case 'updateShortMessage':\n      case 'updateShortChatMessage': {\n        this.debug && this.log.debug('updateShortMessage | updateShortChatMessage', {...updateMessage});\n        const isOut = updateMessage.pFlags.out;\n        const fromId = updateMessage.from_id || (isOut ? rootScope.myId : updateMessage.user_id);\n        const toId = updateMessage.chat_id\n          ? -updateMessage.chat_id\n          : (updateMessage.user_id || rootScope.myId);\n  \n        this.processUpdate({\n          _: 'updateNewMessage',\n          message: {\n            _: 'message',\n            pFlags: updateMessage.pFlags,\n            id: updateMessage.id,\n            from_id: appPeersManager.getOutputPeer(fromId),\n            peer_id: appPeersManager.getOutputPeer(toId),\n            date: updateMessage.date,\n            message: updateMessage.message,\n            fwd_from: updateMessage.fwd_from,\n            reply_to: updateMessage.reply_to,\n            entities: updateMessage.entities\n          },\n          pts: updateMessage.pts,\n          pts_count: updateMessage.pts_count\n        }, processOpts);\n        break;\n      }\n  \n      case 'updatesCombined':\n      case 'updates':\n        appUsersManager.saveApiUsers(updateMessage.users, options.override);\n        appChatsManager.saveApiChats(updateMessage.chats, options.override);\n  \n        updateMessage.updates.forEach((update: any) => {\n          this.processUpdate(update, processOpts);\n        });\n        break;\n  \n      default:\n        this.log.warn('Unknown update message', updateMessage);\n    }\n  };\n  \n  private getDifference(first = false): Promise<void> {\n    // this.trace('Get full diff')\n    const updatesState = this.updatesState;\n    let wasSyncing = updatesState.syncLoading;\n    if(!wasSyncing) {\n      updatesState.pendingSeqUpdates = {};\n      updatesState.pendingPtsUpdates = [];\n    }\n  \n    if(updatesState.syncPending) {\n      clearTimeout(updatesState.syncPending.timeout);\n      updatesState.syncPending = null;\n    }\n\n    const promise = apiManager.invokeApi('updates.getDifference', {\n      pts: updatesState.pts, \n      // pts_total_limit: 1200,\n      date: updatesState.date, \n      qts: -1\n    }, {\n      timeout: 0x7fffffff\n    }).then((differenceResult) => {\n      this.debug && this.log.debug('Get diff result', differenceResult);\n\n      if(differenceResult._ === 'updates.differenceEmpty') {\n        this.debug && this.log.debug('apply empty diff', differenceResult.seq);\n        updatesState.date = differenceResult.date;\n        updatesState.seq = differenceResult.seq;\n        return;\n      }\n\n      // ! SORRY I'M SORRY I'M SORRY\n      if(first) {\n        rootScope.dispatchEvent('state_synchronizing');\n      }\n\n      if(differenceResult._ !== 'updates.differenceTooLong') {\n        appUsersManager.saveApiUsers(differenceResult.users);\n        appChatsManager.saveApiChats(differenceResult.chats);\n\n        // Should be first because of updateMessageID\n        // this.log('applying', differenceResult.other_updates.length, 'other updates')\n    \n        differenceResult.other_updates.forEach((update) => {\n          switch(update._) {\n            case 'updateChannelTooLong':\n            case 'updateNewChannelMessage':\n            case 'updateEditChannelMessage':\n              this.processUpdate(update);\n              return;\n          }\n          \n          this.saveUpdate(update);\n        });\n\n        // this.log('applying', differenceResult.new_messages.length, 'new messages')\n        differenceResult.new_messages.forEach((apiMessage) => {\n          this.saveUpdate({\n            _: 'updateNewMessage',\n            message: apiMessage,\n            pts: updatesState.pts,\n            pts_count: 0\n          });\n        });\n\n        const nextState = differenceResult._ === 'updates.difference' ? differenceResult.state : differenceResult.intermediate_state;\n        updatesState.seq = nextState.seq;\n        updatesState.pts = nextState.pts;\n        updatesState.date = nextState.date;\n      } else {\n        updatesState.pts = differenceResult.pts;\n        delete updatesState.seq;\n        delete updatesState.date;\n        \n        this.channelStates = {};\n        \n        rootScope.dispatchEvent('state_cleared');\n      }\n  \n      // this.log('apply diff', updatesState.seq, updatesState.pts)\n  \n      if(differenceResult._ === 'updates.differenceSlice') {\n        return this.getDifference();\n      } else {\n        this.debug && this.log.debug('finished get diff');\n      }\n    });\n\n    if(!wasSyncing) {\n      this.justAName(updatesState, promise);\n    }\n  \n    return promise;\n  }\n\n  private getChannelDifference(channelId: number): Promise<void> {\n    const channelState = this.getChannelState(channelId);\n    const wasSyncing = channelState.syncLoading;\n    if(!wasSyncing) {\n      channelState.pendingPtsUpdates = [];\n    }\n\n    if(channelState.syncPending) {\n      clearTimeout(channelState.syncPending.timeout);\n      channelState.syncPending = null;\n    }\n\n    //this.log.trace('Get channel diff', appChatsManager.getChat(channelId), channelState.pts);\n    const promise = apiManager.invokeApi('updates.getChannelDifference', {\n      channel: appChatsManager.getChannelInput(channelId),\n      filter: {_: 'channelMessagesFilterEmpty'},\n      pts: channelState.pts,\n      limit: 30\n    }, {timeout: 0x7fffffff}).then((differenceResult) => {\n      this.debug && this.log.debug('Get channel diff result', differenceResult)\n      channelState.pts = 'pts' in differenceResult ? differenceResult.pts : undefined;\n  \n      if(differenceResult._ === 'updates.channelDifferenceEmpty') {\n        this.debug && this.log.debug('apply channel empty diff', differenceResult);\n        return;\n      }\n  \n      if(differenceResult._ === 'updates.channelDifferenceTooLong') {\n        this.debug && this.log.debug('channel diff too long', differenceResult);\n        delete this.channelStates[channelId];\n\n        // @ts-ignore\n        this.saveUpdate({_: 'updateChannelReload', channel_id: channelId});\n        return;\n      }\n  \n      appUsersManager.saveApiUsers(differenceResult.users);\n      appChatsManager.saveApiChats(differenceResult.chats);\n  \n      // Should be first because of updateMessageID\n      this.debug && this.log.debug('applying', differenceResult.other_updates.length, 'channel other updates');\n      differenceResult.other_updates.forEach((update) => {\n        this.saveUpdate(update);\n      });\n  \n      this.debug && this.log.debug('applying', differenceResult.new_messages.length, 'channel new messages');\n      differenceResult.new_messages.forEach((apiMessage) => {\n        this.saveUpdate({\n          _: 'updateNewChannelMessage',\n          message: apiMessage,\n          pts: channelState.pts,\n          pts_count: 0\n        });\n      });\n  \n      this.debug && this.log.debug('apply channel diff', channelState.pts);\n  \n      if(differenceResult._ === 'updates.channelDifference' &&\n        !differenceResult.pFlags['final']) {\n        return this.getChannelDifference(channelId);\n      } else {\n        this.debug && this.log.debug('finished channel get diff');\n      }\n    });\n\n    if(!wasSyncing) {\n      this.justAName(channelState, promise, channelId);\n    }\n\n    return promise;\n  }\n\n  private justAName(state: UpdatesState, promise: UpdatesState['syncLoading'], channelId?: number) {\n    state.syncLoading = promise;\n    rootScope.dispatchEvent('state_synchronizing', channelId);\n\n    promise.then(() => {\n      state.syncLoading = null;\n      rootScope.dispatchEvent('state_synchronized', channelId);\n    }, () => {\n      state.syncLoading = null;\n    });\n  }\n  \n  public addChannelState(channelId: number, pts: number) {\n    if(!pts) {\n      throw new Error('Add channel state without pts ' + channelId);\n    }\n\n    if(!(channelId in this.channelStates)) {\n      this.channelStates[channelId] = {\n        pts,\n        pendingPtsUpdates: [],\n        syncPending: null,\n        syncLoading: null\n      };\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public getChannelState(channelId: number, pts?: number) {\n    if(this.channelStates[channelId] === undefined) {\n      this.addChannelState(channelId, pts);\n    }\n\n    return this.channelStates[channelId];\n  }\n\n  private processUpdate(update: any, options: Partial<{\n    date: number,\n    seq: number,\n    seqStart: number/* ,\n    ignoreSyncLoading: boolean */\n  }> = {}) {\n    let channelId = 0;\n    switch(update._) {\n      case 'updateNewChannelMessage':\n      case 'updateEditChannelMessage':\n        channelId = -appPeersManager.getPeerId(update.message.peer_id);\n        break;\n      case 'updateDeleteChannelMessages':\n        channelId = update.channel_id;\n        break;\n      case 'updateChannelTooLong':\n        channelId = update.channel_id;\n        if(!(channelId in this.channelStates)) {\n          return false;\n        }\n        break;\n    }\n  \n    const curState = channelId ? this.getChannelState(channelId, update.pts) : this.updatesState;\n  \n    // this.log.log('process', channelId, curState.pts, update)\n  \n    if(curState.syncLoading/*  && !options.ignoreSyncLoading */) {\n      return false;\n    }\n  \n    if(update._ === 'updateChannelTooLong') {\n      if(!curState.lastPtsUpdateTime ||\n          curState.lastPtsUpdateTime < (Date.now() - SYNC_DELAY)) {\n        // this.log.trace('channel too long, get diff', channelId, update)\n        this.getChannelDifference(channelId);\n      }\n      return false;\n    }\n  \n    if(update._ === 'updateNewMessage' ||\n        update._ === 'updateEditMessage' ||\n        update._ === 'updateNewChannelMessage' ||\n        update._ === 'updateEditChannelMessage') {\n      const message = update.message;\n      const toPeerId = appPeersManager.getPeerId(message.peer_id);\n      const fwdHeader = message.fwd_from || {};\n      let reason: any = false;\n      if(message.from_id && !appUsersManager.hasUser(appPeersManager.getPeerId(message.from_id), message.pFlags.post/* || channelId*/) && (reason = 'author') ||\n          fwdHeader.from_id && !appUsersManager.hasUser(appPeersManager.getPeerId(fwdHeader.from_id), !!fwdHeader.channel_id) && (reason = 'fwdAuthor') ||\n          fwdHeader.channel_id && !appChatsManager.hasChat(fwdHeader.channel_id, true) && (reason = 'fwdChannel') ||\n          toPeerId > 0 && !appUsersManager.hasUser(toPeerId) && (reason = 'toPeer User') ||\n          toPeerId < 0 && !appChatsManager.hasChat(-toPeerId) && (reason = 'toPeer Chat')) {\n        this.log.warn('Not enough data for message update', toPeerId, reason, message)\n        if(channelId && appChatsManager.hasChat(channelId)) {\n          this.getChannelDifference(channelId);\n        } else {\n          this.forceGetDifference();\n        }\n        return false;\n      }\n    } else if(channelId && !appChatsManager.hasChat(channelId)) {\n      // this.log.log('skip update, missing channel', channelId, update)\n      return false;\n    }\n  \n    let popPts: boolean;\n    let popSeq: boolean;\n  \n    if(update.pts) {\n      const newPts = curState.pts + (update.pts_count || 0);\n      if(newPts < update.pts) {\n        this.debug && this.log.warn('Pts hole', curState, update, channelId && appChatsManager.getChat(channelId));\n        curState.pendingPtsUpdates.push(update);\n        if(!curState.syncPending && !curState.syncLoading) {\n          curState.syncPending = {\n            timeout: window.setTimeout(() => {\n              curState.syncPending = null;\n\n              if(curState.syncLoading) {\n                return;\n              }\n\n              if(channelId) {\n                this.getChannelDifference(channelId);\n              } else {\n                this.getDifference();\n              }\n            }, SYNC_DELAY)\n          };\n        }\n\n        curState.syncPending.ptsAwaiting = true;\n        return false;\n      }\n\n      if(update.pts > curState.pts) {\n        curState.pts = update.pts;\n        popPts = true;\n  \n        curState.lastPtsUpdateTime = Date.now();\n      } else if(update.pts_count) {\n        // this.log.warn('Duplicate update', update)\n        return false;\n      }\n\n      if(channelId && options.date && this.updatesState.date < options.date) {\n        this.updatesState.date = options.date;\n      }\n    } else if(!channelId && options.seq > 0) {\n      const seq = options.seq;\n      const seqStart = options.seqStart || seq;\n  \n      if(seqStart !== curState.seq + 1) {\n        if(seqStart > curState.seq) {\n          this.debug && this.log.warn('Seq hole', curState, curState.syncPending && curState.syncPending.seqAwaiting);\n  \n          if(curState.pendingSeqUpdates[seqStart] === undefined) {\n            curState.pendingSeqUpdates[seqStart] = {seq, date: options.date, updates: []};\n          }\n          curState.pendingSeqUpdates[seqStart].updates.push(update);\n  \n          if(!curState.syncPending) {\n            curState.syncPending = {\n              timeout: window.setTimeout(() => {\n                curState.syncPending = null;\n\n                if(curState.syncLoading) {\n                  return;\n                }\n\n                this.getDifference();\n              }, SYNC_DELAY)\n            };\n          }\n\n          if(!curState.syncPending.seqAwaiting ||\n            curState.syncPending.seqAwaiting < seqStart) {\n            curState.syncPending.seqAwaiting = seqStart;\n          }\n          return false;\n        }\n      }\n  \n      if(curState.seq !== seq) {\n        curState.seq = seq;\n        if(options.date && curState.date < options.date) {\n          curState.date = options.date;\n        }\n\n        popSeq = true;\n      }\n    }\n  \n    this.saveUpdate(update);\n  \n    if(popPts) {\n      this.popPendingPtsUpdate(channelId);\n    } else if(popSeq) {\n      this.popPendingSeqUpdate();\n    }\n  }\n\n  public saveUpdate(update: Update) {\n    //this.debug && this.log('saveUpdate', update);\n    rootScope.dispatchEvent(update._, update as any);\n  }\n  \n  public attach() {\n    if(this.attached) return;\n\n    //return;\n\n    this.log('attach');\n    \n    this.attached = true;\n\n    appStateManager.getState().then(_state => {\n      const state = _state.updates;\n\n      //rootScope.broadcast('state_synchronizing');\n      if(!state || !state.pts || !state.date || !state.seq) {\n        this.log('will get new state');\n\n        this.updatesState.syncLoading = new Promise((resolve) => {\n          apiManager.invokeApi('updates.getState', {}, {noErrorBox: true}).then((stateResult) => {\n            this.updatesState.seq = stateResult.seq;\n            this.updatesState.pts = stateResult.pts;\n            this.updatesState.date = stateResult.date;\n            this.saveUpdatesState();\n            //setTimeout(() => {\n              this.updatesState.syncLoading = null;\n              resolve();\n              //rootScope.broadcast('state_synchronized');\n            //}, 1000);\n        \n          // ! for testing\n          // updatesState.seq = 1\n          // updatesState.pts = stateResult.pts - 5000\n          // updatesState.date = 1\n          // getDifference()\n          });\n        });\n      } else {\n        // ! for testing\n        /* state.seq = 1;\n        state.pts = state.pts - 15;\n        state.date = 1; */\n\n        Object.assign(this.updatesState, state);\n        \n        this.log('will get difference', Object.assign({}, state));\n        \n        this.getDifference(true)/* .finally(() => {\n          if(this.updatesState.syncLoading) {\n            rootScope.broadcast('state_synchronizing');\n          }\n        }) */;\n      }\n\n      apiManager.setUpdatesProcessor(this.processUpdateMessage);\n\n      // this.updatesState.syncLoading.then(() => {\n        this.setProxy();\n      // });\n    });\n  }\n}\n\nconst apiUpdatesManager = new ApiUpdatesManager();\nMOUNT_CLASS_TO.apiUpdatesManager = apiUpdatesManager;\nexport default apiUpdatesManager\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport cleanSearchText from '../helpers/cleanSearchText';\n\nexport default class SearchIndex<SearchWhat> {\n  private fullTexts: Map<SearchWhat, string> = new Map();\n\n  constructor(private cleanText = true, private latinize = true) {\n\n  }\n\n  public indexObject(id: SearchWhat, searchText: string) {\n    /* if(searchIndex.fullTexts.hasOwnProperty(id)) {\n      return false;\n    } */\n\n    if(searchText.trim() && this.cleanText) {\n      searchText = cleanSearchText(searchText, this.latinize);\n    }\n\n    if(!searchText) {\n      this.fullTexts.delete(id);\n      return false;\n    }\n\n    this.fullTexts.set(id, searchText);\n    \n    /* const shortIndexes = searchIndex.shortIndexes;\n    searchText.split(' ').forEach((searchWord) => {\n      let len = Math.min(searchWord.length, 3),\n        wordPart, i;\n      for(i = 1; i <= len; i++) {\n        wordPart = searchWord.substr(0, i);\n        if(shortIndexes[wordPart] === undefined) {\n          shortIndexes[wordPart] = [id];\n        } else {\n          shortIndexes[wordPart].push(id);\n        }\n      }\n    }); */\n  }\n\n  public search(query: string) {\n    const fullTexts = this.fullTexts;\n    //const shortIndexes = searchIndex.shortIndexes;\n\n    if(this.cleanText) {\n      query = cleanSearchText(query, this.latinize);\n    }\n\n    const newFoundObjs: Array<{fullText: string, what: SearchWhat}> = [];\n    const queryWords = query.split(' ');\n    const queryWordsLength = queryWords.length;\n    fullTexts.forEach((fullText, what) => {\n      let found = true;\n      for(let i = 0; i < queryWordsLength; ++i) { // * verify that all words are found\n        const word = queryWords[i];\n        const idx = fullText.indexOf(word);\n        if(idx === -1 || (idx !== 0 && fullText[idx - 1] !== ' ')) { // * search only from word beginning\n          found = false;\n          break;\n        }\n      }\n\n      if(found) {\n        newFoundObjs.push({fullText, what});\n      }\n    });\n\n    //newFoundObjs.sort((a, b) => a.fullText.localeCompare(b.fullText));\n    const newFoundObjs2: Set<SearchWhat> = new Set(newFoundObjs.map(o => o.what));\n\n    /* const queryWords = query.split(' ');\n    let foundArr: number[];\n    for(let i = 0; i < queryWords.length; i++) {\n      const newFound = shortIndexes[queryWords[i].substr(0, 3)];\n      if(!newFound) {\n        foundArr = [];\n        break;\n      }\n      \n      if(foundArr === undefined || foundArr.length > newFound.length) {\n        foundArr = newFound;\n      }\n    }\n\n    for(let j = 0; j < foundArr.length; j++) {\n      let found = true;\n      let searchText = fullTexts[foundArr[j]];\n      for(let i = 0; i < queryWords.length; i++) {\n        if(searchText.indexOf(queryWords[i]) === -1) {\n          found = false;\n          break;\n        }\n      }\n\n      if(found) {\n        newFoundObjs[foundArr[j]] = true;\n      }\n    } */\n\n    return newFoundObjs2;\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n/**\n * Legacy Webogram's format, don't change dcID to camelCase. date is timestamp\n */\nexport type UserAuth = {dcID: number | string, date: number, id: number};\n\nexport const REPLIES_PEER_ID = 1271266957;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nexport default function htmlToSpan(html: string) {\n  const span = document.createElement('span');\n  span.innerHTML = html;\n  return span;\n}\n"],"sourceRoot":""}